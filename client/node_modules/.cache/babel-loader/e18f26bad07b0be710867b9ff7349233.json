{"ast":null,"code":"'use strict';\n\nvar _slicedToArray = require(\"/home/ubuntu/TFG_FL/client/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nconst debug = require('debug');\n\nconst log = Object.assign(debug('libp2p:peer-store'), {\n  error: debug('libp2p:peer-store:err')\n});\n\nconst errcode = require('err-code');\n\nconst _require = require('./errors'),\n      ERR_INVALID_PARAMETERS = _require.codes.ERR_INVALID_PARAMETERS;\n\nconst Topology = require('libp2p-interfaces/src/topology');\n/**\n * @typedef {import('peer-id')} PeerId\n * @typedef {import('./peer-store')} PeerStore\n * @typedef {import('./connection-manager')} ConnectionManager\n * @typedef {import('libp2p-interfaces/src/connection').Connection} Connection\n * @typedef {import('libp2p-interfaces/src/topology')} Topology\n */\n\n/**\n * Responsible for notifying registered protocols of events in the network.\n */\n\n\nclass Registrar {\n  /**\n   * @param {Object} props\n   * @param {PeerStore} props.peerStore\n   * @param {ConnectionManager} props.connectionManager\n   * @class\n   */\n  constructor({\n    peerStore,\n    connectionManager\n  }) {\n    // Used on topology to listen for protocol changes\n    this.peerStore = peerStore;\n    this.connectionManager = connectionManager;\n    /**\n     * Map of topologies\n     *\n     * @type {Map<string, object>}\n     */\n\n    this.topologies = new Map();\n    this._handle = undefined;\n    this._onDisconnect = this._onDisconnect.bind(this);\n    this.connectionManager.on('peer:disconnect', this._onDisconnect);\n  }\n\n  get handle() {\n    return this._handle;\n  }\n\n  set handle(handle) {\n    this._handle = handle;\n  }\n  /**\n   * Get a connection with a peer.\n   *\n   * @param {PeerId} peerId\n   * @returns {Connection | null}\n   */\n\n\n  getConnection(peerId) {\n    return this.connectionManager.get(peerId);\n  }\n  /**\n   * Register handlers for a set of multicodecs given\n   *\n   * @param {Topology} topology - protocol topology\n   * @returns {string} registrar identifier\n   */\n\n\n  register(topology) {\n    if (!Topology.isTopology(topology)) {\n      log.error('topology must be an instance of interfaces/topology');\n      throw errcode(new Error('topology must be an instance of interfaces/topology'), ERR_INVALID_PARAMETERS);\n    } // Create topology\n\n\n    const id = (Math.random() * 1e9).toString(36) + Date.now();\n    this.topologies.set(id, topology); // Set registrar\n\n    topology.registrar = this;\n    return id;\n  }\n  /**\n   * Unregister topology.\n   *\n   * @param {string} id - registrar identifier\n   * @returns {boolean} unregistered successfully\n   */\n\n\n  unregister(id) {\n    return this.topologies.delete(id);\n  }\n  /**\n   * Remove a disconnected peer from the record\n   *\n   * @param {Connection} connection\n   * @param {Error} [error]\n   * @returns {void}\n   */\n\n\n  _onDisconnect(connection, error) {\n    for (const _ref of this.topologies) {\n      var _ref2 = _slicedToArray(_ref, 2);\n\n      const topology = _ref2[1];\n      topology.disconnect(connection.remotePeer, error);\n    }\n  }\n\n}\n\nmodule.exports = Registrar;","map":null,"metadata":{},"sourceType":"script"}