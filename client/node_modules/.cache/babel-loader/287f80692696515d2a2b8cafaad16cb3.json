{"ast":null,"code":"'use strict';\n\nclass TimeoutError extends Error {\n  constructor(message) {\n    super(message);\n    this.name = 'TimeoutError';\n  }\n\n}\n\nconst pTimeout = (promise, milliseconds, fallback, options) => {\n  let timer;\n  const cancelablePromise = new Promise((resolve, reject) => {\n    if (typeof milliseconds !== 'number' || milliseconds < 0) {\n      throw new TypeError('Expected `milliseconds` to be a positive number');\n    }\n\n    if (milliseconds === Infinity) {\n      resolve(promise);\n      return;\n    }\n\n    options = {\n      customTimers: {\n        setTimeout,\n        clearTimeout\n      },\n      ...options\n    };\n    timer = options.customTimers.setTimeout.call(undefined, () => {\n      if (typeof fallback === 'function') {\n        try {\n          resolve(fallback());\n        } catch (error) {\n          reject(error);\n        }\n\n        return;\n      }\n\n      const message = typeof fallback === 'string' ? fallback : \"Promise timed out after \".concat(milliseconds, \" milliseconds\");\n      const timeoutError = fallback instanceof Error ? fallback : new TimeoutError(message);\n\n      if (typeof promise.cancel === 'function') {\n        promise.cancel();\n      }\n\n      reject(timeoutError);\n    }, milliseconds);\n\n    (async () => {\n      try {\n        resolve((await promise));\n      } catch (error) {\n        reject(error);\n      } finally {\n        options.customTimers.clearTimeout.call(undefined, timer);\n      }\n    })();\n  });\n\n  cancelablePromise.clear = () => {\n    clearTimeout(timer);\n    timer = undefined;\n  };\n\n  return cancelablePromise;\n};\n\nmodule.exports = pTimeout; // TODO: Remove this for the next major release\n\nmodule.exports.default = pTimeout;\nmodule.exports.TimeoutError = TimeoutError;","map":null,"metadata":{},"sourceType":"script"}