{"ast":null,"code":"'use strict';\n\nconst _require = require('interface-datastore'),\n      Key = _require.Key,\n      Errors = _require.Errors,\n      Adapter = _require.Adapter,\n      _require$utils = _require.utils,\n      filter = _require$utils.filter,\n      map = _require$utils.map,\n      take = _require$utils.take,\n      sortAll = _require$utils.sortAll;\n/**\n * @typedef {import('interface-datastore').Datastore} Datastore\n * @typedef {import('interface-datastore').Pair} Pair\n * @typedef {import('interface-datastore').Batch} Batch\n * @typedef {import('interface-datastore').Query} Query\n * @typedef {import('interface-datastore').Options} QueryOptions\n */\n\n/**\n * A datastore backed by leveldb.\n *\n * @implements {Datastore}\n */\n\n\nclass LevelDatastore extends Adapter {\n  /**\n   * @param {any} path\n   * @param {Object} [opts]\n   * @param {any} [opts.db] - level db reference\n   * @param {boolean} [opts.createIfMissing]\n   * @param {boolean} [opts.errorIfExists]\n   */\n  constructor(path, opts) {\n    super();\n    this.path = path;\n    this.opts = opts;\n\n    if (opts && opts.db) {\n      this.database = opts.db;\n      delete opts.db;\n    } else {\n      // @ts-ignore\n      this.database = require('level');\n    }\n  }\n\n  _initDb() {\n    return new Promise((resolve, reject) => {\n      this.db = this.database(this.path, { ...this.opts,\n        valueEncoding: 'binary',\n        compression: false // same default as go\n\n      },\n      /** @param {Error}  [err] */\n      err => {\n        if (err) {\n          return reject(err);\n        }\n\n        resolve(this.db);\n      });\n    });\n  }\n\n  async open() {\n    try {\n      if (this.db) {\n        await this.db.open();\n      } else {\n        this.db = await this._initDb();\n      }\n    } catch (err) {\n      throw Errors.dbOpenFailedError(err);\n    }\n  }\n  /**\n   * @param {Key} key\n   * @param {Uint8Array} value\n   */\n\n\n  async put(key, value) {\n    try {\n      await this.db.put(key.toString(), value);\n    } catch (err) {\n      throw Errors.dbWriteFailedError(err);\n    }\n  }\n  /**\n   * @param {Key} key\n   * @returns {Promise<Uint8Array>}\n   */\n\n\n  async get(key) {\n    let data;\n\n    try {\n      data = await this.db.get(key.toString());\n    } catch (err) {\n      if (err.notFound) throw Errors.notFoundError(err);\n      throw Errors.dbWriteFailedError(err);\n    }\n\n    return data;\n  }\n  /**\n   * @param {Key} key\n   * @returns {Promise<boolean>}\n   */\n\n\n  async has(key) {\n    try {\n      await this.db.get(key.toString());\n    } catch (err) {\n      if (err.notFound) return false;\n      throw err;\n    }\n\n    return true;\n  }\n  /**\n   * @param {Key} key\n   * @returns {Promise<void>}\n   */\n\n\n  async delete(key) {\n    try {\n      await this.db.del(key.toString());\n    } catch (err) {\n      throw Errors.dbDeleteFailedError(err);\n    }\n  }\n\n  close() {\n    return this.db && this.db.close();\n  }\n  /**\n   * @returns {Batch}\n   */\n\n\n  batch() {\n    /** @type {{ type: string; key: string; value?: Uint8Array; }[]} */\n    const ops = [];\n    return {\n      put: (key, value) => {\n        ops.push({\n          type: 'put',\n          key: key.toString(),\n          value: value\n        });\n      },\n      delete: key => {\n        ops.push({\n          type: 'del',\n          key: key.toString()\n        });\n      },\n      commit: () => {\n        return this.db.batch(ops);\n      }\n    };\n  }\n  /**\n   * @param {Query} q\n   * @returns {AsyncIterable<Pair>}\n   */\n\n\n  query(q) {\n    let values = true;\n\n    if (q.keysOnly != null) {\n      values = !q.keysOnly;\n    }\n\n    const opts = {\n      keys: true,\n      values: values,\n      keyAsBuffer: true\n    }; // Let the db do the prefix matching\n\n    if (q.prefix != null) {\n      const prefix = q.prefix.toString(); // Match keys greater than or equal to `prefix` and\n      // @ts-ignore\n\n      opts.gte = prefix; // less than `prefix` + \\xFF (hex escape sequence)\n      // @ts-ignore\n\n      opts.lt = prefix + '\\xFF';\n    }\n\n    let it = levelIteratorToIterator(this.db.iterator(opts));\n    it = map(it, ({\n      key,\n      value\n    }) => {\n      if (values) {\n        return {\n          key,\n          value\n        };\n      }\n\n      return (\n        /** @type {Pair} */\n        {\n          key\n        }\n      );\n    });\n\n    if (Array.isArray(q.filters)) {\n      it = q.filters.reduce((it, f) => filter(it, f), it);\n    }\n\n    if (Array.isArray(q.orders)) {\n      it = q.orders.reduce((it, f) => sortAll(it, f), it);\n    }\n\n    const offset = q.offset,\n          limit = q.limit;\n\n    if (offset) {\n      let i = 0;\n      it = filter(it, () => i++ >= offset);\n    }\n\n    if (limit) {\n      it = take(it, limit);\n    }\n\n    return it;\n  }\n\n}\n/**\n * @typedef {Object} LevelIterator\n * @property {(cb: (err: Error, key: string | Uint8Array | null, value: any)=> void)=>void} next\n * @property {(cb: (err: Error) => void) => void } end\n */\n\n/**\n * @param {LevelIterator} li - Level iterator\n * @returns {AsyncIterable<Pair>}\n */\n\n\nfunction levelIteratorToIterator(li) {\n  return {\n    [Symbol.asyncIterator]() {\n      return {\n        next: () => new Promise((resolve, reject) => {\n          li.next((err, key, value) => {\n            if (err) return reject(err);\n\n            if (key == null) {\n              return li.end(err => {\n                if (err) return reject(err);\n                resolve({\n                  done: true,\n                  value: undefined\n                });\n              });\n            }\n\n            resolve({\n              done: false,\n              value: {\n                key: new Key(key, false),\n                value\n              }\n            });\n          });\n        }),\n        return: () => new Promise((resolve, reject) => {\n          li.end(err => {\n            if (err) return reject(err);\n            resolve({\n              done: true,\n              value: undefined\n            });\n          });\n        })\n      };\n    }\n\n  };\n}\n\nmodule.exports = LevelDatastore;","map":null,"metadata":{},"sourceType":"script"}