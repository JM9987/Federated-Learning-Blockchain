{"ast":null,"code":"'use strict';\n\nvar _slicedToArray = require(\"/home/ubuntu/TFG_FL/client/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nconst isIpfs = require('is-ipfs');\n\nconst CID = require('cids');\n\nconst _require = require('ipld-dag-pb'),\n      DAGNode = _require.DAGNode;\n\nconst _require2 = require('../../utils'),\n      normalizeCidPath = _require2.normalizeCidPath;\n\nconst _require3 = require('interface-datastore'),\n      Errors = _require3.Errors;\n\nconst ERR_NOT_FOUND = Errors.notFoundError().code;\n\nconst withTimeoutOption = require('ipfs-core-utils/src/with-timeout-option');\n\nconst Format = {\n  default: '<dst>',\n  edges: '<src> -> <dst>'\n};\n/**\n * @param {Object} config\n * @param {import('..').IPLD} config.ipld\n * @param {import('..').Resolve} config.resolve\n * @param {import('..').Preload} config.preload\n */\n\nmodule.exports = function ({\n  ipld,\n  resolve,\n  preload\n}) {\n  /**\n   * Get links (references) from an object\n   *\n   * @param {CID|string} ipfsPath - The object to search for references\n   * @param {RefsOptions & AbortOptions} [options]\n   * @returns {AsyncIterable<RefResult>}\n   */\n  async function* refs(ipfsPath, options = {}) {\n    if (options.maxDepth === 0) {\n      return;\n    }\n\n    if (options.edges && options.format && options.format !== Format.default) {\n      throw new Error('Cannot set edges to true and also specify format');\n    }\n\n    options.format = options.edges ? Format.edges : options.format || Format.default;\n\n    if (typeof options.maxDepth !== 'number') {\n      options.maxDepth = options.recursive ? Infinity : 1;\n    }\n    /** @type {(string|CID)[]} */\n\n\n    const rawPaths = Array.isArray(ipfsPath) ? ipfsPath : [ipfsPath];\n    const paths = rawPaths.map(p => getFullPath(preload, p, options));\n\n    for (const path of paths) {\n      yield* refsStream(resolve, ipld, path, options);\n    }\n  }\n\n  return withTimeoutOption(refs);\n};\n\nmodule.exports.Format = Format;\n\nfunction getFullPath(preload, ipfsPath, options) {\n  // normalizeCidPath() strips /ipfs/ off the front of the path so the CID will\n  // be at the front of the path\n  const path = normalizeCidPath(ipfsPath);\n  const pathComponents = path.split('/');\n  const cid = pathComponents[0];\n\n  if (!isIpfs.cid(cid)) {\n    throw new Error(\"Error resolving path '\".concat(path, \"': '\").concat(cid, \"' is not a valid CID\"));\n  }\n\n  if (options.preload !== false) {\n    preload(cid);\n  }\n\n  return '/ipfs/' + path;\n} // Get a stream of refs at the given path\n\n\nasync function* refsStream(resolve, ipld, path, options) {\n  // Resolve to the target CID of the path\n  const resPath = await resolve(path); // path is /ipfs/<cid>\n\n  const parts = resPath.split('/');\n  const cid = parts[2]; // Traverse the DAG, converting it into a stream\n\n  for await (const obj of objectStream(ipld, cid, options.maxDepth, options.unique)) {\n    // Root object will not have a parent\n    if (!obj.parent) {\n      continue;\n    } // Filter out duplicates (isDuplicate flag is only set if options.unique is set)\n\n\n    if (obj.isDuplicate) {\n      continue;\n    } // Format the links\n    // Clients expect refs to be in the format { ref: <ref> }\n\n\n    yield {\n      ref: formatLink(obj.parent.cid, obj.node.cid, obj.node.name, options.format)\n    };\n  }\n} // Get formatted link\n\n\nfunction formatLink(srcCid, dstCid, linkName, format) {\n  let out = format.replace(/<src>/g, srcCid.toString());\n  out = out.replace(/<dst>/g, dstCid.toString());\n  out = out.replace(/<linkname>/g, linkName);\n  return out;\n} // Do a depth first search of the DAG, starting from the given root cid\n\n\nasync function* objectStream(ipld, rootCid, maxDepth, uniqueOnly) {\n  // eslint-disable-line require-await\n  const seen = new Set();\n\n  async function* traverseLevel(parent, depth) {\n    const nextLevelDepth = depth + 1; // Check the depth\n\n    if (nextLevelDepth > maxDepth) {\n      return;\n    } // Get this object's links\n\n\n    try {\n      // Look at each link, parent and the new depth\n      for (const link of await getLinks(ipld, parent.cid)) {\n        yield {\n          parent: parent,\n          node: link,\n          isDuplicate: uniqueOnly && seen.has(link.cid.toString())\n        };\n\n        if (uniqueOnly) {\n          seen.add(link.cid.toString());\n        }\n\n        yield* traverseLevel(link, nextLevelDepth);\n      }\n    } catch (err) {\n      if (err.code === ERR_NOT_FOUND) {\n        err.message = \"Could not find object with CID: \".concat(parent.cid);\n      }\n\n      throw err;\n    }\n  }\n\n  yield* traverseLevel({\n    cid: rootCid\n  }, 0);\n} // Fetch a node from IPLD then get all its links\n\n\nasync function getLinks(ipld, cid) {\n  const node = await ipld.get(new CID(cid));\n\n  if (DAGNode.isDAGNode(node)) {\n    return node.Links.map(({\n      Name,\n      Hash\n    }) => ({\n      name: Name,\n      cid: new CID(Hash)\n    }));\n  }\n\n  return getNodeLinks(node);\n} // Recursively search the node for CIDs\n\n\nfunction getNodeLinks(node, path = '') {\n  let links = [];\n\n  for (const _ref of Object.entries(node)) {\n    var _ref2 = _slicedToArray(_ref, 2);\n\n    const name = _ref2[0];\n    const value = _ref2[1];\n\n    if (CID.isCID(value)) {\n      links.push({\n        name: path + name,\n        cid: value\n      });\n    } else if (typeof value === 'object') {\n      links = links.concat(getNodeLinks(value, path + name + '/'));\n    }\n  }\n\n  return links;\n}\n/**\n * @typedef {Object} RefsOptions\n * @property {boolean} [recursive=false] - Recursively list references of child nodes\n * @property {boolean} [unique=false] - Omit duplicate references from output\n * @property {string} [format='<dst>'] - Output edges with given format. Available tokens: `<src>`, `<dst>`, `<linkname>`\n * @property {boolean} [edges=false] - output references in edge format: `\"<src> -> <dst>\"`\n * @property {number} [maxDepth=1] - only for recursive refs, limits fetch and listing to the given depth\n *\n * @typedef {{ref:string, err?:null}|{ref?:undefined, err:Error}} RefResult\n *\n * @typedef {import('..').AbortOptions} AbortOptions\n * @typedef {import('..').Repo} Repo\n */","map":null,"metadata":{},"sourceType":"script"}