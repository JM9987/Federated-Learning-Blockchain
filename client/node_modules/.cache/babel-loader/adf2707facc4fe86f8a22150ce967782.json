{"ast":null,"code":"'use strict';\n\nconst errCode = require('err-code');\n\nconst updateTree = require('./utils/update-tree');\n\nconst updateMfsRoot = require('./utils/update-mfs-root');\n\nconst toSources = require('./utils/to-sources');\n\nconst removeLink = require('./utils/remove-link');\n\nconst toMfsPath = require('./utils/to-mfs-path');\n\nconst toTrail = require('./utils/to-trail');\n\nconst withTimeoutOption = require('ipfs-core-utils/src/with-timeout-option');\n\nconst defaultOptions = {\n  recursive: false,\n  cidVersion: 0,\n  hashAlg: 'sha2-256',\n  flush: true,\n  signal: undefined\n};\n/**\n * @param {any} context\n */\n\nmodule.exports = context => {\n  /**\n   * Remove a file or directory\n   *\n   * @param  {[...paths: Paths, options?:RmOptions]} args\n   * @returns {Promise<void>}\n   */\n  async function mfsRm(...args) {\n    const _ref = await toSources(context, args, defaultOptions),\n          sources = _ref.sources,\n          options = _ref.options;\n\n    if (!sources.length) {\n      throw errCode(new Error('Please supply at least one path to remove'), 'ERR_INVALID_PARAMS');\n    }\n\n    sources.forEach(source => {\n      if (source.path === '/') {\n        throw errCode(new Error('Cannot delete root'), 'ERR_INVALID_PARAMS');\n      }\n    });\n\n    for (const source of sources) {\n      await removePath(context, source.path, options);\n    }\n  }\n\n  return withTimeoutOption(mfsRm);\n};\n\nconst removePath = async (context, path, options) => {\n  const mfsPath = await toMfsPath(context, path, options);\n  const trail = await toTrail(context, mfsPath.mfsPath);\n  const child = trail[trail.length - 1];\n  trail.pop();\n  const parent = trail[trail.length - 1];\n\n  if (!parent) {\n    throw errCode(new Error(\"\".concat(path, \" does not exist\")), 'ERR_NOT_FOUND');\n  }\n\n  if (child.type === 'directory' && !options.recursive) {\n    throw errCode(new Error(\"\".concat(path, \" is a directory, use -r to remove directories\")), 'ERR_WAS_DIR');\n  }\n\n  const _ref2 = await removeLink(context, {\n    parentCid: parent.cid,\n    name: child.name,\n    hashAlg: options.hashAlg,\n    cidVersion: options.cidVersion,\n    flush: options.flush\n  }),\n        cid = _ref2.cid;\n\n  parent.cid = cid; // update the tree with the new child\n\n  const newRootCid = await updateTree(context, trail, options); // Update the MFS record with the new CID for the root of the tree\n\n  await updateMfsRoot(context, newRootCid, options);\n};\n/**\n * @typedef {Object} RmOptions\n * @property {boolean} [recursive=false] - If true all paths under the specifed path(s) will be removed\n * @property {boolean} [flush=false] - If true the changes will be immediately flushed to disk\n * @property {string} [hashAlg='sha2-256'] - The hash algorithm to use for any updated entries\n * @property {0|1} [cidVersion] - The CID version to use for any updated entries\n *\n * @typedef {import('..').CID} CID\n * @typedef {import('./utils/types').Tuple<string>} Paths\n * @typedef {import('../../utils').AbortOptions} AbortOptions\n */","map":null,"metadata":{},"sourceType":"script"}