{"ast":null,"code":"'use strict';\n\nconst errcode = require('err-code');\n\nconst pTimeout = require('p-timeout');\n\nconst c = require('../constants');\n\nconst LimitedPeerList = require('../peer-list/limited-peer-list');\n\nconst Message = require('../message');\n\nconst Query = require('../query');\n\nconst utils = require('../utils');\n\nmodule.exports = dht => {\n  /**\n   * Check for providers from a single node.\n   *\n   * @param {PeerId} peer\n   * @param {CID} key\n   * @returns {Promise<Message>}\n   *\n   * @private\n   */\n  const findProvidersSingle = async (peer, key) => {\n    // eslint-disable-line require-await\n    const msg = new Message(Message.TYPES.GET_PROVIDERS, key.bytes, 0);\n    return dht.network.sendRequest(peer, msg);\n  };\n\n  return {\n    /**\n     * Announce to the network that we can provide given key's value.\n     * @param {CID} key\n     * @returns {Promise<void>}\n     */\n    async provide(key) {\n      dht._log('provide: %s', key.toBaseEncodedString());\n\n      const errors = []; // Add peer as provider\n\n      await dht.providers.addProvider(key, dht.peerId);\n      const multiaddrs = dht.libp2p ? dht.libp2p.multiaddrs : [];\n      const msg = new Message(Message.TYPES.ADD_PROVIDER, key.bytes, 0);\n      msg.providerPeers = [{\n        id: dht.peerId,\n        multiaddrs\n      }]; // Notify closest peers\n\n      await utils.mapParallel(dht.getClosestPeers(key.bytes), async peer => {\n        dht._log('putProvider %s to %s', key.toBaseEncodedString(), peer.toB58String());\n\n        try {\n          await dht.network.sendMessage(peer, msg);\n        } catch (err) {\n          errors.push(err);\n        }\n      });\n\n      if (errors.length) {\n        // TODO:\n        // This should be infrequent. This means a peer we previously connected\n        // to failed to exchange the provide message. If getClosestPeers was an\n        // iterator, we could continue to pull until we announce to kBucketSize peers.\n        throw errcode(new Error(\"Failed to provide to \".concat(errors.length, \" of \").concat(dht.kBucketSize, \" peers\"), 'ERR_SOME_PROVIDES_FAILED'), {\n          errors\n        });\n      }\n    },\n\n    /**\n     * Search the dht for up to `K` providers of the given CID.\n     * @param {CID} key\n     * @param {Object} options - findProviders options\n     * @param {number} options.timeout - how long the query should maximally run, in milliseconds (default: 60000)\n     * @param {number} options.maxNumProviders - maximum number of providers to find\n     * @returns {AsyncIterable<{ id: PeerId, multiaddrs: Multiaddr[] }>}\n     */\n    async *findProviders(key, options = {}) {\n      const providerTimeout = options.timeout || c.minute;\n      const n = options.maxNumProviders || c.K;\n\n      dht._log('findProviders %s', key.toBaseEncodedString());\n\n      const out = new LimitedPeerList(n);\n      const provs = await dht.providers.getProviders(key);\n      provs.forEach(id => {\n        const peerData = dht.peerStore.get(id) || {};\n        out.push({\n          id: peerData.id || id,\n          multiaddrs: (peerData.addresses || []).map(address => address.multiaddr)\n        });\n      }); // All done\n\n      if (out.length >= n) {\n        // yield values\n        for (const pData of out.toArray()) {\n          yield pData;\n        }\n\n        return;\n      } // need more, query the network\n\n\n      const paths = [];\n      const query = new Query(dht, key.bytes, (pathIndex, numPaths) => {\n        // This function body runs once per disjoint path\n        const pathSize = utils.pathSize(n - out.length, numPaths);\n        const pathProviders = new LimitedPeerList(pathSize);\n        paths.push(pathProviders); // Here we return the query function to use on this particular disjoint path\n\n        return async peer => {\n          const msg = await findProvidersSingle(peer, key);\n          const provs = msg.providerPeers;\n\n          dht._log('(%s) found %s provider entries', dht.peerId.toB58String(), provs.length);\n\n          provs.forEach(prov => {\n            pathProviders.push({\n              id: prov.id\n            });\n          }); // hooray we have all that we want\n\n          if (pathProviders.length >= pathSize) {\n            return {\n              pathComplete: true\n            };\n          } // it looks like we want some more\n\n\n          return {\n            closerPeers: msg.closerPeers\n          };\n        };\n      });\n      const peers = dht.routingTable.closestPeers(key.bytes, dht.kBucketSize);\n\n      try {\n        await pTimeout(query.run(peers), providerTimeout);\n      } catch (err) {\n        if (err.name !== pTimeout.TimeoutError.name) {\n          throw err;\n        }\n      } finally {\n        query.stop();\n      } // combine peers from each path\n\n\n      paths.forEach(path => {\n        path.toArray().forEach(peer => {\n          out.push(peer);\n        });\n      });\n\n      for (const pData of out.toArray()) {\n        yield pData;\n      }\n    }\n\n  };\n};","map":null,"metadata":{},"sourceType":"script"}