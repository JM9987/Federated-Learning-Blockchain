{"ast":null,"code":"'use strict';\n\nconst debug = require('debug');\n\nconst log = debug('dns-over-http-resolver');\nlog.error = debug('dns-over-http-resolver:error');\n\nconst Receptacle = require('receptacle');\n\nconst _require = require('./utils'),\n      buildResource = _require.buildResource,\n      fetch = _require.fetch,\n      getCacheKey = _require.getCacheKey;\n/**\n * DNS over HTTP resolver.\n * Uses a list of servers to resolve DNS records with HTTP requests.\n */\n\n\nclass Resolver {\n  /**\n   * @class\n   * @param {object} [properties]\n   * @param {number} [properties.maxCache = 100] - maximum number of cached dns records.\n   */\n  constructor({\n    maxCache = 100\n  } = {}) {\n    this._cache = new Receptacle({\n      max: maxCache\n    });\n    this._servers = ['https://cloudflare-dns.com/dns-query', 'https://dns.google/resolve'];\n  }\n  /**\n   * Get an array of the IP addresses currently configured for DNS resolution.\n   * These addresses are formatted according to RFC 5952. It can include a custom port.\n   *\n   * @returns {Array<string>}\n   */\n\n\n  getServers() {\n    return this._servers;\n  }\n  /**\n   * Get a shuffled array of the IP addresses currently configured for DNS resolution.\n   * These addresses are formatted according to RFC 5952. It can include a custom port.\n   *\n   * @returns {Array<string>}\n   */\n\n\n  _getShuffledServers() {\n    const newServers = [].concat(this._servers);\n\n    for (let i = newServers.length - 1; i > 0; i--) {\n      const j = Math.floor(Math.random() * i);\n      const temp = newServers[i];\n      newServers[i] = newServers[j];\n      newServers[j] = temp;\n    }\n\n    return newServers;\n  }\n  /**\n   * Sets the IP address and port of servers to be used when performing DNS resolution.\n   *\n   * @param {Array<string>} servers - array of RFC 5952 formatted addresses.\n   */\n\n\n  setServers(servers) {\n    this._servers = servers;\n  }\n  /**\n   * Uses the DNS protocol to resolve the given host name into the appropriate DNS record.\n   *\n   * @param {string} hostname - host name to resolve.\n   * @param {string} [rrType = 'A'] - resource record type.\n   * @returns {Promise<*>}\n   */\n\n\n  resolve(hostname, rrType = 'A') {\n    switch (rrType) {\n      case 'A':\n        return this.resolve4(hostname);\n\n      case 'AAAA':\n        return this.resolve6(hostname);\n\n      case 'TXT':\n        return this.resolveTxt(hostname);\n\n      default:\n        throw new Error(\"\".concat(rrType, \" is not supported\"));\n    }\n  }\n  /**\n   * Uses the DNS protocol to resolve the given host name into IPv4 addresses.\n   *\n   * @param {string} hostname - host name to resolve.\n   * @returns {Promise<Array<string>>}\n   */\n\n\n  async resolve4(hostname) {\n    const recordType = 'A';\n\n    const cached = this._cache.get(getCacheKey(hostname, recordType));\n\n    if (cached) {\n      return cached;\n    }\n\n    for (const server of this._getShuffledServers()) {\n      try {\n        const response = await fetch(buildResource({\n          serverResolver: server,\n          hostname,\n          recordType\n        }));\n        const d = await response.json();\n        const data = d.Answer.map(a => a.data);\n        const ttl = Math.min(d.Answer.map(a => a.TTL));\n\n        this._cache.set(getCacheKey(hostname, recordType), data, {\n          ttl\n        });\n\n        return data;\n      } catch (err) {\n        log.error(\"\".concat(server, \" could not resolve \").concat(hostname, \" record \").concat(recordType));\n      }\n    }\n\n    throw new Error(\"Could not resolve \".concat(hostname, \" record \").concat(recordType));\n  }\n  /**\n   * Uses the DNS protocol to resolve the given host name into IPv6 addresses.\n   *\n   * @param {string} hostname - host name to resolve.\n   * @returns {Promise<Array<string>>}\n   */\n\n\n  async resolve6(hostname) {\n    const recordType = 'AAAA';\n\n    const cached = this._cache.get(getCacheKey(hostname, recordType));\n\n    if (cached) {\n      return cached;\n    }\n\n    for (const server of this._getShuffledServers()) {\n      try {\n        const response = await fetch(buildResource({\n          serverResolver: server,\n          hostname,\n          recordType\n        }));\n        const d = await response.json();\n        const data = d.Answer.map(a => a.data);\n        const ttl = Math.min(d.Answer.map(a => a.TTL));\n\n        this._cache.set(getCacheKey(hostname, recordType), data, {\n          ttl\n        });\n\n        return data;\n      } catch (err) {\n        log.error(\"\".concat(server, \" could not resolve \").concat(hostname, \" record \").concat(recordType));\n      }\n    }\n\n    throw new Error(\"Could not resolve \".concat(hostname, \" record \").concat(recordType));\n  }\n  /**\n   * Uses the DNS protocol to resolve the given host name into a Text record.\n   *\n   * @param {string} hostname - host name to resolve.\n   * @returns {Promise<Array<Array<string>>>}\n   */\n\n\n  async resolveTxt(hostname) {\n    const recordType = 'TXT';\n\n    const cached = this._cache.get(getCacheKey(hostname, recordType));\n\n    if (cached) {\n      return cached;\n    }\n\n    for (const server of this._getShuffledServers()) {\n      try {\n        const response = await fetch(buildResource({\n          serverResolver: server,\n          hostname,\n          recordType\n        }));\n        const d = await response.json();\n        const data = d.Answer.map(a => [a.data.replace(/['\"]+/g, '')]);\n        const ttl = Math.min(d.Answer.map(a => a.TTL));\n\n        this._cache.set(getCacheKey(hostname, recordType), data, {\n          ttl\n        });\n\n        return data;\n      } catch (err) {\n        log.error(\"\".concat(server, \" could not resolve \").concat(hostname, \" record \").concat(recordType));\n      }\n    }\n\n    throw new Error(\"Could not resolve \".concat(hostname, \" record \").concat(recordType));\n  }\n\n}\n\nResolver.Resolver = Resolver;\nmodule.exports = Resolver;","map":null,"metadata":{},"sourceType":"script"}