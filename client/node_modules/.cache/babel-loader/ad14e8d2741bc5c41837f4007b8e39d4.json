{"ast":null,"code":"'use strict';\n\nvar _objectWithoutProperties = require(\"/home/ubuntu/Codigo_Javier/client/node_modules/@babel/runtime/helpers/objectWithoutProperties\");\n\nconst stream = require('stream');\n\nconst util = require('util');\n\nconst utils = require('./utils');\n\nconst Simple = require('./simple');\n\nconst Decoder = require('./decoder');\n\nconst NoFilter = require('nofilter');\n\nconst _require = require('./constants'),\n      BigNumber = _require.BigNumber,\n      MT = _require.MT,\n      NUMBYTES = _require.NUMBYTES,\n      SYMS = _require.SYMS;\n\nfunction plural(c) {\n  if (c > 1) {\n    return 's';\n  } else {\n    return '';\n  }\n}\n/**\n  * @typedef CommentOptions\n  * @property {number} [max_depth=10] - how many times to indent\n  *   the dashes\n  * @property {number} [depth=1] - initial indentation depth\n  * @property {boolean} [no_summary=false] - if true, omit the summary\n  *   of the full bytes read at the end\n  * @property {object} [tags] - mapping from tag number to function(v),\n  *   where v is the decoded value that comes after the tag, and where the\n  *   function returns the correctly-created value for that tag.\n  * @property {object} [tags] - mapping from tag number to function(v),\n  *   where v is the decoded value that comes after the tag, and where the\n  *   function returns the correctly-created value for that tag.\n  * @property {boolean} [bigint=true] generate JavaScript BigInt's\n  *   instead of BigNumbers, when possible.\n  * @property {boolean} [preferWeb=false] if true, prefer Uint8Arrays to\n  *   be generated instead of node Buffers.  This might turn on some more\n  *   changes in the future, so forward-compatibility is not guaranteed yet.\n  * @property {string} [encoding='hex'] - Encoding to use for input, if it\n  *   is a string\n  */\n\n/**\n  * @callback commentCallback\n  * @param {Error} [error] - if one was generated\n  * @param {string} [commented] - the comment string\n  */\n\n/**\n  * Normalize inputs to the static functions.\n  *\n  * @param {CommentOptions|commentCallback|string|number} opts encoding,\n  *   max_depth, or callback\n  * @param {commentCallback} [cb] - called on completion\n  * @returns {{options: CommentOptions, cb: commentCallback}}\n  * @private\n  */\n\n\nfunction normalizeOptions(opts, cb) {\n  switch (typeof opts) {\n    case 'function':\n      return {\n        options: {},\n        cb:\n        /** @type {commentCallback} */\n        opts\n      };\n\n    case 'string':\n      return {\n        options: {\n          encoding: opts\n        },\n        cb\n      };\n\n    case 'number':\n      return {\n        options: {\n          max_depth: opts\n        },\n        cb\n      };\n\n    case 'object':\n      return {\n        options: opts || {},\n        cb\n      };\n\n    default:\n      throw new TypeError('Unknown option type');\n  }\n}\n/**\n * Generate the expanded format of RFC 7049, section 2.2.1\n *\n * @extends {stream.Transform}\n */\n\n\nclass Commented extends stream.Transform {\n  /**\n   * Create a CBOR commenter.\n   *\n   * @param {CommentOptions} [options={}] - Stream options\n   */\n  constructor(options = {}) {\n    const _options$depth = options.depth,\n          depth = _options$depth === void 0 ? 1 : _options$depth,\n          _options$max_depth = options.max_depth,\n          max_depth = _options$max_depth === void 0 ? 10 : _options$max_depth,\n          _options$no_summary = options.no_summary,\n          no_summary = _options$no_summary === void 0 ? false : _options$no_summary,\n          _options$tags = options.tags,\n          tags = _options$tags === void 0 ? {} : _options$tags,\n          bigint = options.bigint,\n          preferWeb = options.preferWeb,\n          encoding = options.encoding,\n          superOpts = _objectWithoutProperties(options, [\"depth\", \"max_depth\", \"no_summary\", \"tags\", \"bigint\", \"preferWeb\", \"encoding\"]);\n\n    super({ ...superOpts,\n      readableObjectMode: false,\n      writableObjectMode: false\n    });\n    this.depth = depth;\n    this.max_depth = max_depth;\n    this.all = new NoFilter();\n\n    if (!tags[24]) {\n      tags[24] = this._tag_24.bind(this);\n    }\n\n    this.parser = new Decoder({\n      tags,\n      max_depth,\n      bigint,\n      preferWeb,\n      encoding\n    });\n    this.parser.on('value', this._on_value.bind(this));\n    this.parser.on('start', this._on_start.bind(this));\n    this.parser.on('start-string', this._on_start_string.bind(this));\n    this.parser.on('stop', this._on_stop.bind(this));\n    this.parser.on('more-bytes', this._on_more.bind(this));\n    this.parser.on('error', this._on_error.bind(this));\n\n    if (!no_summary) {\n      this.parser.on('data', this._on_data.bind(this));\n    }\n\n    this.parser.bs.on('read', this._on_read.bind(this));\n  }\n  /**\n   * @private\n   */\n\n\n  _tag_24(v) {\n    const c = new Commented({\n      depth: this.depth + 1,\n      no_summary: true\n    });\n    c.on('data', b => this.push(b));\n    c.on('error', er => this.emit('error', er));\n    c.end(v);\n  }\n\n  _transform(fresh, encoding, cb) {\n    this.parser.write(fresh, encoding, cb);\n  }\n\n  _flush(cb) {\n    // TODO: find the test that covers this, and look at the return value\n    return this.parser._flush(cb);\n  }\n  /**\n   * Comment on an input Buffer or string, creating a string passed to the\n   * callback.  If callback not specified, a promise is returned.\n   *\n   * @static\n   * @param {string|Buffer|ArrayBuffer|Uint8Array|Uint8ClampedArray\n   *   |DataView|stream.Readable} input\n   * @param {CommentOptions|commentCallback|string|number} [options={}]\n   *   encoding, max_depth, or callback\n   * @param {commentCallback} [cb] - called on completion\n   * @returns {Promise} if cb not specified\n   */\n\n\n  static comment(input, options = {}, cb) {\n    if (input == null) {\n      throw new Error('input required');\n    }\n\n    var _normalizeOptions = normalizeOptions(options, cb);\n\n    options = _normalizeOptions.options;\n    cb = _normalizeOptions.cb;\n    const bs = new NoFilter();\n\n    const _options = options,\n          _options$encoding = _options.encoding,\n          encoding = _options$encoding === void 0 ? 'hex' : _options$encoding,\n          opts = _objectWithoutProperties(_options, [\"encoding\"]);\n\n    const d = new Commented(opts);\n    let p = null;\n\n    if (typeof cb === 'function') {\n      d.on('end', () => {\n        cb(null, bs.toString('utf8'));\n      });\n      d.on('error', cb);\n    } else {\n      p = new Promise((resolve, reject) => {\n        d.on('end', () => {\n          resolve(bs.toString('utf8'));\n        });\n        return d.on('error', reject);\n      });\n    }\n\n    d.pipe(bs);\n    utils.guessEncoding(input, encoding).pipe(d);\n    return p;\n  }\n  /**\n   * @private\n   */\n\n\n  _on_error(er) {\n    this.push('ERROR: ');\n    this.push(er.toString());\n    this.push('\\n');\n  }\n  /**\n   * @private\n   */\n\n\n  _on_read(buf) {\n    this.all.write(buf);\n    const hex = buf.toString('hex');\n    this.push(new Array(this.depth + 1).join('  '));\n    this.push(hex);\n    let ind = (this.max_depth - this.depth) * 2;\n    ind -= hex.length;\n\n    if (ind < 1) {\n      ind = 1;\n    }\n\n    this.push(new Array(ind + 1).join(' '));\n    return this.push('-- ');\n  }\n  /**\n   * @private\n   */\n\n\n  _on_more(mt, len, parent_mt, pos) {\n    this.depth++;\n    let desc = '';\n\n    switch (mt) {\n      case MT.POS_INT:\n        desc = 'Positive number,';\n        break;\n\n      case MT.NEG_INT:\n        desc = 'Negative number,';\n        break;\n\n      case MT.ARRAY:\n        desc = 'Array, length';\n        break;\n\n      case MT.MAP:\n        desc = 'Map, count';\n        break;\n\n      case MT.BYTE_STRING:\n        desc = 'Bytes, length';\n        break;\n\n      case MT.UTF8_STRING:\n        desc = 'String, length';\n        break;\n\n      case MT.SIMPLE_FLOAT:\n        if (len === 1) {\n          desc = 'Simple value,';\n        } else {\n          desc = 'Float,';\n        }\n\n        break;\n    }\n\n    return this.push(desc + ' next ' + len + ' byte' + plural(len) + '\\n');\n  }\n  /**\n   * @private\n   */\n\n\n  _on_start_string(mt, tag, parent_mt, pos) {\n    this.depth++;\n    let desc = '';\n\n    switch (mt) {\n      case MT.BYTE_STRING:\n        desc = 'Bytes, length: ' + tag;\n        break;\n\n      case MT.UTF8_STRING:\n        desc = 'String, length: ' + tag.toString();\n        break;\n    }\n\n    return this.push(desc + '\\n');\n  }\n  /**\n   * @private\n   */\n\n\n  _on_start(mt, tag, parent_mt, pos) {\n    this.depth++;\n\n    switch (parent_mt) {\n      case MT.ARRAY:\n        this.push(\"[\".concat(pos, \"], \"));\n        break;\n\n      case MT.MAP:\n        if (pos % 2) {\n          this.push(\"{Val:\".concat(Math.floor(pos / 2), \"}, \"));\n        } else {\n          this.push(\"{Key:\".concat(Math.floor(pos / 2), \"}, \"));\n        }\n\n        break;\n    }\n\n    switch (mt) {\n      case MT.TAG:\n        this.push(\"Tag #\".concat(tag));\n\n        if (tag == 24) {\n          this.push(' Encoded CBOR data item');\n        }\n\n        break;\n\n      case MT.ARRAY:\n        if (tag === SYMS.STREAM) {\n          this.push('Array (streaming)');\n        } else {\n          this.push(\"Array, \".concat(tag, \" item\").concat(plural(tag)));\n        }\n\n        break;\n\n      case MT.MAP:\n        if (tag === SYMS.STREAM) {\n          this.push('Map (streaming)');\n        } else {\n          this.push(\"Map, \".concat(tag, \" pair\").concat(plural(tag)));\n        }\n\n        break;\n\n      case MT.BYTE_STRING:\n        this.push('Bytes (streaming)');\n        break;\n\n      case MT.UTF8_STRING:\n        this.push('String (streaming)');\n        break;\n    }\n\n    return this.push('\\n');\n  }\n  /**\n   * @private\n   */\n\n\n  _on_stop(mt) {\n    return this.depth--;\n  }\n  /**\n   * @private\n   */\n\n\n  _on_value(val, parent_mt, pos, ai) {\n    if (val !== SYMS.BREAK) {\n      switch (parent_mt) {\n        case MT.ARRAY:\n          this.push(\"[\".concat(pos, \"], \"));\n          break;\n\n        case MT.MAP:\n          if (pos % 2) {\n            this.push(\"{Val:\".concat(Math.floor(pos / 2), \"}, \"));\n          } else {\n            this.push(\"{Key:\".concat(Math.floor(pos / 2), \"}, \"));\n          }\n\n          break;\n      }\n    }\n\n    const str = utils.cborValueToString(val, -Infinity);\n\n    if (typeof val === 'string' || Buffer.isBuffer(val)) {\n      if (val.length > 0) {\n        this.push(str);\n        this.push('\\n');\n      }\n\n      this.depth--;\n    } else {\n      this.push(str);\n      this.push('\\n');\n    }\n\n    switch (ai) {\n      case NUMBYTES.ONE:\n      case NUMBYTES.TWO:\n      case NUMBYTES.FOUR:\n      case NUMBYTES.EIGHT:\n        this.depth--;\n    }\n  }\n  /**\n   * @private\n   */\n\n\n  _on_data() {\n    this.push('0x');\n    this.push(this.all.read().toString('hex'));\n    return this.push('\\n');\n  }\n\n}\n\nmodule.exports = Commented;","map":null,"metadata":{},"sourceType":"script"}