{"ast":null,"code":"'use strict';\n\nconst errCode = require('err-code');\n\nconst browserStreamToIt = require('browser-readablestream-to-it');\n\nconst itPeekable = require('it-peekable');\n\nconst map = require('it-map');\n\nconst _require = require('./utils'),\n      isBytes = _require.isBytes,\n      isBlob = _require.isBlob,\n      isReadableStream = _require.isReadableStream,\n      isFileObject = _require.isFileObject,\n      mtimeToObject = _require.mtimeToObject,\n      modeToNumber = _require.modeToNumber; // eslint-disable-next-line complexity\n\n/**\n * @typedef {import('ipfs-core-types/src/files').ToContent} ToContent\n */\n\n/**\n * @template {Blob|AsyncIterable<Uint8Array>} Content\n * @param {import('ipfs-core-types/src/files').ImportSource} input\n * @param {(content:ToContent) => Content|Promise<Content>} normaliseContent\n * @returns {AsyncIterable<import('ipfs-core-types/src/files').Entry<Content>>}\n */\n// eslint-disable-next-line complexity\n\n\nmodule.exports = async function* normaliseInput(input, normaliseContent) {\n  // must give us something\n  if (input === null || input === undefined) {\n    throw errCode(new Error(\"Unexpected input: \".concat(input)), 'ERR_UNEXPECTED_INPUT');\n  } // String\n\n\n  if (typeof input === 'string' || input instanceof String) {\n    yield toFileObject(input.toString(), normaliseContent);\n    return;\n  } // Uint8Array|ArrayBuffer|TypedArray\n  // Blob|File\n\n\n  if (isBytes(input) || isBlob(input)) {\n    yield toFileObject(input, normaliseContent);\n    return;\n  } // Browser ReadableStream\n\n\n  if (isReadableStream(input)) {\n    input = browserStreamToIt(input);\n  } // Iterable<?>\n\n\n  if (input[Symbol.iterator] || input[Symbol.asyncIterator]) {\n    /** @type {any} peekable */\n    const peekable = itPeekable(input);\n    /** @type {any} value **/\n\n    const _ref = await peekable.peek(),\n          value = _ref.value,\n          done = _ref.done;\n\n    if (done) {\n      // make sure empty iterators result in empty files\n      yield* [];\n      return;\n    }\n\n    peekable.push(value); // (Async)Iterable<Number>\n    // (Async)Iterable<Bytes>\n\n    if (Number.isInteger(value) || isBytes(value)) {\n      yield toFileObject(peekable, normaliseContent);\n      return;\n    } // (Async)Iterable<Blob>\n    // (Async)Iterable<String>\n    // (Async)Iterable<{ path, content }>\n\n\n    if (isFileObject(value) || isBlob(value) || typeof value === 'string' || value instanceof String) {\n      yield* map(peekable, value => toFileObject(value, normaliseContent));\n      return;\n    } // (Async)Iterable<(Async)Iterable<?>>\n    // (Async)Iterable<ReadableStream<?>>\n    // ReadableStream<(Async)Iterable<?>>\n    // ReadableStream<ReadableStream<?>>\n\n\n    if (value[Symbol.iterator] || value[Symbol.asyncIterator] || isReadableStream(value)) {\n      yield* map(peekable, value => toFileObject(value, normaliseContent));\n      return;\n    }\n  } // { path, content: ? }\n  // Note: Detected _after_ (Async)Iterable<?> because Node.js streams have a\n  // `path` property that passes this check.\n\n\n  if (isFileObject(input)) {\n    yield toFileObject(input, normaliseContent);\n    return;\n  }\n\n  throw errCode(new Error('Unexpected input: ' + typeof input), 'ERR_UNEXPECTED_INPUT');\n};\n/**\n * @template {Blob|AsyncIterable<Uint8Array>} Content\n * @param {import('ipfs-core-types/src/files').ToEntry} input\n * @param {(content:ToContent) => Content|Promise<Content>} normaliseContent\n * @returns {Promise<import('ipfs-core-types/src/files').Entry<Content>>}\n */\n\n\nasync function toFileObject(input, normaliseContent) {\n  // @ts-ignore - Those properties don't exist on most input types\n  const path = input.path,\n        mode = input.mode,\n        mtime = input.mtime,\n        content = input.content;\n  const file = {\n    path: path || '',\n    mode: modeToNumber(mode),\n    mtime: mtimeToObject(mtime)\n  };\n\n  if (content) {\n    file.content = await normaliseContent(content);\n  } else if (!path) {\n    // Not already a file object with path or content prop\n    // @ts-ignore - input still can be different ToContent\n    file.content = await normaliseContent(input);\n  }\n\n  return file;\n}","map":null,"metadata":{},"sourceType":"script"}