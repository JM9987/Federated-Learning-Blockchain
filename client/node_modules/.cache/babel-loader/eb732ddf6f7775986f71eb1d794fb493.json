{"ast":null,"code":"'use strict';\n\nvar _slicedToArray = require(\"/home/ubuntu/Codigo_Javier/client/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nconst debug = require('debug');\n\nconst log = Object.assign(debug('libp2p:auto-relay'), {\n  error: debug('libp2p:auto-relay:err')\n});\n\nconst uint8ArrayFromString = require('uint8arrays/from-string');\n\nconst uint8ArrayToString = require('uint8arrays/to-string');\n\nconst multiaddr = require('multiaddr');\n\nconst PeerId = require('peer-id');\n\nconst _require = require('./multicodec'),\n      multicodec = _require.relay;\n\nconst _require2 = require('./circuit/hop'),\n      canHop = _require2.canHop;\n\nconst _require3 = require('./utils'),\n      namespaceToCid = _require3.namespaceToCid;\n\nconst _require4 = require('./constants'),\n      CIRCUIT_PROTO_CODE = _require4.CIRCUIT_PROTO_CODE,\n      HOP_METADATA_KEY = _require4.HOP_METADATA_KEY,\n      HOP_METADATA_VALUE = _require4.HOP_METADATA_VALUE,\n      RELAY_RENDEZVOUS_NS = _require4.RELAY_RENDEZVOUS_NS;\n/**\n * @typedef {import('libp2p-interfaces/src/connection').Connection} Connection\n * @typedef {import('../peer-store/address-book').Address} Address\n */\n\n/**\n * @typedef {Object} AutoRelayProperties\n * @property {import('../')} libp2p\n *\n * @typedef {Object} AutoRelayOptions\n * @property {number} [maxListeners = 1] - maximum number of relays to listen.\n */\n\n\nclass AutoRelay {\n  /**\n   * Creates an instance of AutoRelay.\n   *\n   * @class\n   * @param {AutoRelayProperties & AutoRelayOptions} props\n   */\n  constructor({\n    libp2p,\n    maxListeners = 1\n  }) {\n    this._libp2p = libp2p;\n    this._peerId = libp2p.peerId;\n    this._peerStore = libp2p.peerStore;\n    this._connectionManager = libp2p.connectionManager;\n    this._transportManager = libp2p.transportManager;\n    this._addressSorter = libp2p.dialer.addressSorter;\n    this.maxListeners = maxListeners;\n    /**\n     * @type {Set<string>}\n     */\n\n    this._listenRelays = new Set();\n    this._onProtocolChange = this._onProtocolChange.bind(this);\n    this._onPeerDisconnected = this._onPeerDisconnected.bind(this);\n\n    this._peerStore.on('change:protocols', this._onProtocolChange);\n\n    this._connectionManager.on('peer:disconnect', this._onPeerDisconnected);\n  }\n  /**\n   * Check if a peer supports the relay protocol.\n   * If the protocol is not supported, check if it was supported before and remove it as a listen relay.\n   * If the protocol is supported, check if the peer supports **HOP** and add it as a listener if\n   * inside the threshold.\n   *\n   * @param {Object} props\n   * @param {PeerId} props.peerId\n   * @param {string[]} props.protocols\n   * @returns {Promise<void>}\n   */\n\n\n  async _onProtocolChange({\n    peerId,\n    protocols\n  }) {\n    const id = peerId.toB58String(); // Check if it has the protocol\n\n    const hasProtocol = protocols.find(protocol => protocol === multicodec); // If no protocol, check if we were keeping the peer before as a listenRelay\n\n    if (!hasProtocol && this._listenRelays.has(id)) {\n      this._removeListenRelay(id);\n\n      return;\n    } else if (!hasProtocol || this._listenRelays.has(id)) {\n      return;\n    } // If protocol, check if can hop, store info in the metadataBook and listen on it\n\n\n    try {\n      const connection = this._connectionManager.get(peerId);\n\n      if (!connection) {\n        return;\n      } // Do not hop on a relayed connection\n\n\n      if (connection.remoteAddr.protoCodes().includes(CIRCUIT_PROTO_CODE)) {\n        log(\"relayed connection to \".concat(id, \" will not be used to hop on\"));\n        return;\n      }\n\n      const supportsHop = await canHop({\n        connection\n      });\n\n      if (supportsHop) {\n        this._peerStore.metadataBook.set(peerId, HOP_METADATA_KEY, uint8ArrayFromString(HOP_METADATA_VALUE));\n\n        await this._addListenRelay(connection, id);\n      }\n    } catch (err) {\n      log.error(err);\n    }\n  }\n  /**\n   * Peer disconnects.\n   *\n   * @param {Connection} connection - connection to the peer\n   * @returns {void}\n   */\n\n\n  _onPeerDisconnected(connection) {\n    const peerId = connection.remotePeer;\n    const id = peerId.toB58String(); // Not listening on this relay\n\n    if (!this._listenRelays.has(id)) {\n      return;\n    }\n\n    this._removeListenRelay(id);\n  }\n  /**\n   * Attempt to listen on the given relay connection.\n   *\n   * @private\n   * @param {Connection} connection - connection to the peer\n   * @param {string} id - peer identifier string\n   * @returns {Promise<void>}\n   */\n\n\n  async _addListenRelay(connection, id) {\n    // Check if already listening on enough relays\n    if (this._listenRelays.size >= this.maxListeners) {\n      return;\n    } // Get peer known addresses and sort them per public addresses first\n\n\n    const remoteAddrs = this._peerStore.addressBook.getMultiaddrsForPeer(connection.remotePeer, this._addressSorter);\n\n    if (!remoteAddrs || !remoteAddrs.length) {\n      return;\n    }\n\n    const listenAddr = \"\".concat(remoteAddrs[0].toString(), \"/p2p-circuit\");\n\n    this._listenRelays.add(id); // Attempt to listen on relay\n\n\n    try {\n      await this._transportManager.listen([multiaddr(listenAddr)]); // Announce multiaddrs will update on listen success by TransportManager event being triggered\n    } catch (err) {\n      log.error(err);\n\n      this._listenRelays.delete(id);\n    }\n  }\n  /**\n   * Remove listen relay.\n   *\n   * @private\n   * @param {string} id - peer identifier string.\n   * @returns {void}\n   */\n\n\n  _removeListenRelay(id) {\n    if (this._listenRelays.delete(id)) {\n      // TODO: this should be responsibility of the connMgr\n      this._listenOnAvailableHopRelays([id]);\n    }\n  }\n  /**\n   * Try to listen on available hop relay connections.\n   * The following order will happen while we do not have enough relays.\n   * 1. Check the metadata store for known relays, try to listen on the ones we are already connected.\n   * 2. Dial and try to listen on the peers we know that support hop but are not connected.\n   * 3. Search the network.\n   *\n   * @param {string[]} [peersToIgnore]\n   * @returns {Promise<void>}\n   */\n\n\n  async _listenOnAvailableHopRelays(peersToIgnore = []) {\n    // TODO: The peer redial issue on disconnect should be handled by connection gating\n    // Check if already listening on enough relays\n    if (this._listenRelays.size >= this.maxListeners) {\n      return;\n    }\n\n    const knownHopsToDial = []; // Check if we have known hop peers to use and attempt to listen on the already connected\n\n    for (const _ref of this._peerStore.metadataBook.data.entries()) {\n      var _ref2 = _slicedToArray(_ref, 2);\n\n      const id = _ref2[0];\n      const metadataMap = _ref2[1];\n\n      // Continue to next if listening on this or peer to ignore\n      if (this._listenRelays.has(id) || peersToIgnore.includes(id)) {\n        continue;\n      }\n\n      const supportsHop = metadataMap.get(HOP_METADATA_KEY); // Continue to next if it does not support Hop\n\n      if (!supportsHop || uint8ArrayToString(supportsHop) !== HOP_METADATA_VALUE) {\n        continue;\n      }\n\n      const peerId = PeerId.createFromCID(id);\n\n      const connection = this._connectionManager.get(peerId); // If not connected, store for possible later use.\n\n\n      if (!connection) {\n        knownHopsToDial.push(peerId);\n        continue;\n      }\n\n      await this._addListenRelay(connection, id); // Check if already listening on enough relays\n\n      if (this._listenRelays.size >= this.maxListeners) {\n        return;\n      }\n    } // Try to listen on known peers that are not connected\n\n\n    for (const peerId of knownHopsToDial) {\n      const connection = await this._libp2p.dial(peerId);\n      await this._addListenRelay(connection, peerId.toB58String()); // Check if already listening on enough relays\n\n      if (this._listenRelays.size >= this.maxListeners) {\n        return;\n      }\n    } // Try to find relays to hop on the network\n\n\n    try {\n      const cid = await namespaceToCid(RELAY_RENDEZVOUS_NS);\n\n      for await (const provider of this._libp2p.contentRouting.findProviders(cid)) {\n        if (!provider.multiaddrs.length) {\n          continue;\n        }\n\n        const peerId = provider.id;\n\n        this._peerStore.addressBook.add(peerId, provider.multiaddrs);\n\n        const connection = await this._libp2p.dial(peerId);\n        await this._addListenRelay(connection, peerId.toB58String()); // Check if already listening on enough relays\n\n        if (this._listenRelays.size >= this.maxListeners) {\n          return;\n        }\n      }\n    } catch (err) {\n      log.error(err);\n    }\n  }\n\n}\n\nmodule.exports = AutoRelay;","map":null,"metadata":{},"sourceType":"script"}