{"ast":null,"code":"'use strict';\n\nconst IPNS = require('../ipns');\n\nconst routingConfig = require('../ipns/routing/config');\n\nconst OfflineDatastore = require('../ipns/routing/offline-datastore');\n\nconst _require = require('../errors'),\n      NotInitializedError = _require.NotInitializedError,\n      AlreadyInitializedError = _require.AlreadyInitializedError;\n\nconst log = require('debug')('ipfs:components:ipns');\n\nclass IPNSAPI {\n  /**\n   * @param {Object} options\n   * @param {string} [options.pass]\n   * @param {boolean} [options.offline]\n   * @param {LibP2POptions} [options.libp2p]\n   * @param {ExperimentalOptions} [options.EXPERIMENTAL]\n   */\n  constructor(options = {}) {\n    this.options = options;\n    this.offline = null;\n    this.online = null;\n  }\n\n  getIPNS() {\n    const ipns = this.online || this.offline;\n\n    if (ipns) {\n      return ipns;\n    } else {\n      throw new NotInitializedError();\n    }\n  }\n\n  get routing() {\n    return this.getIPNS().routing;\n  }\n  /**\n   * Activates IPNS subsystem in an ofline mode. If it was started once already\n   * it will throw an exception.\n   *\n   * This is primarily used for offline ipns modifications, such as the\n   * initializeKeyspace feature.\n   *\n   * @param {Object} config\n   * @param {import('.').Repo} config.repo\n   * @param {import('.').PeerId} config.peerId\n   * @param {import('.').Keychain} config.keychain\n   */\n\n\n  startOffline({\n    repo,\n    peerId,\n    keychain\n  }) {\n    if (this.offline != null) {\n      throw new AlreadyInitializedError();\n    }\n\n    log('initializing IPNS keyspace');\n    const routing = new OfflineDatastore(repo);\n    const ipns = new IPNS(routing, repo.datastore, peerId, keychain, this.options);\n    this.offline = ipns;\n  }\n  /**\n   * @param {Object} config\n   * @param {import('.').LibP2P} config.libp2p\n   * @param {import('.').Repo} config.repo\n   * @param {import('.').PeerId} config.peerId\n   * @param {import('.').Keychain} config.keychain\n   */\n\n\n  async startOnline({\n    libp2p,\n    repo,\n    peerId,\n    keychain\n  }) {\n    if (this.online != null) {\n      throw new AlreadyInitializedError();\n    }\n\n    const routing = routingConfig({\n      libp2p,\n      repo,\n      peerId,\n      options: this.options\n    });\n    const ipns = new IPNS(routing, repo.datastore, peerId, keychain, this.options);\n    await ipns.republisher.start();\n    this.online = ipns;\n  }\n\n  async stop() {\n    const ipns = this.online;\n\n    if (ipns) {\n      await ipns.republisher.stop();\n      this.online = null;\n    }\n  }\n\n  publish(privKey, value, lifetime) {\n    return this.getIPNS().publish(privKey, value, lifetime);\n  }\n\n  resolve(name, options) {\n    return this.getIPNS().resolve(name, options);\n  }\n\n  initializeKeyspace(privKey, value) {\n    return this.getIPNS().initializeKeyspace(privKey, value);\n  }\n\n}\n\nmodule.exports = IPNSAPI;\n/**\n * @typedef {Object} ExperimentalOptions\n * @property {boolean} [ipnsPubsub]\n *\n * @typedef {Object} LibP2POptions\n * @property {DHTConfig} [config]\n *\n * @typedef {Object} DHTConfig\n * @property {boolean} [enabled]\n */","map":null,"metadata":{},"sourceType":"script"}