{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.decryptStream = exports.encryptStream = void 0;\n\nconst buffer_1 = require(\"buffer\");\n\nconst constants_1 = require(\"./constants\"); // Returns generator that encrypts payload from the user\n\n\nfunction encryptStream(handshake) {\n  return async function* (source) {\n    for await (const chunk of source) {\n      const chunkBuffer = buffer_1.Buffer.from(chunk.buffer, chunk.byteOffset, chunk.length);\n\n      for (let i = 0; i < chunkBuffer.length; i += constants_1.NOISE_MSG_MAX_LENGTH_BYTES_WITHOUT_TAG) {\n        let end = i + constants_1.NOISE_MSG_MAX_LENGTH_BYTES_WITHOUT_TAG;\n\n        if (end > chunkBuffer.length) {\n          end = chunkBuffer.length;\n        }\n\n        const data = handshake.encrypt(chunkBuffer.slice(i, end), handshake.session);\n        yield data;\n      }\n    }\n  };\n}\n\nexports.encryptStream = encryptStream; // Decrypt received payload to the user\n\nfunction decryptStream(handshake) {\n  return async function* (source) {\n    for await (const chunk of source) {\n      const chunkBuffer = buffer_1.Buffer.from(chunk.buffer, chunk.byteOffset, chunk.length);\n\n      for (let i = 0; i < chunkBuffer.length; i += constants_1.NOISE_MSG_MAX_LENGTH_BYTES) {\n        let end = i + constants_1.NOISE_MSG_MAX_LENGTH_BYTES;\n\n        if (end > chunkBuffer.length) {\n          end = chunkBuffer.length;\n        }\n\n        const chunk = chunkBuffer.slice(i, end);\n\n        const _ref = await handshake.decrypt(chunk, handshake.session),\n              decrypted = _ref.plaintext,\n              valid = _ref.valid;\n\n        if (!valid) {\n          throw new Error('Failed to validate decrypted chunk');\n        }\n\n        yield decrypted;\n      }\n    }\n  };\n}\n\nexports.decryptStream = decryptStream;","map":null,"metadata":{},"sourceType":"script"}