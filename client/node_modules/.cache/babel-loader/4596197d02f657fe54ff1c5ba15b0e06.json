{"ast":null,"code":"'use strict';\n\nconst _require = require('./utils'),\n      filter = _require.filter,\n      sortAll = _require.sortAll,\n      take = _require.take,\n      map = _require.map;\n\nconst drain = require('it-drain');\n/**\n * @typedef {import('./key')} Key\n * @typedef {import('./types').Pair} Pair\n * @typedef {import('./types').Datastore} Datastore\n * @typedef {import('./types').Options} Options\n * @typedef {import('./types').Query} Query\n * @typedef {import('./types').Batch} Batch\n */\n\n/**\n * @template O\n * @typedef {import('./types').AwaitIterable<O>} AwaitIterable\n */\n\n/**\n * @implements {Datastore}\n */\n\n\nclass Adapter {\n  /**\n   * @returns {Promise<void>}\n   */\n  open() {\n    return Promise.reject(new Error('.open is not implemented'));\n  }\n  /**\n   * @returns {Promise<void>}\n   */\n\n\n  close() {\n    return Promise.reject(new Error('.close is not implemented'));\n  }\n  /**\n   * @param {Key} key\n   * @param {Uint8Array} val\n   * @param {Options} [options]\n   * @returns {Promise<void>}\n   */\n\n\n  put(key, val, options) {\n    return Promise.reject(new Error('.put is not implemented'));\n  }\n  /**\n   * @param {Key} key\n   * @param {Options} [options]\n   * @returns {Promise<Uint8Array>}\n   */\n\n\n  get(key, options) {\n    return Promise.reject(new Error('.get is not implemented'));\n  }\n  /**\n   * @param {Key} key\n   * @param {Options} [options]\n   * @returns {Promise<boolean>}\n   */\n\n\n  has(key, options) {\n    return Promise.reject(new Error('.has is not implemented'));\n  }\n  /**\n   * @param {Key} key\n   * @param {Options} [options]\n   * @returns {Promise<void>}\n   */\n\n\n  delete(key, options) {\n    return Promise.reject(new Error('.delete is not implemented'));\n  }\n  /**\n   * @param {AwaitIterable<Pair>} source\n   * @param {Options} [options]\n   * @returns {AsyncIterable<Pair>}\n   */\n\n\n  async *putMany(source, options = {}) {\n    for await (const _ref of source) {\n      const key = _ref.key;\n      const value = _ref.value;\n      await this.put(key, value, options);\n      yield {\n        key,\n        value\n      };\n    }\n  }\n  /**\n   * @param {AwaitIterable<Key>} source\n   * @param {Options} [options]\n   * @returns {AsyncIterable<Uint8Array>}\n   */\n\n\n  async *getMany(source, options = {}) {\n    for await (const key of source) {\n      yield this.get(key, options);\n    }\n  }\n  /**\n   * @param {AwaitIterable<Key>} source\n   * @param {Options} [options]\n   * @returns {AsyncIterable<Key>}\n   */\n\n\n  async *deleteMany(source, options = {}) {\n    for await (const key of source) {\n      await this.delete(key, options);\n      yield key;\n    }\n  }\n  /**\n   * @returns {Batch}\n   */\n\n\n  batch() {\n    /** @type {Pair[]} */\n    let puts = [];\n    /** @type {Key[]} */\n\n    let dels = [];\n    return {\n      put(key, value) {\n        puts.push({\n          key,\n          value\n        });\n      },\n\n      delete(key) {\n        dels.push(key);\n      },\n\n      commit: async options => {\n        await drain(this.putMany(puts, options));\n        puts = [];\n        await drain(this.deleteMany(dels, options));\n        dels = [];\n      }\n    };\n  }\n  /**\n   * @param {Query} q\n   * @param {Options} [options]\n   * @returns {AsyncIterable<Pair>}\n   */\n  // eslint-disable-next-line require-yield\n\n\n  async *_all(q, options) {\n    throw new Error('._all is not implemented');\n  }\n  /**\n   * @param {Query} q\n   * @param {Options} [options]\n   */\n\n\n  query(q, options) {\n    let it = this._all(q, options);\n\n    if (q.prefix != null) {\n      it = filter(it, e => e.key.toString().startsWith(\n      /** @type {string} */\n      q.prefix));\n    }\n\n    if (Array.isArray(q.filters)) {\n      it = q.filters.reduce((it, f) => filter(it, f), it);\n    }\n\n    if (Array.isArray(q.orders)) {\n      it = q.orders.reduce((it, f) => sortAll(it, f), it);\n    }\n\n    if (q.offset != null) {\n      let i = 0;\n      it = filter(it, () => i++ >=\n      /** @type {number} */\n      q.offset);\n    }\n\n    if (q.limit != null) {\n      it = take(it, q.limit);\n    }\n\n    if (q.keysOnly === true) {\n      return map(it, e => (\n      /** @type {Pair} */\n      {\n        key: e.key\n      }));\n    }\n\n    return it;\n  }\n\n}\n\nmodule.exports = Adapter;","map":null,"metadata":{},"sourceType":"script"}