{"ast":null,"code":"'use strict';\n\nconst errCode = require('err-code');\n\nconst filter = require('it-filter');\n\nconst map = require('it-map');\n\nconst take = require('it-take');\n/**\n * @typedef {import('peer-id')} PeerId\n * @typedef {import('multiaddr')} Multiaddr\n */\n\n/**\n * Store the multiaddrs from every peer in the passed peer store\n *\n * @param {AsyncIterable<{ id: PeerId, multiaddrs: Multiaddr[] }>} source\n * @param {import('../peer-store')} peerStore\n */\n\n\nfunction storeAddresses(source, peerStore) {\n  return map(source, peer => {\n    // ensure we have the addresses for a given peer\n    peerStore.addressBook.add(peer.id, peer.multiaddrs);\n    return peer;\n  });\n}\n/**\n * Filter peers by unique peer id\n *\n * @param {AsyncIterable<{ id: PeerId, multiaddrs: Multiaddr[] }>} source\n */\n\n\nfunction uniquePeers(source) {\n  /** @type Set<string> */\n  const seen = new Set();\n  return filter(source, peer => {\n    // dedupe by peer id\n    if (seen.has(peer.id.toString())) {\n      return false;\n    }\n\n    seen.add(peer.id.toString());\n    return true;\n  });\n}\n/**\n * Require at least `min` peers to be yielded from `source`\n *\n * @param {AsyncIterable<{ id: PeerId, multiaddrs: Multiaddr[] }>} source\n * @param {number} min\n */\n\n\nasync function* requirePeers(source, min = 1) {\n  let seen = 0;\n\n  for await (const peer of source) {\n    seen++;\n    yield peer;\n  }\n\n  if (seen < min) {\n    throw errCode(new Error('not found'), 'NOT_FOUND');\n  }\n}\n/**\n * If `max` is passed, only take that number of peers from the source\n * otherwise take all the peers\n *\n * @param {AsyncIterable<{ id: PeerId, multiaddrs: Multiaddr[] }>} source\n * @param {number} [max]\n */\n\n\nfunction maybeLimitSource(source, max) {\n  if (max) {\n    return take(source, max);\n  }\n\n  return source;\n}\n\nmodule.exports = {\n  storeAddresses,\n  uniquePeers,\n  requirePeers,\n  maybeLimitSource\n};","map":null,"metadata":{},"sourceType":"script"}