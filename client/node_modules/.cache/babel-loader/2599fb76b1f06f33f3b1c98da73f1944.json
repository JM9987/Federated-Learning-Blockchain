{"ast":null,"code":"'use strict';\n\nconst errCode = require('err-code');\n\nconst _require = require('../errors'),\n      messages = _require.messages,\n      codes = _require.codes;\n\nconst _require2 = require('./utils'),\n      storeAddresses = _require2.storeAddresses,\n      uniquePeers = _require2.uniquePeers,\n      requirePeers = _require2.requirePeers,\n      maybeLimitSource = _require2.maybeLimitSource;\n\nconst merge = require('it-merge');\n\nconst _require3 = require('it-pipe'),\n      pipe = _require3.pipe;\n/**\n * @typedef {import('peer-id')} PeerId\n * @typedef {import('multiaddr')} Multiaddr\n * @typedef {import('cids')} CID\n */\n\n/**\n * @typedef {Object} GetData\n * @property {PeerId} from\n * @property {Uint8Array} val\n */\n\n\nclass ContentRouting {\n  /**\n   * @class\n   * @param {import('..')} libp2p\n   */\n  constructor(libp2p) {\n    this.libp2p = libp2p;\n    this.routers = libp2p._modules.contentRouting || [];\n    this.dht = libp2p._dht; // If we have the dht, add it to the available content routers\n\n    if (this.dht && libp2p._config.dht.enabled) {\n      this.routers.push(this.dht);\n    }\n  }\n  /**\n   * Iterates over all content routers in parallel to find providers of the given key.\n   *\n   * @param {CID} key - The CID key of the content to find\n   * @param {object} [options]\n   * @param {number} [options.timeout] - How long the query should run\n   * @param {number} [options.maxNumProviders] - maximum number of providers to find\n   * @returns {AsyncIterable<{ id: PeerId, multiaddrs: Multiaddr[] }>}\n   */\n\n\n  async *findProviders(key, options = {}) {\n    if (!this.routers.length) {\n      throw errCode(new Error('No content this.routers available'), 'NO_ROUTERS_AVAILABLE');\n    }\n\n    yield* pipe(merge(...this.routers.map(router => router.findProviders(key, options))), source => storeAddresses(source, this.libp2p.peerStore), source => uniquePeers(source), source => maybeLimitSource(source, options.maxNumProviders), source => requirePeers(source));\n  }\n  /**\n   * Iterates over all content routers in parallel to notify it is\n   * a provider of the given key.\n   *\n   * @param {CID} key - The CID key of the content to find\n   * @returns {Promise<void>}\n   */\n\n\n  async provide(key) {\n    if (!this.routers.length) {\n      throw errCode(new Error('No content routers available'), 'NO_ROUTERS_AVAILABLE');\n    }\n\n    await Promise.all(this.routers.map(router => router.provide(key)));\n  }\n  /**\n   * Store the given key/value pair in the DHT.\n   *\n   * @param {Uint8Array} key\n   * @param {Uint8Array} value\n   * @param {Object} [options] - put options\n   * @param {number} [options.minPeers] - minimum number of peers required to successfully put\n   * @returns {Promise<void>}\n   */\n\n\n  put(key, value, options) {\n    if (!this.libp2p.isStarted() || !this.dht.isStarted) {\n      throw errCode(new Error(messages.NOT_STARTED_YET), codes.DHT_NOT_STARTED);\n    }\n\n    return this.dht.put(key, value, options);\n  }\n  /**\n   * Get the value to the given key.\n   * Times out after 1 minute by default.\n   *\n   * @param {Uint8Array} key\n   * @param {Object} [options] - get options\n   * @param {number} [options.timeout] - optional timeout (default: 60000)\n   * @returns {Promise<GetData>}\n   */\n\n\n  get(key, options) {\n    if (!this.libp2p.isStarted() || !this.dht.isStarted) {\n      throw errCode(new Error(messages.NOT_STARTED_YET), codes.DHT_NOT_STARTED);\n    }\n\n    return this.dht.get(key, options);\n  }\n  /**\n   * Get the `n` values to the given key without sorting.\n   *\n   * @param {Uint8Array} key\n   * @param {number} nVals\n   * @param {Object} [options] - get options\n   * @param {number} [options.timeout] - optional timeout (default: 60000)\n   * @returns {Promise<GetData[]>}\n   */\n\n\n  async getMany(key, nVals, options) {\n    // eslint-disable-line require-await\n    if (!this.libp2p.isStarted() || !this.dht.isStarted) {\n      throw errCode(new Error(messages.NOT_STARTED_YET), codes.DHT_NOT_STARTED);\n    }\n\n    return this.dht.getMany(key, nVals, options);\n  }\n\n}\n\nmodule.exports = ContentRouting;","map":null,"metadata":{},"sourceType":"script"}