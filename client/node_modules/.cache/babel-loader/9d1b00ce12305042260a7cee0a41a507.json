{"ast":null,"code":"'use strict';\n\nvar defined = require('./utils').defined;\n\nvar varint = require('varint');\n\nfunction compileEncode(m, resolve, enc, oneofs, encodingLength) {\n  const oneofsKeys = Object.keys(oneofs);\n  const encLength = enc.length;\n  const ints = {};\n\n  for (let i = 0; i < encLength; i++) {\n    ints[i] = {\n      p: varint.encode(m.fields[i].tag << 3 | 2),\n      h: varint.encode(m.fields[i].tag << 3 | enc[i].type)\n    };\n    const field = m.fields[i];\n    m.fields[i].packed = field.repeated && field.options && field.options.packed && field.options.packed !== 'false';\n  }\n\n  function encodeField(buf, view, offset, h, e, packed, innerVal) {\n    let j = 0;\n\n    if (!packed) {\n      for (j = 0; j < h.length; j++) {\n        buf[offset++] = h[j];\n      }\n    }\n\n    if (e.message) {\n      varint.encode(e.encodingLength(innerVal), buf, offset);\n      offset += varint.encode.bytes;\n    }\n\n    e.encode(innerVal, buf, view, offset);\n    return offset + e.encode.bytes;\n  }\n\n  return function encode(obj, buf, view, offset = 0) {\n    if (buf == null) {\n      buf = new Uint8Array(encodingLength(obj));\n    }\n\n    if (view == null) {\n      view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);\n    }\n\n    const oldOffset = offset;\n    const objKeys = Object.keys(obj);\n    let i = 0; // oneof checks\n\n    let match = false;\n\n    for (i = 0; i < oneofsKeys.length; i++) {\n      const name = oneofsKeys[i];\n      const prop = oneofs[i];\n\n      if (objKeys.indexOf(prop) > -1) {\n        if (match) {\n          throw new Error('only one of the properties defined in oneof ' + name + ' can be set');\n        }\n\n        match = true;\n      }\n    }\n\n    for (i = 0; i < encLength; i++) {\n      const e = enc[i];\n      const field = m.fields[i]; // was f\n\n      let val = obj[field.name];\n      let j = 0;\n\n      if (!defined(val)) {\n        if (field.required) {\n          throw new Error(field.name + ' is required');\n        }\n\n        continue;\n      }\n\n      const p = ints[i].p;\n      const h = ints[i].h;\n      const packed = field.packed;\n\n      if (field.map) {\n        const tmp = Object.keys(val);\n\n        for (j = 0; j < tmp.length; j++) {\n          tmp[j] = {\n            key: tmp[j],\n            value: val[tmp[j]]\n          };\n        }\n\n        val = tmp;\n      }\n\n      if (packed) {\n        let packedLen = 0;\n\n        for (j = 0; j < val.length; j++) {\n          if (!Object.prototype.hasOwnProperty.call(val, j)) {\n            continue;\n          }\n\n          packedLen += e.encodingLength(val[j]);\n        }\n\n        if (packedLen) {\n          for (j = 0; j < h.length; j++) {\n            buf[offset++] = p[j];\n          }\n\n          varint.encode(packedLen, buf, offset);\n          offset += varint.encode.bytes;\n        }\n      }\n\n      if (field.repeated) {\n        let innerVal;\n\n        for (j = 0; j < val.length; j++) {\n          innerVal = val[j];\n\n          if (!defined(innerVal)) {\n            continue;\n          }\n\n          offset = encodeField(buf, view, offset, h, e, packed, innerVal);\n        }\n      } else {\n        offset = encodeField(buf, view, offset, h, e, packed, val);\n      }\n    }\n\n    encode.bytes = offset - oldOffset;\n    return buf;\n  };\n}\n\nmodule.exports = compileEncode;","map":null,"metadata":{},"sourceType":"script"}