{"ast":null,"code":"\"use strict\";\n/* eslint-disable block-scoped-var, id-length, no-control-regex, no-magic-numbers, no-prototype-builtins, no-redeclare, no-shadow, no-var, sort-vars */\n\n(function (global, factory) {\n  /* AMD */\n  if (typeof define === 'function' && define.amd) {\n    define(['protobufjs/minimal'], factory);\n  }\n  /* CommonJS */\n  else if (typeof require === 'function' && typeof module === 'object' && module && module.exports) {\n      module.exports = factory(require('protobufjs/minimal'));\n    }\n})(this, function ($protobuf) {\n  // Common aliases\n  var $Reader = $protobuf.Reader;\n  var $Writer = $protobuf.Writer;\n  var $util = $protobuf.util; // Exported root namespace\n\n  var $root = $protobuf.roots.default || ($protobuf.roots.default = {});\n\n  $root.pb = function () {\n    /**\n         * Namespace pb.\n         * @exports pb\n         * @namespace\n         */\n    var pb = {};\n\n    pb.NoiseHandshakePayload = function () {\n      /**\n             * Properties of a NoiseHandshakePayload.\n             * @memberof pb\n             * @interface INoiseHandshakePayload\n             * @property {Uint8Array|null} [identityKey] NoiseHandshakePayload identityKey\n             * @property {Uint8Array|null} [identitySig] NoiseHandshakePayload identitySig\n             * @property {Uint8Array|null} [data] NoiseHandshakePayload data\n             */\n\n      /**\n             * Constructs a new NoiseHandshakePayload.\n             * @memberof pb\n             * @classdesc Represents a NoiseHandshakePayload.\n             * @implements INoiseHandshakePayload\n             * @constructor\n             * @param {pb.INoiseHandshakePayload=} [properties] Properties to set\n             */\n      function NoiseHandshakePayload(properties) {\n        if (properties) {\n          for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {\n            if (properties[keys[i]] != null) {\n              this[keys[i]] = properties[keys[i]];\n            }\n          }\n        }\n      }\n      /**\n             * NoiseHandshakePayload identityKey.\n             * @member {Uint8Array} identityKey\n             * @memberof pb.NoiseHandshakePayload\n             * @instance\n             */\n\n\n      NoiseHandshakePayload.prototype.identityKey = $util.newBuffer([]);\n      /**\n             * NoiseHandshakePayload identitySig.\n             * @member {Uint8Array} identitySig\n             * @memberof pb.NoiseHandshakePayload\n             * @instance\n             */\n\n      NoiseHandshakePayload.prototype.identitySig = $util.newBuffer([]);\n      /**\n             * NoiseHandshakePayload data.\n             * @member {Uint8Array} data\n             * @memberof pb.NoiseHandshakePayload\n             * @instance\n             */\n\n      NoiseHandshakePayload.prototype.data = $util.newBuffer([]);\n      /**\n             * Creates a new NoiseHandshakePayload instance using the specified properties.\n             * @function create\n             * @memberof pb.NoiseHandshakePayload\n             * @static\n             * @param {pb.INoiseHandshakePayload=} [properties] Properties to set\n             * @returns {pb.NoiseHandshakePayload} NoiseHandshakePayload instance\n             */\n\n      NoiseHandshakePayload.create = function create(properties) {\n        return new NoiseHandshakePayload(properties);\n      };\n      /**\n             * Encodes the specified NoiseHandshakePayload message. Does not implicitly {@link pb.NoiseHandshakePayload.verify|verify} messages.\n             * @function encode\n             * @memberof pb.NoiseHandshakePayload\n             * @static\n             * @param {pb.INoiseHandshakePayload} message NoiseHandshakePayload message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n\n\n      NoiseHandshakePayload.encode = function encode(message, writer) {\n        if (!writer) {\n          writer = $Writer.create();\n        }\n\n        if (message.identityKey != null && message.hasOwnProperty('identityKey')) {\n          writer.uint32(\n          /* id 1, wireType 2 = */\n          10).bytes(message.identityKey);\n        }\n\n        if (message.identitySig != null && message.hasOwnProperty('identitySig')) {\n          writer.uint32(\n          /* id 2, wireType 2 = */\n          18).bytes(message.identitySig);\n        }\n\n        if (message.data != null && message.hasOwnProperty('data')) {\n          writer.uint32(\n          /* id 3, wireType 2 = */\n          26).bytes(message.data);\n        }\n\n        return writer;\n      };\n      /**\n             * Encodes the specified NoiseHandshakePayload message, length delimited. Does not implicitly {@link pb.NoiseHandshakePayload.verify|verify} messages.\n             * @function encodeDelimited\n             * @memberof pb.NoiseHandshakePayload\n             * @static\n             * @param {pb.INoiseHandshakePayload} message NoiseHandshakePayload message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n\n\n      NoiseHandshakePayload.encodeDelimited = function encodeDelimited(message, writer) {\n        return this.encode(message, writer).ldelim();\n      };\n      /**\n             * Decodes a NoiseHandshakePayload message from the specified reader or buffer.\n             * @function decode\n             * @memberof pb.NoiseHandshakePayload\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @param {number} [length] Message length if known beforehand\n             * @returns {pb.NoiseHandshakePayload} NoiseHandshakePayload\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n\n\n      NoiseHandshakePayload.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader)) {\n          reader = $Reader.create(reader);\n        }\n\n        var end = length === undefined ? reader.len : reader.pos + length;\n        var message = new $root.pb.NoiseHandshakePayload();\n\n        while (reader.pos < end) {\n          var tag = reader.uint32();\n\n          switch (tag >>> 3) {\n            case 1:\n              message.identityKey = reader.bytes();\n              break;\n\n            case 2:\n              message.identitySig = reader.bytes();\n              break;\n\n            case 3:\n              message.data = reader.bytes();\n              break;\n\n            default:\n              reader.skipType(tag & 7);\n              break;\n          }\n        }\n\n        return message;\n      };\n      /**\n             * Decodes a NoiseHandshakePayload message from the specified reader or buffer, length delimited.\n             * @function decodeDelimited\n             * @memberof pb.NoiseHandshakePayload\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @returns {pb.NoiseHandshakePayload} NoiseHandshakePayload\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n\n\n      NoiseHandshakePayload.decodeDelimited = function decodeDelimited(reader) {\n        if (!(reader instanceof $Reader)) {\n          reader = new $Reader(reader);\n        }\n\n        return this.decode(reader, reader.uint32());\n      };\n      /**\n             * Verifies a NoiseHandshakePayload message.\n             * @function verify\n             * @memberof pb.NoiseHandshakePayload\n             * @static\n             * @param {Object.<string,*>} message Plain object to verify\n             * @returns {string|null} `null` if valid, otherwise the reason why it is not\n             */\n\n\n      NoiseHandshakePayload.verify = function verify(message) {\n        if (typeof message !== 'object' || message === null) {\n          return 'object expected';\n        }\n\n        if (message.identityKey != null && message.hasOwnProperty('identityKey')) {\n          if (!(message.identityKey && typeof message.identityKey.length === 'number' || $util.isString(message.identityKey))) {\n            return 'identityKey: buffer expected';\n          }\n        }\n\n        if (message.identitySig != null && message.hasOwnProperty('identitySig')) {\n          if (!(message.identitySig && typeof message.identitySig.length === 'number' || $util.isString(message.identitySig))) {\n            return 'identitySig: buffer expected';\n          }\n        }\n\n        if (message.data != null && message.hasOwnProperty('data')) {\n          if (!(message.data && typeof message.data.length === 'number' || $util.isString(message.data))) {\n            return 'data: buffer expected';\n          }\n        }\n\n        return null;\n      };\n      /**\n             * Creates a NoiseHandshakePayload message from a plain object. Also converts values to their respective internal types.\n             * @function fromObject\n             * @memberof pb.NoiseHandshakePayload\n             * @static\n             * @param {Object.<string,*>} object Plain object\n             * @returns {pb.NoiseHandshakePayload} NoiseHandshakePayload\n             */\n\n\n      NoiseHandshakePayload.fromObject = function fromObject(object) {\n        if (object instanceof $root.pb.NoiseHandshakePayload) {\n          return object;\n        }\n\n        var message = new $root.pb.NoiseHandshakePayload();\n\n        if (object.identityKey != null) {\n          if (typeof object.identityKey === 'string') {\n            $util.base64.decode(object.identityKey, message.identityKey = $util.newBuffer($util.base64.length(object.identityKey)), 0);\n          } else if (object.identityKey.length) {\n            message.identityKey = object.identityKey;\n          }\n        }\n\n        if (object.identitySig != null) {\n          if (typeof object.identitySig === 'string') {\n            $util.base64.decode(object.identitySig, message.identitySig = $util.newBuffer($util.base64.length(object.identitySig)), 0);\n          } else if (object.identitySig.length) {\n            message.identitySig = object.identitySig;\n          }\n        }\n\n        if (object.data != null) {\n          if (typeof object.data === 'string') {\n            $util.base64.decode(object.data, message.data = $util.newBuffer($util.base64.length(object.data)), 0);\n          } else if (object.data.length) {\n            message.data = object.data;\n          }\n        }\n\n        return message;\n      };\n      /**\n             * Creates a plain object from a NoiseHandshakePayload message. Also converts values to other types if specified.\n             * @function toObject\n             * @memberof pb.NoiseHandshakePayload\n             * @static\n             * @param {pb.NoiseHandshakePayload} message NoiseHandshakePayload\n             * @param {$protobuf.IConversionOptions} [options] Conversion options\n             * @returns {Object.<string,*>} Plain object\n             */\n\n\n      NoiseHandshakePayload.toObject = function toObject(message, options) {\n        if (!options) {\n          options = {};\n        }\n\n        var object = {};\n\n        if (options.defaults) {\n          if (options.bytes === String) {\n            object.identityKey = '';\n          } else {\n            object.identityKey = [];\n\n            if (options.bytes !== Array) {\n              object.identityKey = $util.newBuffer(object.identityKey);\n            }\n          }\n\n          if (options.bytes === String) {\n            object.identitySig = '';\n          } else {\n            object.identitySig = [];\n\n            if (options.bytes !== Array) {\n              object.identitySig = $util.newBuffer(object.identitySig);\n            }\n          }\n\n          if (options.bytes === String) {\n            object.data = '';\n          } else {\n            object.data = [];\n\n            if (options.bytes !== Array) {\n              object.data = $util.newBuffer(object.data);\n            }\n          }\n        }\n\n        if (message.identityKey != null && message.hasOwnProperty('identityKey')) {\n          object.identityKey = options.bytes === String ? $util.base64.encode(message.identityKey, 0, message.identityKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.identityKey) : message.identityKey;\n        }\n\n        if (message.identitySig != null && message.hasOwnProperty('identitySig')) {\n          object.identitySig = options.bytes === String ? $util.base64.encode(message.identitySig, 0, message.identitySig.length) : options.bytes === Array ? Array.prototype.slice.call(message.identitySig) : message.identitySig;\n        }\n\n        if (message.data != null && message.hasOwnProperty('data')) {\n          object.data = options.bytes === String ? $util.base64.encode(message.data, 0, message.data.length) : options.bytes === Array ? Array.prototype.slice.call(message.data) : message.data;\n        }\n\n        return object;\n      };\n      /**\n             * Converts this NoiseHandshakePayload to JSON.\n             * @function toJSON\n             * @memberof pb.NoiseHandshakePayload\n             * @instance\n             * @returns {Object.<string,*>} JSON object\n             */\n\n\n      NoiseHandshakePayload.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n      };\n\n      return NoiseHandshakePayload;\n    }();\n\n    return pb;\n  }();\n\n  return $root;\n});","map":null,"metadata":{},"sourceType":"script"}