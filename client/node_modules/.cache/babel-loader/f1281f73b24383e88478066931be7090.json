{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.isValidPublicKey = exports.getHkdf = exports.verifySignedPayload = exports.getHandshakePayload = exports.decodePayload = exports.getPeerIdFromPayload = exports.signPayload = exports.createHandshakePayload = exports.getPayload = exports.generateKeypair = void 0;\n\nconst hkdf_1 = __importDefault(require(\"bcrypto/lib/hkdf\"));\n\nconst x25519_1 = __importDefault(require(\"bcrypto/lib/js/x25519\"));\n\nconst sha256_1 = __importDefault(require(\"bcrypto/lib/js/sha256\"));\n\nconst buffer_1 = require(\"buffer\");\n\nconst peer_id_1 = __importDefault(require(\"peer-id\"));\n\nconst libp2p_crypto_1 = require(\"libp2p-crypto\");\n\nconst payload_1 = require(\"./proto/payload\");\n\nconst equals_1 = __importDefault(require(\"uint8arrays/equals\"));\n\nconst NoiseHandshakePayloadProto = payload_1.pb.NoiseHandshakePayload;\n\nfunction generateKeypair() {\n  const privateKey = x25519_1.default.privateKeyGenerate();\n  const publicKey = x25519_1.default.publicKeyCreate(privateKey);\n  return {\n    publicKey,\n    privateKey\n  };\n}\n\nexports.generateKeypair = generateKeypair;\n\nasync function getPayload(localPeer, staticPublicKey, earlyData) {\n  const signedPayload = await signPayload(localPeer, getHandshakePayload(staticPublicKey));\n  const earlyDataPayload = earlyData || buffer_1.Buffer.alloc(0);\n  return await createHandshakePayload(localPeer.marshalPubKey(), signedPayload, earlyDataPayload);\n}\n\nexports.getPayload = getPayload;\n\nfunction createHandshakePayload(libp2pPublicKey, signedPayload, earlyData) {\n  const payloadInit = NoiseHandshakePayloadProto.create({\n    identityKey: buffer_1.Buffer.from(libp2pPublicKey),\n    identitySig: signedPayload,\n    data: earlyData || null\n  });\n  return buffer_1.Buffer.from(NoiseHandshakePayloadProto.encode(payloadInit).finish());\n}\n\nexports.createHandshakePayload = createHandshakePayload;\n\nasync function signPayload(peerId, payload) {\n  return buffer_1.Buffer.from((await peerId.privKey.sign(payload)));\n}\n\nexports.signPayload = signPayload;\n\nasync function getPeerIdFromPayload(payload) {\n  return await peer_id_1.default.createFromPubKey(buffer_1.Buffer.from(payload.identityKey));\n}\n\nexports.getPeerIdFromPayload = getPeerIdFromPayload;\n\nfunction decodePayload(payload) {\n  return NoiseHandshakePayloadProto.toObject(NoiseHandshakePayloadProto.decode(buffer_1.Buffer.from(payload)));\n}\n\nexports.decodePayload = decodePayload;\n\nfunction getHandshakePayload(publicKey) {\n  return buffer_1.Buffer.concat([buffer_1.Buffer.from('noise-libp2p-static-key:'), publicKey]);\n}\n\nexports.getHandshakePayload = getHandshakePayload;\n\nasync function isValidPeerId(peerId, publicKeyProtobuf) {\n  const generatedPeerId = await peer_id_1.default.createFromPubKey(publicKeyProtobuf);\n  return equals_1.default(generatedPeerId.id, peerId);\n}\n/**\n * Verifies signed payload, throws on any irregularities.\n *\n * @param {bytes} noiseStaticKey - owner's noise static key\n * @param {bytes} payload - decoded payload\n * @param {PeerId} remotePeer - owner's libp2p peer ID\n * @returns {Promise<PeerId>} - peer ID of payload owner\n */\n\n\nasync function verifySignedPayload(noiseStaticKey, payload, remotePeer) {\n  const identityKey = buffer_1.Buffer.from(payload.identityKey);\n\n  if (!(await isValidPeerId(remotePeer.id, identityKey))) {\n    throw new Error(\"Peer ID doesn't match libp2p public key.\");\n  }\n\n  const generatedPayload = getHandshakePayload(noiseStaticKey); // Unmarshaling from PublicKey protobuf\n\n  const publicKey = libp2p_crypto_1.keys.unmarshalPublicKey(identityKey);\n\n  if (!payload.identitySig || !publicKey.verify(generatedPayload, buffer_1.Buffer.from(payload.identitySig))) {\n    throw new Error(\"Static key doesn't match to peer that signed payload!\");\n  }\n\n  return peer_id_1.default.createFromPubKey(identityKey);\n}\n\nexports.verifySignedPayload = verifySignedPayload;\n\nfunction getHkdf(ck, ikm) {\n  const info = buffer_1.Buffer.alloc(0);\n  const prk = hkdf_1.default.extract(sha256_1.default, ikm, ck);\n  const okm = hkdf_1.default.expand(sha256_1.default, prk, info, 96);\n  const k1 = okm.slice(0, 32);\n  const k2 = okm.slice(32, 64);\n  const k3 = okm.slice(64, 96);\n  return [k1, k2, k3];\n}\n\nexports.getHkdf = getHkdf;\n\nfunction isValidPublicKey(pk) {\n  return x25519_1.default.publicKeyVerify(pk.slice(0, 32));\n}\n\nexports.isValidPublicKey = isValidPublicKey;","map":null,"metadata":{},"sourceType":"script"}