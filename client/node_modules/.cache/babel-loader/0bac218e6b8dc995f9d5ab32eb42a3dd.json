{"ast":null,"code":"'use strict';\n\nvar _slicedToArray = require(\"/home/ubuntu/TFG_FL/client/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nconst mergeOptions = require('merge-options').bind({\n  ignoreUndefined: true\n});\n\nconst toMfsPath = require('./utils/to-mfs-path');\n\nconst log = require('debug')('ipfs:mfs:touch');\n\nconst errCode = require('err-code');\n\nconst UnixFS = require('ipfs-unixfs');\n\nconst toTrail = require('./utils/to-trail');\n\nconst addLink = require('./utils/add-link');\n\nconst updateTree = require('./utils/update-tree');\n\nconst updateMfsRoot = require('./utils/update-mfs-root');\n\nconst _require = require('ipld-dag-pb'),\n      DAGNode = _require.DAGNode;\n\nconst mc = require('multicodec');\n\nconst mh = require('multihashing-async').multihash;\n\nconst _require2 = require('it-pipe'),\n      pipe = _require2.pipe;\n\nconst importer = require('ipfs-unixfs-importer');\n\nconst exporter = require('ipfs-unixfs-exporter');\n\nconst last = require('it-last');\n\nconst cp = require('./cp');\n\nconst rm = require('./rm');\n\nconst persist = require('ipfs-unixfs-importer/src/utils/persist');\n\nconst withTimeoutOption = require('ipfs-core-utils/src/with-timeout-option');\n\nconst defaultOptions = {\n  flush: true,\n  shardSplitThreshold: 1000,\n  hashAlg: 'sha2-256',\n  cidVersion: 0,\n  recursive: false,\n  signal: undefined\n};\n\nfunction calculateModification(mode, originalMode, isDirectory) {\n  let modification = 0;\n\n  if (mode.includes('x') || mode.includes('X') && (isDirectory || originalMode & 0o1 || originalMode & 0o10 || originalMode & 0o100)) {\n    modification += 1;\n  }\n\n  if (mode.includes('w')) {\n    modification += 2;\n  }\n\n  if (mode.includes('r')) {\n    modification += 4;\n  }\n\n  return modification;\n}\n\nfunction calculateUGO(references, modification) {\n  let ugo = 0;\n\n  if (references.includes('u')) {\n    ugo += modification << 6;\n  }\n\n  if (references.includes('g')) {\n    ugo += modification << 3;\n  }\n\n  if (references.includes('o')) {\n    ugo += modification;\n  }\n\n  return ugo;\n}\n\nfunction calculateSpecial(references, mode, modification) {\n  if (mode.includes('t')) {\n    modification += parseInt('1000', 8);\n  }\n\n  if (mode.includes('s')) {\n    if (references.includes('u')) {\n      modification += parseInt('4000', 8);\n    }\n\n    if (references.includes('g')) {\n      modification += parseInt('2000', 8);\n    }\n  }\n\n  return modification;\n} // https://en.wikipedia.org/wiki/Chmod#Symbolic_modes\n\n\nfunction parseSymbolicMode(input, originalMode, isDirectory) {\n  if (!originalMode) {\n    originalMode = 0;\n  }\n\n  const match = input.match(/^(u?g?o?a?)(-?\\+?=?)?(r?w?x?X?s?t?)$/);\n\n  if (!match) {\n    throw new Error(\"Invalid file mode: \".concat(input));\n  }\n\n  let _match = _slicedToArray(match, 4),\n      references = _match[1],\n      operator = _match[2],\n      mode = _match[3];\n\n  if (references === 'a' || !references) {\n    references = 'ugo';\n  }\n\n  let modification = calculateModification(mode, originalMode, isDirectory);\n  modification = calculateUGO(references, modification);\n  modification = calculateSpecial(references, mode, modification);\n\n  if (operator === '=') {\n    if (references.includes('u')) {\n      // blank u bits\n      originalMode = originalMode & parseInt('7077', 8); // or them together\n\n      originalMode = originalMode | modification;\n    }\n\n    if (references.includes('g')) {\n      // blank g bits\n      originalMode = originalMode & parseInt('7707', 8); // or them together\n\n      originalMode = originalMode | modification;\n    }\n\n    if (references.includes('o')) {\n      // blank o bits\n      originalMode = originalMode & parseInt('7770', 8); // or them together\n\n      originalMode = originalMode | modification;\n    }\n\n    return originalMode;\n  }\n\n  if (operator === '+') {\n    return modification | originalMode;\n  }\n\n  if (operator === '-') {\n    return modification ^ originalMode;\n  }\n}\n\nfunction calculateMode(mode, metadata) {\n  if (mode instanceof String) {\n    mode = mode.toString();\n  }\n\n  if (typeof mode === 'string') {\n    if (mode.match(/^\\d+$/g)) {\n      mode = parseInt(mode, 8);\n    } else {\n      mode = mode.split(',').reduce((curr, acc) => {\n        return parseSymbolicMode(acc, curr, metadata.isDirectory());\n      }, metadata.mode);\n    }\n  }\n\n  return mode;\n}\n\nmodule.exports = context => {\n  /**\n   * @param {string} path\n   * @param {string | number} mode\n   * @param {ChmodOptions & AbortOptions} [options]\n   * @returns {Promise<void>}\n   */\n  async function mfsChmod(path, mode, options = {}) {\n    const opts = mergeOptions(defaultOptions, options);\n    log(\"Fetching stats for \".concat(path));\n\n    const _ref = await toMfsPath(context, path, opts),\n          cid = _ref.cid,\n          mfsDirectory = _ref.mfsDirectory,\n          name = _ref.name;\n\n    if (cid.codec !== 'dag-pb') {\n      throw errCode(new Error(\"\".concat(path, \" was not a UnixFS node\")), 'ERR_NOT_UNIXFS');\n    }\n\n    if (opts.recursive) {\n      // recursively export from root CID, change perms of each entry then reimport\n      // but do not reimport files, only manipulate dag-pb nodes\n      const root = await pipe(async function* () {\n        for await (const entry of exporter.recursive(cid, context.ipld)) {\n          let node = await context.ipld.get(entry.cid);\n          entry.unixfs.mode = calculateMode(mode, entry.unixfs);\n          node = new DAGNode(entry.unixfs.marshal(), node.Links);\n          yield {\n            path: entry.path,\n            content: node\n          };\n        }\n      }, source => importer(source, context.block, { ...opts,\n        pin: false,\n        dagBuilder: async function* (source, block, opts) {\n          for await (const entry of source) {\n            yield async function () {\n              const cid = await persist(entry.content.serialize(), block, opts);\n              return {\n                cid,\n                path: entry.path,\n                unixfs: UnixFS.unmarshal(entry.content.Data),\n                node: entry.content\n              };\n            };\n          }\n        }\n      }), nodes => last(nodes)); // remove old path from mfs\n\n      await rm(context)(path, opts); // add newly created tree to mfs at path\n\n      await cp(context)(\"/ipfs/\".concat(root.cid), path, opts);\n      return;\n    }\n\n    let node = await context.ipld.get(cid);\n    const metadata = UnixFS.unmarshal(node.Data);\n    metadata.mode = calculateMode(mode, metadata);\n    node = new DAGNode(metadata.marshal(), node.Links);\n    const updatedCid = await context.ipld.put(node, mc.DAG_PB, {\n      cidVersion: cid.version,\n      hashAlg: mh.names[opts.hashAlg || defaultOptions.hashAlg],\n      onlyHash: !opts.flush\n    });\n    const trail = await toTrail(context, mfsDirectory);\n    const parent = trail[trail.length - 1];\n    const parentNode = await context.ipld.get(parent.cid);\n    const result = await addLink(context, {\n      parent: parentNode,\n      name: name,\n      cid: updatedCid,\n      size: node.serialize().length,\n      flush: opts.flush,\n      hashAlg: opts.hashAlg,\n      cidVersion: cid.version\n    });\n    parent.cid = result.cid; // update the tree with the new child\n\n    const newRootCid = await updateTree(context, trail, opts); // Update the MFS record with the new CID for the root of the tree\n\n    await updateMfsRoot(context, newRootCid, opts);\n  }\n\n  return withTimeoutOption(mfsChmod);\n};\n/**\n * @typedef {Object} ChmodOptions\n * @property {boolean} [flush=false]\n * @property {number} [shardSplitThreshold=1000]\n * @property {string} [hashAlg=sha2-256]\n * @property {0|1} [cidVersion=0]\n * @property {boolean} [recursive=false]\n *\n * @typedef {import('cids')} CID\n * @typedef {import('../../utils').AbortOptions} AbortOptions\n */","map":null,"metadata":{},"sourceType":"script"}