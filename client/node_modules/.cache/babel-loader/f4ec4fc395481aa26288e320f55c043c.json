{"ast":null,"code":"'use strict';\n\nconst debug = require('debug');\n\nconst log = Object.assign(debug('libp2p:peer-routing'), {\n  error: debug('libp2p:peer-routing:err')\n});\n\nconst errCode = require('err-code');\n\nconst _require = require('./content-routing/utils'),\n      storeAddresses = _require.storeAddresses,\n      uniquePeers = _require.uniquePeers,\n      requirePeers = _require.requirePeers;\n\nconst merge = require('it-merge');\n\nconst _require2 = require('it-pipe'),\n      pipe = _require2.pipe;\n\nconst first = require('it-first');\n\nconst drain = require('it-drain');\n\nconst filter = require('it-filter');\n\nconst _require3 = require('set-delayed-interval'),\n      setDelayedInterval = _require3.setDelayedInterval,\n      clearDelayedInterval = _require3.clearDelayedInterval;\n\nconst PeerId = require('peer-id');\n/**\n * @typedef {import('multiaddr')} Multiaddr\n */\n\n\nclass PeerRouting {\n  /**\n   * @class\n   * @param {import('./')} libp2p\n   */\n  constructor(libp2p) {\n    this._peerId = libp2p.peerId;\n    this._peerStore = libp2p.peerStore;\n    this._routers = libp2p._modules.peerRouting || []; // If we have the dht, add it to the available peer routers\n\n    if (libp2p._dht && libp2p._config.dht.enabled) {\n      this._routers.push(libp2p._dht);\n    }\n\n    this._refreshManagerOptions = libp2p._options.peerRouting.refreshManager;\n    this._findClosestPeersTask = this._findClosestPeersTask.bind(this);\n  }\n  /**\n   * Start peer routing service.\n   */\n\n\n  start() {\n    if (!this._routers.length || this._timeoutId || !this._refreshManagerOptions.enabled) {\n      return;\n    }\n\n    this._timeoutId = setDelayedInterval(this._findClosestPeersTask, this._refreshManagerOptions.interval, this._refreshManagerOptions.bootDelay);\n  }\n  /**\n   * Recurrent task to find closest peers and add their addresses to the Address Book.\n   */\n\n\n  async _findClosestPeersTask() {\n    try {\n      // nb getClosestPeers adds the addresses to the address book\n      await drain(this.getClosestPeers(this._peerId.id));\n    } catch (err) {\n      log.error(err);\n    }\n  }\n  /**\n   * Stop peer routing service.\n   */\n\n\n  stop() {\n    clearDelayedInterval(this._timeoutId);\n  }\n  /**\n   * Iterates over all peer routers in parallel to find the given peer.\n   *\n   * @param {PeerId} id - The id of the peer to find\n   * @param {object} [options]\n   * @param {number} [options.timeout] - How long the query should run\n   * @returns {Promise<{ id: PeerId, multiaddrs: Multiaddr[] }>}\n   */\n\n\n  async findPeer(id, options) {\n    // eslint-disable-line require-await\n    if (!this._routers.length) {\n      throw errCode(new Error('No peer routers available'), 'NO_ROUTERS_AVAILABLE');\n    }\n\n    const output = await pipe(merge(...this._routers.map(router => [router.findPeer(id, options)])), source => filter(source, Boolean), source => storeAddresses(source, this._peerStore), source => first(source));\n\n    if (output) {\n      return output;\n    }\n\n    throw errCode(new Error('not found'), 'NOT_FOUND');\n  }\n  /**\n   * Attempt to find the closest peers on the network to the given key.\n   *\n   * @param {Uint8Array} key - A CID like key\n   * @param {Object} [options]\n   * @param {number} [options.timeout=30e3] - How long the query can take.\n   * @returns {AsyncIterable<{ id: PeerId, multiaddrs: Multiaddr[] }>}\n   */\n\n\n  async *getClosestPeers(key, options = {\n    timeout: 30e3\n  }) {\n    if (!this._routers.length) {\n      throw errCode(new Error('No peer routers available'), 'NO_ROUTERS_AVAILABLE');\n    }\n\n    yield* pipe(merge(...this._routers.map(router => router.getClosestPeers(key, options))), source => storeAddresses(source, this._peerStore), source => uniquePeers(source), source => requirePeers(source));\n  }\n\n}\n\nmodule.exports = PeerRouting;","map":null,"metadata":{},"sourceType":"script"}