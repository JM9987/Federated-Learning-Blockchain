{"ast":null,"code":"'use strict';\n\nconst Topology = require('./index');\n\nconst multicodecTopologySymbol = Symbol.for('@libp2p/js-interfaces/topology/multicodec-topology');\n\nclass MulticodecTopology extends Topology {\n  /**\n   * @param {TopologyOptions & MulticodecOptions} props\n   */\n  constructor({\n    min,\n    max,\n    multicodecs,\n    handlers\n  }) {\n    super({\n      min,\n      max,\n      handlers\n    });\n\n    if (!multicodecs) {\n      throw new Error('one or more multicodec should be provided');\n    }\n\n    if (!handlers) {\n      throw new Error('the handlers should be provided');\n    }\n\n    if (typeof handlers.onConnect !== 'function') {\n      throw new Error('the \\'onConnect\\' handler must be provided');\n    }\n\n    if (typeof handlers.onDisconnect !== 'function') {\n      throw new Error('the \\'onDisconnect\\' handler must be provided');\n    }\n\n    this.multicodecs = Array.isArray(multicodecs) ? multicodecs : [multicodecs];\n    this._registrar = undefined;\n    this._onProtocolChange = this._onProtocolChange.bind(this);\n    this._onPeerConnect = this._onPeerConnect.bind(this);\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'Topology';\n  }\n\n  get [multicodecTopologySymbol]() {\n    return true;\n  }\n  /**\n   * Checks if the given value is a `MulticodecTopology` instance.\n   *\n   * @param {any} other\n   * @returns {other is MulticodecTopology}\n   */\n\n\n  static isMulticodecTopology(other) {\n    return Boolean(other && other[multicodecTopologySymbol]);\n  }\n\n  set registrar(registrar) {\n    // eslint-disable-line\n    this._registrar = registrar;\n\n    this._registrar.peerStore.on('change:protocols', this._onProtocolChange);\n\n    this._registrar.connectionManager.on('peer:connect', this._onPeerConnect); // Update topology peers\n\n\n    this._updatePeers(this._registrar.peerStore.peers.values());\n  }\n  /**\n   * Update topology.\n   *\n   * @param {Array<{id: PeerId, multiaddrs: Array<Multiaddr>, protocols: Array<string>}>} peerDataIterable\n   * @returns {void}\n   */\n\n\n  _updatePeers(peerDataIterable) {\n    for (const _ref of peerDataIterable) {\n      const id = _ref.id;\n      const protocols = _ref.protocols;\n\n      if (this.multicodecs.filter(multicodec => protocols.includes(multicodec)).length) {\n        // Add the peer regardless of whether or not there is currently a connection\n        this.peers.add(id.toB58String()); // If there is a connection, call _onConnect\n\n        const connection = this._registrar.getConnection(id);\n\n        connection && this._onConnect(id, connection);\n      } else {\n        // Remove any peers we might be tracking that are no longer of value to us\n        this.peers.delete(id.toB58String());\n      }\n    }\n  }\n  /**\n   * Check if a new peer support the multicodecs for this topology.\n   *\n   * @param {Object} props\n   * @param {PeerId} props.peerId\n   * @param {Array<string>} props.protocols\n   */\n\n\n  _onProtocolChange({\n    peerId,\n    protocols\n  }) {\n    const hadPeer = this.peers.has(peerId.toB58String());\n    const hasProtocol = protocols.filter(protocol => this.multicodecs.includes(protocol)); // Not supporting the protocol anymore?\n\n    if (hadPeer && hasProtocol.length === 0) {\n      this._onDisconnect(peerId);\n    } // New to protocol support\n\n\n    for (const protocol of protocols) {\n      if (this.multicodecs.includes(protocol)) {\n        const peerData = this._registrar.peerStore.get(peerId);\n\n        this._updatePeers([peerData]);\n\n        return;\n      }\n    }\n  }\n  /**\n   * Verify if a new connected peer has a topology multicodec and call _onConnect.\n   *\n   * @param {Connection} connection\n   * @returns {void}\n   */\n\n\n  _onPeerConnect(connection) {\n    // @ts-ignore - remotePeer does not existist on Connection\n    const peerId = connection.remotePeer;\n\n    const protocols = this._registrar.peerStore.protoBook.get(peerId);\n\n    if (!protocols) {\n      return;\n    }\n\n    if (this.multicodecs.find(multicodec => protocols.includes(multicodec))) {\n      this.peers.add(peerId.toB58String());\n\n      this._onConnect(peerId, connection);\n    }\n  }\n\n}\n/**\n * @typedef {import('peer-id')} PeerId\n * @typedef {import('multiaddr')} Multiaddr\n * @typedef {import('../connection/connection')} Connection\n * @typedef {import('.').Options} TopologyOptions\n * @typedef {Object} MulticodecOptions\n * @property {string[]} multicodecs - protocol multicodecs\n * @property {Required<Handlers>} handlers\n * @typedef {import('.').Handlers} Handlers\n */\n\n\nmodule.exports = MulticodecTopology;","map":null,"metadata":{},"sourceType":"script"}