{"ast":null,"code":"'use strict';\n\nvar _objectWithoutProperties = require(\"/home/ubuntu/Codigo_Javier/client/node_modules/@babel/runtime/helpers/objectWithoutProperties\");\n\nconst stream = require('stream');\n\nconst BinaryParseStream = require('../vendor/binary-parse-stream');\n\nconst Tagged = require('./tagged');\n\nconst Simple = require('./simple');\n\nconst utils = require('./utils');\n\nconst NoFilter = require('nofilter');\n\nconst _require = require('./constants'),\n      BigNumber = _require.BigNumber,\n      MT = _require.MT,\n      NUMBYTES = _require.NUMBYTES,\n      SIMPLE = _require.SIMPLE,\n      SYMS = _require.SYMS,\n      BI = _require.BI,\n      BN = _require.BN;\n\nconst COUNT = Symbol('count');\nconst PENDING_KEY = Symbol('pending_key');\nconst MAJOR = Symbol('major type');\nconst ERROR = Symbol('error');\nconst NOT_FOUND = Symbol('not found');\n\nfunction parentArray(parent, typ, count) {\n  const a = [];\n  a[COUNT] = count;\n  a[SYMS.PARENT] = parent;\n  a[MAJOR] = typ;\n  return a;\n}\n\nfunction parentBufferStream(parent, typ) {\n  const b = new NoFilter();\n  b[COUNT] = -1;\n  b[SYMS.PARENT] = parent;\n  b[MAJOR] = typ;\n  return b;\n}\n/**\n * @param {Buffer} v\n * @private\n */\n\n\nfunction _tag_2(v) {\n  return utils.bufferToBigInt(v);\n}\n/**\n * @param {BigInt} v\n * @private\n */\n\n\nfunction _tag_3(v) {\n  // avoid syntax error on old runtimes\n  return BI.MINUS_ONE - utils.bufferToBigInt(v);\n}\n\nclass UnexpectedDataError extends Error {\n  constructor(byte, value) {\n    super(\"Unexpected data: 0x\".concat(byte.toString(16)));\n    this.name = 'UnexpectedDataError';\n    this.byte = byte;\n    this.value = value;\n  }\n\n}\n/**\n * @typedef ExtendedResults\n * @property {any} value - the value that was found\n * @property {number} length - the number of bytes of the original input that\n *   were read\n * @property {Buffer} bytes - the bytes of the original input that were used\n *   to produce the value\n * @property {Buffer} [unused] - the bytes that were left over from the original\n *   input.  This property only exists if {@linkcode Decoder.decodeFirst} or\n *   {@linkcode Decoder.decodeFirstSync} was called.\n */\n\n/**\n * @typedef DecoderOptions\n * @property {number} [max_depth=-1] - the maximum depth to parse.\n *   Use -1 for \"until you run out of memory\".  Set this to a finite\n *   positive number for un-trusted inputs.  Most standard inputs won't nest\n *   more than 100 or so levels; I've tested into the millions before\n *   running out of memory.\n * @property {object} [tags] - mapping from tag number to function(v),\n *   where v is the decoded value that comes after the tag, and where the\n *   function returns the correctly-created value for that tag.\n * @property {boolean} [bigint=true] generate JavaScript BigInt's\n *   instead of BigNumbers, when possible.\n * @property {boolean} [preferWeb=false] if true, prefer Uint8Arrays to\n *   be generated instead of node Buffers.  This might turn on some more\n *   changes in the future, so forward-compatibility is not guaranteed yet.\n * @property {string} [encoding='hex'] - The encoding of the input.\n *   Ignored if input is a Buffer.\n * @property {boolean} [required=false] - Should an error be thrown when no\n *   data is in the input?\n * @property {boolean} [extendedResults=false] - if true, emit extended\n *   results, which will be an object with shape {@link ExtendedResults}.\n *   The value will already have been null-checked.\n */\n\n/**\n  * @callback decodeCallback\n  * @param {Error} [error] - if one was generated\n  * @param {any} [value] - the decoded value\n  */\n\n/**\n  * @param {DecoderOptions|decodeCallback|string} opts options,\n  *   the callback, or input incoding\n  * @param {decodeCallback} [cb] - called on completion\n  * @returns {{options: DecoderOptions, cb: decodeCallback}}\n  * @private\n  */\n\n\nfunction normalizeOptions(opts, cb) {\n  switch (typeof opts) {\n    case 'function':\n      return {\n        options: {},\n        cb:\n        /** @type {decodeCallback} */\n        opts\n      };\n\n    case 'string':\n      return {\n        options: {\n          encoding: opts\n        },\n        cb\n      };\n\n    case 'object':\n      return {\n        options: opts || {},\n        cb\n      };\n\n    default:\n      throw new TypeError('Unknown option type');\n  }\n}\n/**\n * Decode a stream of CBOR bytes by transforming them into equivalent\n * JavaScript data.  Because of the limitations of Node object streams,\n * special symbols are emitted instead of NULL or UNDEFINED.  Fix those\n * up by calling {@link Decoder.nullcheck}.\n *\n * @extends {BinaryParseStream}\n */\n\n\nclass Decoder extends BinaryParseStream {\n  /**\n   * Create a parsing stream.\n   *\n   * @param {DecoderOptions} [options={}]\n   */\n  constructor(options = {}) {\n    const _options$tags = options.tags,\n          tags = _options$tags === void 0 ? {} : _options$tags,\n          _options$max_depth = options.max_depth,\n          max_depth = _options$max_depth === void 0 ? -1 : _options$max_depth,\n          _options$bigint = options.bigint,\n          bigint = _options$bigint === void 0 ? true : _options$bigint,\n          _options$preferWeb = options.preferWeb,\n          preferWeb = _options$preferWeb === void 0 ? false : _options$preferWeb,\n          _options$required = options.required,\n          required = _options$required === void 0 ? false : _options$required,\n          _options$encoding = options.encoding,\n          encoding = _options$encoding === void 0 ? 'hex' : _options$encoding,\n          _options$extendedResu = options.extendedResults,\n          extendedResults = _options$extendedResu === void 0 ? false : _options$extendedResu,\n          superOpts = _objectWithoutProperties(options, [\"tags\", \"max_depth\", \"bigint\", \"preferWeb\", \"required\", \"encoding\", \"extendedResults\"]);\n\n    super({\n      defaultEncoding: encoding,\n      ...superOpts\n    });\n    this.running = true;\n    this.max_depth = max_depth;\n    this.tags = tags;\n    this.preferWeb = preferWeb;\n    this.extendedResults = extendedResults;\n    this.bigint = bigint;\n\n    if (extendedResults) {\n      this.bs.on('read', this._onRead.bind(this));\n      this.valueBytes = new NoFilter();\n    }\n\n    if (bigint) {\n      if (this.tags[2] == null) {\n        this.tags[2] = _tag_2;\n      }\n\n      if (this.tags[3] == null) {\n        this.tags[3] = _tag_3;\n      }\n    }\n  }\n  /**\n   * Check the given value for a symbol encoding a NULL or UNDEFINED value in\n   * the CBOR stream.\n   *\n   * @static\n   * @param {any} val - the value to check\n   * @returns {any} the corrected value\n   *\n   * @example\n   * myDecoder.on('data', function(val) {\n   *   val = Decoder.nullcheck(val);\n   *   ...\n   * });\n   */\n\n\n  static nullcheck(val) {\n    switch (val) {\n      case SYMS.NULL:\n        return null;\n\n      case SYMS.UNDEFINED:\n        return undefined;\n      // Leaving this in for now as belt-and-suspenders, but I'm pretty sure\n      // it can't happen.\n\n      /* istanbul ignore next */\n\n      case NOT_FOUND:\n        /* istanbul ignore next */\n        throw new Error('Value not found');\n\n      default:\n        return val;\n    }\n  }\n  /**\n   * Decode the first CBOR item in the input, synchronously.  This will throw\n   * an exception if the input is not valid CBOR, or if there are more bytes\n   * left over at the end (if options.extendedResults is not true).\n   *\n   * @static\n   * @param {string|Buffer|ArrayBuffer|Uint8Array|Uint8ClampedArray\n   *   |DataView|stream.Readable} input - If a Readable stream, must have\n   *   received the `readable` event already, or you will get an error\n   *   claiming \"Insufficient data\"\n   * @param {DecoderOptions|string} [options={}] Options or encoding for input\n   * @returns {any} - the decoded value\n   */\n\n\n  static decodeFirstSync(input, options = {}) {\n    if (input == null) {\n      throw new TypeError('input required');\n    }\n\n    var _normalizeOptions = normalizeOptions(options);\n\n    options = _normalizeOptions.options;\n\n    const _options = options,\n          _options$encoding2 = _options.encoding,\n          encoding = _options$encoding2 === void 0 ? 'hex' : _options$encoding2,\n          opts = _objectWithoutProperties(_options, [\"encoding\"]);\n\n    const c = new Decoder(opts);\n    const s = utils.guessEncoding(input, encoding); // for/of doesn't work when you need to call next() with a value\n    // generator created by parser will be \"done\" after each CBOR entity\n    // parser will yield numbers of bytes that it wants\n\n    const parser = c._parse();\n\n    let state = parser.next();\n\n    while (!state.done) {\n      const b = s.read(state.value);\n\n      if (b == null || b.length !== state.value) {\n        throw new Error('Insufficient data');\n      }\n\n      if (c.extendedResults) {\n        c.valueBytes.write(b);\n      }\n\n      state = parser.next(b);\n    }\n\n    let val;\n\n    if (!c.extendedResults) {\n      val = Decoder.nullcheck(state.value);\n\n      if (s.length > 0) {\n        const nextByte = s.read(1);\n        s.unshift(nextByte);\n        throw new UnexpectedDataError(nextByte[0], val);\n      }\n    } else {\n      val = state.value;\n      val.unused = s.read();\n    }\n\n    return val;\n  }\n  /**\n   * Decode all of the CBOR items in the input into an array.  This will throw\n   * an exception if the input is not valid CBOR; a zero-length input will\n   * return an empty array.\n   *\n   * @static\n   * @param {string|Buffer|ArrayBuffer|Uint8Array|Uint8ClampedArray\n   *   |DataView|stream.Readable} input\n   * @param {DecoderOptions|string} [options={}] Options or encoding\n   *   for input\n   * @returns {Array} - Array of all found items\n   */\n\n\n  static decodeAllSync(input, options = {}) {\n    if (input == null) {\n      throw new TypeError('input required');\n    }\n\n    var _normalizeOptions2 = normalizeOptions(options);\n\n    options = _normalizeOptions2.options;\n\n    const _options2 = options,\n          _options2$encoding = _options2.encoding,\n          encoding = _options2$encoding === void 0 ? 'hex' : _options2$encoding,\n          opts = _objectWithoutProperties(_options2, [\"encoding\"]);\n\n    const c = new Decoder(opts);\n    const s = utils.guessEncoding(input, encoding);\n    const res = [];\n\n    while (s.length > 0) {\n      const parser = c._parse();\n\n      let state = parser.next();\n\n      while (!state.done) {\n        const b = s.read(state.value);\n\n        if (b == null || b.length !== state.value) {\n          throw new Error('Insufficient data');\n        }\n\n        if (c.extendedResults) {\n          c.valueBytes.write(b);\n        }\n\n        state = parser.next(b);\n      }\n\n      res.push(Decoder.nullcheck(state.value));\n    }\n\n    return res;\n  }\n  /**\n   * Decode the first CBOR item in the input.  This will error if there are\n   * more bytes left over at the end (if options.extendedResults is not true),\n   * and optionally if there were no valid CBOR bytes in the input.  Emits the\n   * {Decoder.NOT_FOUND} Symbol in the callback if no data was found and the\n   * `required` option is false.\n   *\n   * @static\n   * @param {string|Buffer|ArrayBuffer|Uint8Array|Uint8ClampedArray\n   *   |DataView|stream.Readable} input\n   * @param {DecoderOptions|decodeCallback|string} [options={}] - options, the\n   *   callback, or input encoding\n   * @param {decodeCallback} [cb] callback\n   * @returns {Promise<any>} returned even if callback is specified\n   */\n\n\n  static decodeFirst(input, options = {}, cb) {\n    if (input == null) {\n      throw new TypeError('input required');\n    }\n\n    var _normalizeOptions3 = normalizeOptions(options, cb);\n\n    options = _normalizeOptions3.options;\n    cb = _normalizeOptions3.cb;\n\n    const _options3 = options,\n          _options3$encoding = _options3.encoding,\n          encoding = _options3$encoding === void 0 ? 'hex' : _options3$encoding,\n          _options3$required = _options3.required,\n          required = _options3$required === void 0 ? false : _options3$required,\n          opts = _objectWithoutProperties(_options3, [\"encoding\", \"required\"]);\n\n    const c = new Decoder(opts);\n    /** @type {any} */\n\n    let v = NOT_FOUND;\n    const s = utils.guessEncoding(input, encoding);\n    const p = new Promise((resolve, reject) => {\n      c.on('data', val => {\n        v = Decoder.nullcheck(val);\n        c.close();\n      });\n      c.once('error', er => {\n        if (c.extendedResults && er instanceof UnexpectedDataError) {\n          v.unused = c.bs.slice();\n          return resolve(v);\n        }\n\n        if (v !== NOT_FOUND) {\n          er['value'] = v;\n        }\n\n        v = ERROR;\n        c.close();\n        return reject(er);\n      });\n      c.once('end', () => {\n        switch (v) {\n          case NOT_FOUND:\n            if (required) {\n              return reject(new Error('No CBOR found'));\n            } else {\n              return resolve(v);\n            }\n\n          // Pretty sure this can't happen, but not *certain*.\n\n          /* istanbul ignore next */\n\n          case ERROR:\n            /* istanbul ignore next */\n            return void 0;\n\n          default:\n            return resolve(v);\n        }\n      });\n    });\n\n    if (typeof cb === 'function') {\n      p.then(v => cb(null, v), cb);\n    }\n\n    s.pipe(c);\n    return p;\n  }\n  /**\n   * @callback decodeAllCallback\n   * @param {Error} error - if one was generated\n   * @param {Array} value - all of the decoded values, wrapped in an Array\n   */\n\n  /**\n   * Decode all of the CBOR items in the input.  This will error if there are\n   * more bytes left over at the end.\n   *\n   * @static\n   * @param {string|Buffer|ArrayBuffer|Uint8Array|Uint8ClampedArray\n   *   |DataView|stream.Readable} input\n   * @param {DecoderOptions|decodeAllCallback|string} [options={}] -\n   *   Decoding options, the callback, or the input encoding.\n   * @param {decodeAllCallback} [cb] callback\n   * @returns {Promise<Array>} even if callback is specified\n   */\n\n\n  static decodeAll(input, options = {}, cb) {\n    if (input == null) {\n      throw new TypeError('input required');\n    }\n\n    var _normalizeOptions4 = normalizeOptions(options, cb);\n\n    options = _normalizeOptions4.options;\n    cb = _normalizeOptions4.cb;\n\n    const _options4 = options,\n          _options4$encoding = _options4.encoding,\n          encoding = _options4$encoding === void 0 ? 'hex' : _options4$encoding,\n          opts = _objectWithoutProperties(_options4, [\"encoding\"]);\n\n    const c = new Decoder(opts);\n    const vals = [];\n    c.on('data', val => {\n      return vals.push(Decoder.nullcheck(val));\n    });\n    const p = new Promise((resolve, reject) => {\n      c.on('error', reject);\n      c.on('end', () => resolve(vals));\n    });\n\n    if (typeof cb === 'function') {\n      p.then(v => cb(undefined, v), er => cb(er, undefined));\n    }\n\n    utils.guessEncoding(input, encoding).pipe(c);\n    return p;\n  }\n  /**\n   * Stop processing\n   */\n\n\n  close() {\n    this.running = false;\n    this.__fresh = true;\n  }\n  /**\n   * Only called if extendedResults is true\n   * @ignore\n   */\n\n\n  _onRead(data) {\n    this.valueBytes.write(data);\n  }\n  /**\n   * @ignore\n   * @returns {Generator<number, any, Buffer>}\n   */\n\n\n  *_parse() {\n    let parent = null;\n    let depth = 0;\n    let val = null;\n\n    while (true) {\n      if (this.max_depth >= 0 && depth > this.max_depth) {\n        throw new Error('Maximum depth ' + this.max_depth + ' exceeded');\n      }\n\n      const octet = (yield 1)[0];\n\n      if (!this.running) {\n        this.bs.unshift(Buffer.from([octet]));\n        throw new UnexpectedDataError(octet);\n      }\n\n      const mt = octet >> 5;\n      const ai = octet & 0x1f;\n      const parent_major = parent != null ? parent[MAJOR] : undefined;\n      const parent_length = parent != null ? parent.length : undefined;\n\n      switch (ai) {\n        case NUMBYTES.ONE:\n          this.emit('more-bytes', mt, 1, parent_major, parent_length);\n          val = (yield 1)[0];\n          break;\n\n        case NUMBYTES.TWO:\n        case NUMBYTES.FOUR:\n        case NUMBYTES.EIGHT:\n          const numbytes = 1 << ai - 24;\n          this.emit('more-bytes', mt, numbytes, parent_major, parent_length);\n          const buf = yield numbytes;\n          val = mt === MT.SIMPLE_FLOAT ? buf : utils.parseCBORint(ai, buf, this.bigint);\n          break;\n\n        case 28:\n        case 29:\n        case 30:\n          this.running = false;\n          throw new Error('Additional info not implemented: ' + ai);\n\n        case NUMBYTES.INDEFINITE:\n          switch (mt) {\n            case MT.POS_INT:\n            case MT.NEG_INT:\n            case MT.TAG:\n              throw new Error(\"Invalid indefinite encoding for MT \".concat(mt));\n          }\n\n          val = -1;\n          break;\n\n        default:\n          val = ai;\n      }\n\n      switch (mt) {\n        case MT.POS_INT:\n          // val already decoded\n          break;\n\n        case MT.NEG_INT:\n          if (val === Number.MAX_SAFE_INTEGER) {\n            val = this.bigint ? BI.NEG_MAX : BN.NEG_MAX;\n          } else if (val instanceof BigNumber) {\n            val = BN.MINUS_ONE.minus(val);\n          } else {\n            val = typeof val === 'bigint' ? BI.MINUS_ONE - val : -1 - val;\n          }\n\n          break;\n\n        case MT.BYTE_STRING:\n        case MT.UTF8_STRING:\n          switch (val) {\n            case 0:\n              this.emit('start-string', mt, val, parent_major, parent_length);\n\n              if (mt === MT.UTF8_STRING) {\n                val = '';\n              } else {\n                val = this.preferWeb ? new Uint8Array(0) : Buffer.allocUnsafe(0);\n              }\n\n              break;\n\n            case -1:\n              this.emit('start', mt, SYMS.STREAM, parent_major, parent_length);\n              parent = parentBufferStream(parent, mt);\n              depth++;\n              continue;\n\n            default:\n              this.emit('start-string', mt, val, parent_major, parent_length);\n              val = yield val;\n\n              if (mt === MT.UTF8_STRING) {\n                val = utils.utf8(val);\n              } else if (this.preferWeb) {\n                val = new Uint8Array(val.buffer, val.byteOffset, val.length);\n              }\n\n          }\n\n          break;\n\n        case MT.ARRAY:\n        case MT.MAP:\n          switch (val) {\n            case 0:\n              val = mt === MT.MAP ? {} : [];\n              break;\n\n            case -1:\n              this.emit('start', mt, SYMS.STREAM, parent_major, parent_length);\n              parent = parentArray(parent, mt, -1);\n              depth++;\n              continue;\n\n            default:\n              this.emit('start', mt, val, parent_major, parent_length);\n              parent = parentArray(parent, mt, val * (mt - 3));\n              depth++;\n              continue;\n          }\n\n          break;\n\n        case MT.TAG:\n          this.emit('start', mt, val, parent_major, parent_length);\n          parent = parentArray(parent, mt, 1);\n          parent.push(val);\n          depth++;\n          continue;\n\n        case MT.SIMPLE_FLOAT:\n          if (typeof val === 'number') {\n            if (ai === NUMBYTES.ONE && val < 32) {\n              throw new Error(\"Invalid two-byte encoding of simple value \".concat(val));\n            }\n\n            const hasParent = parent != null;\n            val = Simple.decode(val, hasParent, hasParent && parent[COUNT] < 0);\n          } else {\n            val = utils.parseCBORfloat(val);\n          }\n\n      }\n\n      this.emit('value', val, parent_major, parent_length, ai);\n      let again = false;\n\n      while (parent != null) {\n        switch (false) {\n          case val !== SYMS.BREAK:\n            parent[COUNT] = 1;\n            break;\n\n          case !Array.isArray(parent):\n            parent.push(val);\n            break;\n\n          case !(parent instanceof NoFilter):\n            const pm = parent[MAJOR];\n\n            if (pm != null && pm !== mt) {\n              this.running = false;\n              throw new Error('Invalid major type in indefinite encoding');\n            }\n\n            parent.write(val);\n        }\n\n        if (--parent[COUNT] !== 0) {\n          again = true;\n          break;\n        }\n\n        --depth;\n        delete parent[COUNT];\n\n        if (Array.isArray(parent)) {\n          switch (parent[MAJOR]) {\n            case MT.ARRAY:\n              val = parent;\n              break;\n\n            case MT.MAP:\n              let allstrings = true;\n\n              if (parent.length % 2 !== 0) {\n                throw new Error('Invalid map length: ' + parent.length);\n              }\n\n              for (let i = 0, len = parent.length; i < len; i += 2) {\n                if (typeof parent[i] !== 'string') {\n                  allstrings = false;\n                  break;\n                }\n              }\n\n              if (allstrings) {\n                val = {};\n\n                for (let i = 0, len = parent.length; i < len; i += 2) {\n                  val[parent[i]] = parent[i + 1];\n                }\n              } else {\n                val = new Map();\n\n                for (let i = 0, len = parent.length; i < len; i += 2) {\n                  val.set(parent[i], parent[i + 1]);\n                }\n              }\n\n              break;\n\n            case MT.TAG:\n              const t = new Tagged(parent[0], parent[1]);\n              val = t.convert(this.tags);\n              break;\n          }\n        } else\n          /* istanbul ignore else */\n          if (parent instanceof NoFilter) {\n            // only parent types are Array and NoFilter for (Array/Map) and\n            // (bytes/string) respectively.\n            switch (parent[MAJOR]) {\n              case MT.BYTE_STRING:\n                val = parent.slice();\n\n                if (this.preferWeb) {\n                  val = new Uint8Array(val.buffer, val.byteOffset, val.length);\n                }\n\n                break;\n\n              case MT.UTF8_STRING:\n                val = parent.toString('utf-8');\n                break;\n            }\n          }\n\n        this.emit('stop', parent[MAJOR]);\n        const old = parent;\n        parent = parent[SYMS.PARENT];\n        delete old[SYMS.PARENT];\n        delete old[MAJOR];\n      }\n\n      if (!again) {\n        if (this.extendedResults) {\n          const bytes = this.valueBytes.slice();\n          const ret = {\n            value: Decoder.nullcheck(val),\n            bytes,\n            length: bytes.length\n          };\n          this.valueBytes = new NoFilter();\n          return ret;\n        }\n\n        return val;\n      }\n    }\n  }\n\n}\n\nDecoder.NOT_FOUND = NOT_FOUND;\nmodule.exports = Decoder;","map":null,"metadata":{},"sourceType":"script"}