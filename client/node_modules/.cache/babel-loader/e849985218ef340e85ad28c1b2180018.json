{"ast":null,"code":"'use strict';\n\nconst toSources = require('./utils/to-sources');\n\nconst cp = require('./cp');\n\nconst rm = require('./rm');\n\nconst withTimeoutOption = require('ipfs-core-utils/src/with-timeout-option');\n\nconst defaultOptions = {\n  parents: false,\n  recursive: false,\n  flush: true,\n  cidVersion: 0,\n  hashAlg: 'sha2-256',\n  shardSplitThreshold: 1000,\n  signal: undefined\n};\n/**\n *\n * @param {any} context\n */\n\nmodule.exports = context => {\n  /**\n   *\n   * @param  {[...from:From, to:string, options?:MvOptions]} args\n   * @returns {Promise<void>}\n   */\n  async function mfsMv(...args) {\n    const _ref = await toSources(context, args, defaultOptions),\n          sources = _ref.sources,\n          options = _ref.options;\n\n    const cpArgs = sources.map(source => source.path).concat(options); // remove the last source as it'll be the destination\n\n    const rmArgs = sources.slice(0, -1).map(source => source.path).concat(Object.assign(options, {\n      recursive: true\n    }));\n    await cp(context).apply(null, cpArgs);\n    await rm(context).apply(null, rmArgs);\n  }\n\n  return withTimeoutOption(mfsMv);\n};\n/**\n * @typedef {Object} MvOptions\n * @property {boolean} [parents=false]\n * @property {boolean} [flush=false]\n * @property {string} [hashAlg='sha2-256']\n * @property {0|1} [cidVersion]\n *\n * @typedef {import('./utils/types').Tuple<string>} From\n * @typedef {import('cids')} CID\n * @typedef {import('../../utils').AbortOptions} AbortOptions\n */","map":null,"metadata":{},"sourceType":"script"}