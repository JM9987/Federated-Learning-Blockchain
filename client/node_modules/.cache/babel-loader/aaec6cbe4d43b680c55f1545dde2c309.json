{"ast":null,"code":"'use strict';\n\nconst defaultMigrations = require('../migrations');\n\nconst repoVersion = require('./repo/version');\n\nconst repoLock = require('./repo/lock');\n\nconst errors = require('./errors');\n\nconst log = require('debug')('ipfs:repo:migrator');\n\nexports.getCurrentRepoVersion = repoVersion.getVersion;\nexports.errors = errors;\n/**\n * Returns the version of latest migration.\n * If no migrations are present returns 0.\n *\n * @param {?Array} migrations - Array of migrations to consider. If undefined, the bundled migrations are used. Mainly for testing purpose.\n * @returns {int}\n */\n\nfunction getLatestMigrationVersion(migrations) {\n  migrations = migrations || defaultMigrations;\n\n  if (!Array.isArray(migrations) || migrations.length === 0) {\n    return 0;\n  }\n\n  return migrations[migrations.length - 1].version;\n}\n\nexports.getLatestMigrationVersion = getLatestMigrationVersion;\n/**\n * Main function to execute forward migrations.\n * It acquire lock on the provided path before doing any migrations.\n *\n * Signature of the progress callback is: function(migrationObject: object, currentMigrationNumber: int, totalMigrationsCount: int)\n *\n * @param {string} path - Path to initialized (!) JS-IPFS repo\n * @param {Object} repoOptions - Options that are passed to migrations, that can use them to correctly construct datastore. Options are same like for IPFSRepo.\n * @param {int} toVersion - Version to which the repo should be migrated.\n * @param {Object?} options - Options for migration\n * @param {boolean?} options.ignoreLock - Won't lock the repo for applying the migrations. Use with caution.\n * @param {?Function} options.onProgress - Callback which will be called after each executed migration to report progress\n * @param {boolean?} options.isDryRun - Allows to simulate the execution of the migrations without any effect.\n * @param {?Array} options.migrations - Array of migrations to migrate. If undefined, the bundled migrations are used. Mainly for testing purpose.\n * @returns {Promise<void>}\n */\n\nasync function migrate(path, repoOptions, toVersion, {\n  ignoreLock = false,\n  onProgress,\n  isDryRun = false,\n  migrations\n}) {\n  migrations = migrations || defaultMigrations;\n\n  if (!path) {\n    throw new errors.RequiredParameterError('Path argument is required!');\n  }\n\n  if (!repoOptions) {\n    throw new errors.RequiredParameterError('repoOptions argument is required!');\n  }\n\n  if (!toVersion) {\n    throw new errors.RequiredParameterError('toVersion argument is required!');\n  }\n\n  if (!Number.isInteger(toVersion) || toVersion <= 0) {\n    throw new errors.InvalidValueError('Version has to be positive integer!');\n  }\n\n  const currentVersion = await repoVersion.getVersion(path, repoOptions);\n\n  if (currentVersion === toVersion) {\n    log('Nothing to migrate.');\n    return;\n  }\n\n  if (currentVersion > toVersion) {\n    throw new errors.InvalidValueError(\"Current repo's version (\".concat(currentVersion, \") is higher then toVersion (\").concat(toVersion, \"), you probably wanted to revert it?\"));\n  }\n\n  verifyAvailableMigrations(migrations, currentVersion, toVersion);\n  let lock;\n\n  if (!isDryRun && !ignoreLock) {\n    lock = await repoLock.lock(currentVersion, path);\n  }\n\n  try {\n    for (const migration of migrations) {\n      if (toVersion !== undefined && migration.version > toVersion) {\n        break;\n      }\n\n      if (migration.version <= currentVersion) {\n        continue;\n      }\n\n      log(\"Migrating version \".concat(migration.version));\n\n      try {\n        if (!isDryRun) {\n          let progressCallback;\n\n          if (onProgress) {\n            // eslint-disable-line max-depth\n            progressCallback = (percent, message) => onProgress(migration.version, percent.toFixed(2), message);\n          }\n\n          await migration.migrate(path, repoOptions, progressCallback);\n        }\n      } catch (e) {\n        const lastSuccessfullyMigratedVersion = migration.version - 1;\n        log(\"An exception was raised during execution of migration. Setting the repo's version to last successfully migrated version: \".concat(lastSuccessfullyMigratedVersion));\n        await repoVersion.setVersion(path, lastSuccessfullyMigratedVersion, repoOptions);\n        throw new Error(\"During migration to version \".concat(migration.version, \" exception was raised: \").concat(e.stack || e.message || e));\n      }\n\n      log(\"Migrating to version \".concat(migration.version, \" finished\"));\n    }\n\n    if (!isDryRun) {\n      await repoVersion.setVersion(path, toVersion || getLatestMigrationVersion(migrations), repoOptions);\n    }\n\n    log('Repo successfully migrated', toVersion !== undefined ? \"to version \".concat(toVersion, \"!\") : 'to latest version!');\n  } finally {\n    if (!isDryRun && !ignoreLock) {\n      await lock.close();\n    }\n  }\n}\n\nexports.migrate = migrate;\n/**\n * Main function to execute backward migration (reversion).\n * It acquire lock on the provided path before doing any migrations.\n *\n * Signature of the progress callback is: function(migrationObject: object, currentMigrationNumber: int, totalMigrationsCount: int)\n *\n * @param {string} path - Path to initialized (!) JS-IPFS repo\n * @param {Object} repoOptions - Options that are passed to migrations, that can use them to correctly construct datastore. Options are same like for IPFSRepo.\n * @param {int} toVersion - Version to which the repo will be reverted.\n * @param {Object?} options - Options for the reversion\n * @param {?Function} options.onProgress - Callback which will be called after each reverted migration to report progress\n * @param {boolean?} options.isDryRun - Allows to simulate the execution of the reversion without any effects. Make sense to utilize onProgress with this argument.\n * @param {boolean?} options.ignoreLock - Won't lock the repo for reverting the migrations. Use with caution.\n * @param {?Array} options.migrations - Array of migrations to migrate. If undefined, the bundled migrations are used. Mainly for testing purpose.\n * @returns {Promise<void>}\n */\n\nasync function revert(path, repoOptions, toVersion, {\n  ignoreLock = false,\n  onProgress,\n  isDryRun = false,\n  migrations\n}) {\n  migrations = migrations || defaultMigrations;\n\n  if (!path) {\n    throw new errors.RequiredParameterError('Path argument is required!');\n  }\n\n  if (!repoOptions) {\n    throw new errors.RequiredParameterError('repoOptions argument is required!');\n  }\n\n  if (!toVersion) {\n    throw new errors.RequiredParameterError('When reverting migrations, you have to specify to which version to revert!');\n  }\n\n  if (!Number.isInteger(toVersion) || toVersion <= 0) {\n    throw new errors.InvalidValueError('Version has to be positive integer!');\n  }\n\n  const currentVersion = await repoVersion.getVersion(path, repoOptions);\n\n  if (currentVersion === toVersion) {\n    log('Nothing to revert.');\n    return;\n  }\n\n  if (currentVersion < toVersion) {\n    throw new errors.InvalidValueError(\"Current repo's version (\".concat(currentVersion, \") is lower then toVersion (\").concat(toVersion, \"), you probably wanted to migrate it?\"));\n  }\n\n  verifyAvailableMigrations(migrations, toVersion, currentVersion, true);\n  let lock;\n  if (!isDryRun && !ignoreLock) lock = await repoLock.lock(currentVersion, path);\n  log(\"Reverting from version \".concat(currentVersion, \" to \").concat(toVersion));\n\n  try {\n    const reversedMigrationArray = migrations.slice().reverse();\n\n    for (const migration of reversedMigrationArray) {\n      if (migration.version <= toVersion) {\n        break;\n      }\n\n      if (migration.version > currentVersion) {\n        continue;\n      }\n\n      log(\"Reverting migration version \".concat(migration.version));\n\n      try {\n        if (!isDryRun) {\n          let progressCallback;\n\n          if (onProgress) {\n            // eslint-disable-line max-depth\n            progressCallback = (percent, message) => onProgress(migration.version, percent.toFixed(2), message);\n          }\n\n          await migration.revert(path, repoOptions, progressCallback);\n        }\n      } catch (e) {\n        const lastSuccessfullyRevertedVersion = migration.version;\n        log(\"An exception was raised during execution of migration. Setting the repo's version to last successfully reverted version: \".concat(lastSuccessfullyRevertedVersion));\n        await repoVersion.setVersion(path, lastSuccessfullyRevertedVersion, repoOptions);\n        e.message = \"During reversion to version \".concat(migration.version, \" exception was raised: \").concat(e.message);\n        throw e;\n      }\n\n      log(\"Reverting to version \".concat(migration.version, \" finished\"));\n    }\n\n    if (!isDryRun) {\n      await repoVersion.setVersion(path, toVersion, repoOptions);\n    }\n\n    log(\"All migrations successfully reverted to version \".concat(toVersion, \"!\"));\n  } finally {\n    if (!isDryRun && !ignoreLock) {\n      await lock.close();\n    }\n  }\n}\n\nexports.revert = revert;\n/**\n * Function checks if all migrations in given range are available.\n *\n * @param {Array} migrations\n * @param {int} fromVersion\n * @param {int} toVersion\n * @param {boolean} checkReversibility - Will additionally checks if all the migrations in the range are reversible\n * @returns {void}\n */\n\nfunction verifyAvailableMigrations(migrations, fromVersion, toVersion, checkReversibility = false) {\n  let migrationCounter = 0;\n\n  for (const migration of migrations) {\n    if (migration.version > toVersion) {\n      break;\n    }\n\n    if (migration.version > fromVersion) {\n      if (checkReversibility && !migration.revert) {\n        throw new errors.NonReversibleMigrationError(\"It is not possible to revert to version \".concat(fromVersion, \" because migration version \").concat(migration.version, \" is not reversible. Cancelling reversion.\"));\n      }\n\n      migrationCounter++;\n    }\n  }\n\n  if (migrationCounter !== toVersion - fromVersion) {\n    throw new errors.InvalidValueError(\"The ipfs-repo-migrations package does not have all migration to migrate from version \".concat(fromVersion, \" to \").concat(toVersion));\n  }\n}","map":null,"metadata":{},"sourceType":"script"}