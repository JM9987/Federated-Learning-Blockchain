{"ast":null,"code":"'use strict';\n\nconst _require = require('buffer'),\n      Buffer = _require.Buffer; // @ts-ignore\n\n\nconst BufferList = require('bl/BufferList');\n\nconst varintDecode = require('./varint-decode'); // Maximum length of the length section of the message\n\n\nconst MAX_LENGTH_LENGTH = 8; // Varint.encode(Number.MAX_SAFE_INTEGER).length\n// Maximum length of the data section of the message\n\nconst MAX_DATA_LENGTH = 1024 * 1024 * 4;\nconst Empty = Buffer.alloc(0);\nconst ReadModes = {\n  LENGTH: 'readLength',\n  DATA: 'readData'\n};\nconst ReadHandlers = {\n  /**\n   * @param {BufferList} chunk\n   * @param {BufferList} buffer\n   * @param {import('./types').ReadState | undefined} state\n   * @param {import('./types').DecoderOptions} options\n   * @returns {import('./types').ReadResult}\n   */\n  [ReadModes.LENGTH]: (chunk, buffer, state, options) => {\n    // console.log(ReadModes.LENGTH, chunk.length)\n    buffer = buffer.append(chunk);\n    let dataLength;\n\n    try {\n      dataLength = options.lengthDecoder(buffer);\n    } catch (err) {\n      if (buffer.length > options.maxLengthLength) {\n        throw Object.assign(err, {\n          message: 'message length too long',\n          code: 'ERR_MSG_LENGTH_TOO_LONG'\n        });\n      }\n\n      if (err instanceof RangeError) {\n        return {\n          mode: ReadModes.LENGTH,\n          buffer,\n          chunk: undefined,\n          state: undefined,\n          data: undefined\n        };\n      }\n\n      throw err;\n    }\n\n    if (dataLength > options.maxDataLength) {\n      throw Object.assign(new Error('message data too long'), {\n        code: 'ERR_MSG_DATA_TOO_LONG'\n      });\n    }\n\n    chunk = buffer.shallowSlice(options.lengthDecoder.bytes);\n    buffer = new BufferList();\n    if (options.onLength) options.onLength(dataLength);\n\n    if (dataLength <= 0) {\n      if (options.onData) options.onData(Empty);\n      return {\n        mode: ReadModes.LENGTH,\n        chunk,\n        buffer,\n        data: Empty\n      };\n    }\n\n    return {\n      mode: ReadModes.DATA,\n      chunk,\n      buffer,\n      state: {\n        dataLength\n      },\n      data: undefined\n    };\n  },\n\n  /**\n   * @param {BufferList} chunk\n   * @param {BufferList} buffer\n   * @param {import('./types').ReadState | undefined} state\n   * @param {import('./types').DecoderOptions} options\n   * @returns {import('./types').ReadResult}\n   */\n  [ReadModes.DATA]: (chunk, buffer, state, options) => {\n    // console.log(ReadModes.DATA, chunk.length)\n    buffer = buffer.append(chunk);\n\n    if (!state) {\n      throw new Error('state is required');\n    }\n\n    if (buffer.length < state.dataLength) {\n      return {\n        mode: ReadModes.DATA,\n        buffer,\n        state,\n        chunk: undefined,\n        data: undefined\n      };\n    }\n\n    const dataLength = state.dataLength;\n    const data = buffer.shallowSlice(0, dataLength);\n    const nextChunk = buffer.length > dataLength ? buffer.shallowSlice(dataLength) : undefined;\n    buffer = new BufferList();\n    if (options.onData) options.onData(data);\n    return {\n      mode: ReadModes.LENGTH,\n      chunk: nextChunk,\n      buffer,\n      state: undefined,\n      data\n    };\n  }\n};\n/**\n * @param {any} [options]\n */\n\nfunction decode(options) {\n  options = options || {};\n  /**\n   * @type {import('./types').DecoderOptions}\n   */\n\n  const opts = {\n    lengthDecoder: options.lengthDecoder || varintDecode,\n    maxLengthLength: options.maxLengthLength || MAX_LENGTH_LENGTH,\n    maxDataLength: options.maxDataLength || MAX_DATA_LENGTH,\n    onLength: options.onLength,\n    onData: options.onData\n  };\n  /**\n   * @param {AsyncIterable<BufferList>} source\n   */\n\n  const decoder = async function* (source) {\n    let buffer = new BufferList();\n    let mode = ReadModes.LENGTH; // current parsing mode\n\n    let state; // accumulated state for the current mode\n\n    for await (const chunk of source) {\n      /** @type {BufferList | undefined} */\n      let nextChunk = chunk; // Each chunk may contain multiple messages - keep calling handler for the\n      // current parsing mode until all handlers have consumed the chunk.\n\n      while (nextChunk) {\n        const result = ReadHandlers[mode](nextChunk, buffer, state, opts);\n        mode = result.mode;\n        nextChunk = result.chunk;\n        buffer = result.buffer;\n        state = result.state;\n\n        if (result.data) {\n          yield result.data;\n        }\n      }\n    }\n\n    if (buffer.length) {\n      throw Object.assign(new Error('unexpected end of input'), {\n        code: 'ERR_UNEXPECTED_EOF'\n      });\n    }\n  };\n\n  return decoder;\n}\n/**\n * @param {*} reader\n * @param {import('./types').DecoderOptions} [options]\n * @returns\n */\n\n\ndecode.fromReader = (reader, options) => {\n  let byteLength = 1; // Read single byte chunks until the length is known\n\n  const varByteSource = {\n    [Symbol.asyncIterator]() {\n      return this;\n    },\n\n    next: async () => {\n      try {\n        return await reader.next(byteLength);\n      } catch (err) {\n        if (err.code === 'ERR_UNDER_READ') {\n          return {\n            done: true,\n            value: null\n          };\n        }\n\n        throw err;\n      } finally {\n        // Reset the byteLength so we continue to check for varints\n        byteLength = 1;\n      }\n    }\n  };\n  /**\n   * Once the length has been parsed, read chunk for that length\n   *\n   * @param {number} l\n   */\n\n  const onLength = l => {\n    byteLength = l;\n  };\n\n  return decode({ ...(options || {}),\n    onLength\n  })(varByteSource);\n};\n\nmodule.exports = decode;\nmodule.exports.MAX_LENGTH_LENGTH = MAX_LENGTH_LENGTH;\nmodule.exports.MAX_DATA_LENGTH = MAX_DATA_LENGTH;","map":null,"metadata":{},"sourceType":"script"}