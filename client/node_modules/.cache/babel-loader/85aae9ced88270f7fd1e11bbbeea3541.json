{"ast":null,"code":"'use strict';\n/**\n * Enum for Signature Policy\n * Details how message signatures are produced/consumed\n */\n\nconst SignaturePolicy = {\n  /**\n   * On the producing side:\n   * * Build messages with the signature, key (from may be enough for certain inlineable public key types), from and seqno fields.\n   *\n   * On the consuming side:\n   * * Enforce the fields to be present, reject otherwise.\n   * * Propagate only if the fields are valid and signature can be verified, reject otherwise.\n   */\n  StrictSign:\n  /** @type {'StrictSign'} */\n  'StrictSign',\n\n  /**\n   * On the producing side:\n   * * Build messages without the signature, key, from and seqno fields.\n   * * The corresponding protobuf key-value pairs are absent from the marshalled message, not just empty.\n   *\n   * On the consuming side:\n   * * Enforce the fields to be absent, reject otherwise.\n   * * Propagate only if the fields are absent, reject otherwise.\n   * * A message_id function will not be able to use the above fields, and should instead rely on the data field. A commonplace strategy is to calculate a hash.\n   */\n  StrictNoSign:\n  /** @type {'StrictNoSign'} */\n  'StrictNoSign'\n};\nexports.SignaturePolicy = SignaturePolicy;\n/**\n * @typedef {SignaturePolicy[keyof SignaturePolicy]} SignaturePolicyType\n */","map":null,"metadata":{},"sourceType":"script"}