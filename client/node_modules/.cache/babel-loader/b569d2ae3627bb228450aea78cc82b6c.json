{"ast":null,"code":"'use strict';\n\nconst _require = require('interface-datastore'),\n      Key = _require.Key,\n      utf8Decoder = _require.utils.utf8Decoder;\n\nconst readme = require('./shard-readme');\n/**\n * @typedef {import('interface-datastore').Datastore} Datastore\n * @typedef {import('./types').Shard} Shard\n */\n\n\nconst PREFIX = '/repo/flatfs/shard/';\nconst SHARDING_FN = 'SHARDING';\nconst README_FN = '_README';\n/**\n * @implements {Shard}\n */\n\nclass ShardBase {\n  /**\n   * @param {any} param\n   */\n  constructor(param) {\n    this.param = param;\n    this.name = 'base';\n    this._padding = '';\n  }\n  /**\n   * @param {string} s\n   */\n\n\n  fun(s) {\n    return 'implement me';\n  }\n\n  toString() {\n    return \"\".concat(PREFIX, \"v1/\").concat(this.name, \"/\").concat(this.param);\n  }\n\n}\n/**\n * @implements {Shard}\n */\n\n\nclass Prefix extends ShardBase {\n  /**\n   * @param {number} prefixLen\n   */\n  constructor(prefixLen) {\n    super(prefixLen);\n    this._padding = ''.padStart(prefixLen, '_');\n    this.name = 'prefix';\n  }\n  /**\n   * @param {string} noslash\n   */\n\n\n  fun(noslash) {\n    return (noslash + this._padding).slice(0, this.param);\n  }\n\n}\n\nclass Suffix extends ShardBase {\n  /**\n   * @param {number} suffixLen\n   */\n  constructor(suffixLen) {\n    super(suffixLen);\n    this._padding = ''.padStart(suffixLen, '_');\n    this.name = 'suffix';\n  }\n  /**\n   * @param {string} noslash\n   */\n\n\n  fun(noslash) {\n    const s = this._padding + noslash;\n    return s.slice(s.length - this.param);\n  }\n\n}\n\nclass NextToLast extends ShardBase {\n  /**\n   * @param {number} suffixLen\n   */\n  constructor(suffixLen) {\n    super(suffixLen);\n    this._padding = ''.padStart(suffixLen + 1, '_');\n    this.name = 'next-to-last';\n  }\n  /**\n   * @param {string} noslash\n   */\n\n\n  fun(noslash) {\n    const s = this._padding + noslash;\n    const offset = s.length - this.param - 1;\n    return s.slice(offset, offset + this.param);\n  }\n\n}\n/**\n * Convert a given string to the matching sharding function.\n *\n * @param {string} str\n * @returns {Shard}\n */\n\n\nfunction parseShardFun(str) {\n  str = str.trim();\n\n  if (str.length === 0) {\n    throw new Error('empty shard string');\n  }\n\n  if (!str.startsWith(PREFIX)) {\n    throw new Error(\"invalid or no path prefix: \".concat(str));\n  }\n\n  const parts = str.slice(PREFIX.length).split('/');\n  const version = parts[0];\n\n  if (version !== 'v1') {\n    throw new Error(\"expect 'v1' version, got '\".concat(version, \"'\"));\n  }\n\n  const name = parts[1];\n\n  if (!parts[2]) {\n    throw new Error('missing param');\n  }\n\n  const param = parseInt(parts[2], 10);\n\n  switch (name) {\n    case 'prefix':\n      return new Prefix(param);\n\n    case 'suffix':\n      return new Suffix(param);\n\n    case 'next-to-last':\n      return new NextToLast(param);\n\n    default:\n      throw new Error(\"unkown sharding function: \".concat(name));\n  }\n}\n/**\n * @param {string | Uint8Array} path\n * @param {Datastore} store\n */\n\n\nconst readShardFun = async (path, store) => {\n  const key = new Key(path).child(new Key(SHARDING_FN)); // @ts-ignore\n\n  const get = typeof store.getRaw === 'function' ? store.getRaw.bind(store) : store.get.bind(store);\n  const res = await get(key);\n  return parseShardFun(utf8Decoder.decode(res || '').trim());\n};\n\nmodule.exports = {\n  readme,\n  parseShardFun,\n  readShardFun,\n  Prefix,\n  Suffix,\n  NextToLast,\n  README_FN,\n  SHARDING_FN,\n  PREFIX\n};","map":null,"metadata":{},"sourceType":"script"}