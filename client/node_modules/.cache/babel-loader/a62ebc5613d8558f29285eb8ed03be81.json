{"ast":null,"code":"'use strict';\n\nconst NoFilter = require('nofilter');\n\nconst stream = require('stream');\n\nconst util = require('util');\n\nconst _require = require('./constants'),\n      BigNumber = _require.BigNumber,\n      NUMBYTES = _require.NUMBYTES,\n      SHIFT32 = _require.SHIFT32,\n      BI = _require.BI,\n      SYMS = _require.SYMS;\n\nconst MAX_SAFE_HIGH = 0x1fffff;\n/**\n * Convert a UTF8-encoded Buffer to a JS string.  If possible, throw an error\n * on invalid UTF8.  Byte Order Marks are not looked at or stripped.\n */\n\n/* istanbul ignore next */\n// TextDecoder in node 11+, browsers\n\nconst TD = typeof TextDecoder === 'function' ? TextDecoder : util.TextDecoder;\nconst td = new TD('utf8', {\n  fatal: true,\n  ignoreBOM: true\n});\n\nexports.utf8 = buf => td.decode(buf);\n\nexports.utf8.checksUTF8 = true;\n\nexports.parseCBORint = function (ai, buf, bigInt = true) {\n  switch (ai) {\n    case NUMBYTES.ONE:\n      return buf.readUInt8(0);\n\n    case NUMBYTES.TWO:\n      return buf.readUInt16BE(0);\n\n    case NUMBYTES.FOUR:\n      return buf.readUInt32BE(0);\n\n    case NUMBYTES.EIGHT:\n      const f = buf.readUInt32BE(0);\n      const g = buf.readUInt32BE(4);\n\n      if (f > MAX_SAFE_HIGH) {\n        if (bigInt) {\n          return BigInt(f) * BI.SHIFT32 + BigInt(g);\n        }\n\n        return new BigNumber(f).times(SHIFT32).plus(g);\n      } else {\n        return f * SHIFT32 + g;\n      }\n\n    default:\n      throw new Error('Invalid additional info for int: ' + ai);\n  }\n};\n\nexports.writeHalf = function writeHalf(buf, half) {\n  // assume 0, -0, NaN, Infinity, and -Infinity have already been caught\n  // HACK: everyone settle in.  This isn't going to be pretty.\n  // Translate cn-cbor's C code (from Carsten Borman):\n  // uint32_t be32;\n  // uint16_t be16, u16;\n  // union {\n  //   float f;\n  //   uint32_t u;\n  // } u32;\n  // u32.f = float_val;\n  const u32 = Buffer.allocUnsafe(4);\n  u32.writeFloatBE(half, 0);\n  const u = u32.readUInt32BE(0); // if ((u32.u & 0x1FFF) == 0) { /* worth trying half */\n  // hildjj: If the lower 13 bits aren't 0,\n  // we will lose precision in the conversion.\n  // mant32 = 24bits, mant16 = 11bits, 24-11 = 13\n\n  if ((u & 0x1FFF) !== 0) {\n    return false;\n  } //   int s16 = (u32.u >> 16) & 0x8000;\n  //   int exp = (u32.u >> 23) & 0xff;\n  //   int mant = u32.u & 0x7fffff;\n\n\n  let s16 = u >> 16 & 0x8000; // top bit is sign\n\n  const exp = u >> 23 & 0xff; // then 5 bits of exponent\n\n  const mant = u & 0x7fffff; //   if (exp == 0 && mant == 0)\n  //     ;              /* 0.0, -0.0 */\n  // hildjj: zeros already handled.  Assert if you don't believe me.\n  //   else if (exp >= 113 && exp <= 142) /* normalized */\n  //     s16 += ((exp - 112) << 10) + (mant >> 13);\n\n  if (exp >= 113 && exp <= 142) {\n    s16 += (exp - 112 << 10) + (mant >> 13);\n  } else if (exp >= 103 && exp < 113) {\n    //   else if (exp >= 103 && exp < 113) { /* denorm, exp16 = 0 */\n    //     if (mant & ((1 << (126 - exp)) - 1))\n    //       goto float32;         /* loss of precision */\n    //     s16 += ((mant + 0x800000) >> (126 - exp));\n    if (mant & (1 << 126 - exp) - 1) {\n      return false;\n    }\n\n    s16 += mant + 0x800000 >> 126 - exp;\n  } else {\n    //   } else if (exp == 255 && mant == 0) { /* Inf */\n    //     s16 += 0x7c00;\n    // hildjj: Infinity already handled\n    //   } else\n    //     goto float32;           /* loss of range */\n    return false;\n  } //   ensure_writable(3);\n  //   u16 = s16;\n  //   be16 = hton16p((const uint8_t*)&u16);\n\n\n  buf.writeUInt16BE(s16);\n  return true;\n};\n\nexports.parseHalf = function parseHalf(buf) {\n  const sign = buf[0] & 0x80 ? -1 : 1;\n  const exp = (buf[0] & 0x7C) >> 2;\n  const mant = (buf[0] & 0x03) << 8 | buf[1];\n\n  if (!exp) {\n    return sign * 5.9604644775390625e-8 * mant;\n  } else if (exp === 0x1f) {\n    return sign * (mant ? 0 / 0 : 2e308);\n  } else {\n    return sign * Math.pow(2, exp - 25) * (1024 + mant);\n  }\n};\n\nexports.parseCBORfloat = function parseCBORfloat(buf) {\n  switch (buf.length) {\n    case 2:\n      return exports.parseHalf(buf);\n\n    case 4:\n      return buf.readFloatBE(0);\n\n    case 8:\n      return buf.readDoubleBE(0);\n\n    default:\n      throw new Error('Invalid float size: ' + buf.length);\n  }\n};\n\nexports.hex = function hex(s) {\n  return Buffer.from(s.replace(/^0x/, ''), 'hex');\n};\n\nexports.bin = function bin(s) {\n  s = s.replace(/\\s/g, '');\n  let start = 0;\n  let end = s.length % 8 || 8;\n  const chunks = [];\n\n  while (end <= s.length) {\n    chunks.push(parseInt(s.slice(start, end), 2));\n    start = end;\n    end += 8;\n  }\n\n  return Buffer.from(chunks);\n};\n\nexports.arrayEqual = function arrayEqual(a, b) {\n  if (a == null && b == null) {\n    return true;\n  }\n\n  if (a == null || b == null) {\n    return false;\n  }\n\n  return a.length === b.length && a.every((elem, i) => elem === b[i]);\n};\n\nexports.bufferEqual = function bufferEqual(a, b) {\n  if (a == null && b == null) {\n    return true;\n  }\n\n  if (a == null || b == null) {\n    return false;\n  }\n\n  if (!(Buffer.isBuffer(a) && Buffer.isBuffer(b) && a.length === b.length)) {\n    return false;\n  }\n\n  const len = a.length;\n  let ret = true;\n  let i;\n  let j;\n\n  for (i = j = 0; j < len; i = ++j) {\n    const byte = a[i];\n    ret = ret && b[i] === byte;\n  }\n\n  return !!ret;\n};\n\nexports.bufferToBignumber = function bufferToBignumber(buf) {\n  return new BigNumber(buf.toString('hex'), 16);\n};\n\nexports.bufferToBigInt = function bufferToBigInt(buf) {\n  return BigInt('0x' + buf.toString('hex'));\n};\n\nexports.cborValueToString = function cborValueToString(val, float_bytes = -1) {\n  switch (typeof val) {\n    case 'symbol':\n      switch (val) {\n        case SYMS.NULL:\n          return 'null';\n\n        case SYMS.UNDEFINED:\n          return 'undefined';\n\n        case SYMS.BREAK:\n          return 'BREAK';\n      } // impossible in node 10\n\n      /* istanbul ignore if */\n\n\n      if (val.description) {\n        return val.description;\n      } // on node10, Symbol doesn't have description.  Parse it out of the\n      // toString value, which looks like `Symbol(foo)`.\n\n\n      const s = val.toString();\n      const m = s.match(/^Symbol\\((.*)\\)/);\n      /* istanbul ignore if */\n\n      if (m && m[1]) {\n        // impossible in node 12+\n\n        /* istanbul ignore next */\n        return m[1];\n      }\n\n      return 'Symbol';\n\n    case 'string':\n      return JSON.stringify(val);\n\n    case 'bigint':\n      return val.toString();\n\n    case 'number':\n      if (float_bytes > 0) {\n        return util.inspect(val) + '_' + float_bytes;\n      }\n\n      return util.inspect(val);\n  }\n\n  if (Buffer.isBuffer(val)) {\n    const hex = val.toString('hex');\n    return float_bytes === -Infinity ? hex : \"h'\".concat(hex, \"'\");\n  }\n\n  if (BigNumber.isBigNumber(val)) {\n    return val.toString();\n  }\n\n  return util.inspect(val);\n};\n\nexports.guessEncoding = function guessEncoding(input, encoding) {\n  if (typeof input == 'string') {\n    return new NoFilter(input, encoding != null ? encoding : 'hex');\n  } else if (Buffer.isBuffer(input)) {\n    return new NoFilter(input);\n  } else if (ArrayBuffer.isView(input)) {\n    return new NoFilter(Buffer.from(input.buffer, input.byteOffset, input.byteLength));\n  } else if (input instanceof ArrayBuffer) {\n    return new NoFilter(Buffer.from(input));\n  } else if (input instanceof stream.Readable) {\n    return input;\n  }\n\n  throw new Error('Unknown input type');\n};","map":null,"metadata":{},"sourceType":"script"}