{"ast":null,"code":"import _slicedToArray from \"/home/ubuntu/TFG_FL/client/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\n\nasync function* _batch(size, iterable) {\n  let dataBatch = [];\n\n  for await (const data of iterable) {\n    dataBatch.push(data);\n\n    if (dataBatch.length === size) {\n      yield dataBatch;\n      dataBatch = [];\n    }\n  }\n\n  if (dataBatch.length > 0) {\n    yield dataBatch;\n  }\n}\n\nfunction* _syncBatch(size, iterable) {\n  let dataBatch = [];\n\n  for (const data of iterable) {\n    dataBatch.push(data);\n\n    if (dataBatch.length === size) {\n      yield dataBatch;\n      dataBatch = [];\n    }\n  }\n\n  if (dataBatch.length > 0) {\n    yield dataBatch;\n  }\n}\n\nfunction batch(size, iterable) {\n  if (iterable === undefined) {\n    return curriedIterable => batch(size, curriedIterable);\n  }\n\n  if (iterable[Symbol.asyncIterator]) {\n    return _batch(size, iterable);\n  }\n\n  return _syncBatch(size, iterable);\n}\n\nfunction getIterator(iterable) {\n  if (typeof iterable.next === 'function') {\n    return iterable;\n  }\n\n  if (typeof iterable[Symbol.iterator] === 'function') {\n    return iterable[Symbol.iterator]();\n  }\n\n  if (typeof iterable[Symbol.asyncIterator] === 'function') {\n    return iterable[Symbol.asyncIterator]();\n  }\n\n  throw new TypeError('\"values\" does not to conform to any of the iterator or iterable protocols');\n}\n\nfunction defer() {\n  let reject;\n  let resolve;\n  const promise = new Promise((resolveFunc, rejectFunc) => {\n    resolve = resolveFunc;\n    reject = rejectFunc;\n  });\n  return {\n    promise,\n    reject,\n    resolve\n  };\n} /// <reference lib=\"esnext.asynciterable\" />\n\n\nfunction _buffer(size, iterable) {\n  const iterator = getIterator(iterable);\n  const resultQueue = [];\n  const readQueue = [];\n  let reading = false;\n  let ended = false;\n\n  function fulfillReadQueue() {\n    while (readQueue.length > 0 && resultQueue.length > 0) {\n      const readDeferred = readQueue.shift();\n\n      const _resultQueue$shift = resultQueue.shift(),\n            error = _resultQueue$shift.error,\n            value = _resultQueue$shift.value;\n\n      if (error) {\n        readDeferred.reject(error);\n      } else {\n        readDeferred.resolve({\n          done: false,\n          value\n        });\n      }\n    }\n\n    while (readQueue.length > 0 && ended) {\n      const _readQueue$shift = readQueue.shift(),\n            resolve = _readQueue$shift.resolve;\n\n      resolve({\n        done: true,\n        value: undefined\n      });\n    }\n  }\n\n  async function fillQueue() {\n    if (ended) {\n      return;\n    }\n\n    if (reading) {\n      return;\n    }\n\n    if (resultQueue.length >= size) {\n      return;\n    }\n\n    reading = true;\n\n    try {\n      const _ref = await iterator.next(),\n            done = _ref.done,\n            value = _ref.value;\n\n      if (done) {\n        ended = true;\n      } else {\n        resultQueue.push({\n          value\n        });\n      }\n    } catch (error) {\n      ended = true;\n      resultQueue.push({\n        error\n      });\n    }\n\n    fulfillReadQueue();\n    reading = false;\n    fillQueue();\n  }\n\n  async function next() {\n    if (resultQueue.length > 0) {\n      const _resultQueue$shift2 = resultQueue.shift(),\n            error = _resultQueue$shift2.error,\n            value = _resultQueue$shift2.value;\n\n      if (error) {\n        throw error;\n      }\n\n      fillQueue();\n      return {\n        done: false,\n        value\n      };\n    }\n\n    if (ended) {\n      return {\n        done: true,\n        value: undefined\n      }; // stupid ts\n    }\n\n    const deferred = defer();\n    readQueue.push(deferred);\n    fillQueue();\n    return deferred.promise;\n  }\n\n  const asyncIterableIterator = {\n    next,\n    [Symbol.asyncIterator]: () => asyncIterableIterator\n  };\n  return asyncIterableIterator;\n}\n\nfunction* syncBuffer(size, iterable) {\n  const valueQueue = [];\n  let e;\n\n  try {\n    for (const value of iterable) {\n      valueQueue.push(value);\n\n      if (valueQueue.length <= size) {\n        continue;\n      }\n\n      yield valueQueue.shift();\n    }\n  } catch (error) {\n    e = error;\n  }\n\n  for (const value of valueQueue) {\n    yield value;\n  }\n\n  if (e) {\n    throw e;\n  }\n}\n\nfunction buffer(size, iterable) {\n  if (iterable === undefined) {\n    return curriedIterable => buffer(size, curriedIterable);\n  }\n\n  if (size === 0) {\n    return iterable;\n  }\n\n  if (iterable[Symbol.asyncIterator]) {\n    return _buffer(size, iterable);\n  }\n\n  return syncBuffer(size, iterable);\n}\n\nasync function _collect(iterable) {\n  const values = [];\n\n  for await (const value of iterable) {\n    values.push(value);\n  }\n\n  return values;\n}\n\nfunction collect(iterable) {\n  if (iterable[Symbol.asyncIterator]) {\n    return _collect(iterable);\n  }\n\n  return Array.from(iterable);\n}\n\nasync function* _concat(iterables) {\n  for await (const iterable of iterables) {\n    yield* iterable;\n  }\n}\n\nfunction* _syncConcat(iterables) {\n  for (const iterable of iterables) {\n    yield* iterable;\n  }\n}\n\nfunction concat(...iterables) {\n  const hasAnyAsync = iterables.find(itr => itr[Symbol.asyncIterator] !== undefined);\n\n  if (hasAnyAsync) {\n    return _concat(iterables);\n  } else {\n    return _syncConcat(iterables);\n  }\n}\n\nasync function _consume(iterable) {\n  for await (const val of iterable) {// do nothing\n  }\n}\n\nfunction consume(iterable) {\n  if (iterable[Symbol.asyncIterator]) {\n    return _consume(iterable);\n  }\n\n  for (const val of iterable) {// do nothing\n  }\n}\n\nasync function* _filter(filterFunc, iterable) {\n  for await (const data of iterable) {\n    if (await filterFunc(data)) {\n      yield data;\n    }\n  }\n}\n\nfunction filter(filterFunc, iterable) {\n  if (iterable === undefined) {\n    return curriedIterable => _filter(filterFunc, curriedIterable);\n  }\n\n  return _filter(filterFunc, iterable);\n}\n\nasync function* flatten(iterable) {\n  for await (const maybeItr of iterable) {\n    if (maybeItr && typeof maybeItr !== 'string' && (maybeItr[Symbol.iterator] || maybeItr[Symbol.asyncIterator])) {\n      yield* flatten(maybeItr);\n    } else {\n      yield maybeItr;\n    }\n  }\n}\n\nasync function* _map(func, iterable) {\n  for await (const val of iterable) {\n    yield await func(val);\n  }\n}\n\nfunction map(func, iterable) {\n  if (iterable === undefined) {\n    return curriedIterable => _map(func, curriedIterable);\n  }\n\n  return _map(func, iterable);\n}\n\nfunction flatMap(func, iterable) {\n  if (iterable === undefined) {\n    return curriedIterable => flatMap(func, curriedIterable);\n  }\n\n  return filter(i => i !== undefined && i !== null, flatten(map(func, iterable)));\n}\n\nfunction _flatTransform(concurrency, func, iterable) {\n  const iterator = getIterator(iterable);\n  const resultQueue = [];\n  const readQueue = [];\n  let ended = false;\n  let reading = false;\n  let inflightCount = 0;\n  let lastError = null;\n\n  function fulfillReadQueue() {\n    while (readQueue.length > 0 && resultQueue.length > 0) {\n      const _readQueue$shift2 = readQueue.shift(),\n            resolve = _readQueue$shift2.resolve;\n\n      const value = resultQueue.shift();\n      resolve({\n        done: false,\n        value\n      });\n    }\n\n    while (readQueue.length > 0 && inflightCount === 0 && ended) {\n      const _readQueue$shift3 = readQueue.shift(),\n            resolve = _readQueue$shift3.resolve,\n            reject = _readQueue$shift3.reject;\n\n      if (lastError) {\n        reject(lastError);\n        lastError = null;\n      } else {\n        resolve({\n          done: true,\n          value: undefined\n        });\n      }\n    }\n  }\n\n  async function fillQueue() {\n    if (ended) {\n      fulfillReadQueue();\n      return;\n    }\n\n    if (reading) {\n      return;\n    }\n\n    if (inflightCount + resultQueue.length >= concurrency) {\n      return;\n    }\n\n    reading = true;\n    inflightCount++;\n\n    try {\n      const _ref2 = await iterator.next(),\n            done = _ref2.done,\n            value = _ref2.value;\n\n      if (done) {\n        ended = true;\n        inflightCount--;\n        fulfillReadQueue();\n      } else {\n        mapAndQueue(value);\n      }\n    } catch (error) {\n      ended = true;\n      inflightCount--;\n      lastError = error;\n      fulfillReadQueue();\n    }\n\n    reading = false;\n    fillQueue();\n  }\n\n  async function mapAndQueue(itrValue) {\n    try {\n      const value = await func(itrValue);\n\n      if (value && value[Symbol.asyncIterator]) {\n        for await (const asyncVal of value) {\n          resultQueue.push(asyncVal);\n        }\n      } else {\n        resultQueue.push(value);\n      }\n    } catch (error) {\n      ended = true;\n      lastError = error;\n    }\n\n    inflightCount--;\n    fulfillReadQueue();\n    fillQueue();\n  }\n\n  async function next() {\n    if (resultQueue.length === 0) {\n      const deferred = defer();\n      readQueue.push(deferred);\n      fillQueue();\n      return deferred.promise;\n    }\n\n    const value = resultQueue.shift();\n    fillQueue();\n    return {\n      done: false,\n      value\n    };\n  }\n\n  const asyncIterableIterator = {\n    next,\n    [Symbol.asyncIterator]: () => asyncIterableIterator\n  };\n  return asyncIterableIterator;\n}\n\nfunction flatTransform(concurrency, func, iterable) {\n  if (func === undefined) {\n    return (curriedFunc, curriedIterable) => curriedIterable ? flatTransform(concurrency, curriedFunc, curriedIterable) : flatTransform(concurrency, curriedFunc);\n  }\n\n  if (iterable === undefined) {\n    return curriedIterable => flatTransform(concurrency, func, curriedIterable);\n  }\n\n  return filter(i => i !== undefined && i !== null, flatten(_flatTransform(concurrency, func, iterable)));\n}\n\nasync function onceReadable(stream) {\n  return new Promise(resolve => {\n    stream.once('readable', () => {\n      resolve();\n    });\n  });\n}\n\nasync function* _fromStream(stream) {\n  while (true) {\n    const data = stream.read();\n\n    if (data !== null) {\n      yield data;\n      continue;\n    }\n\n    if (stream._readableState.ended) {\n      break;\n    }\n\n    await onceReadable(stream);\n  }\n}\n\nfunction fromStream(stream) {\n  if (typeof stream[Symbol.asyncIterator] === 'function') {\n    return stream;\n  }\n\n  return _fromStream(stream);\n}\n\nasync function* merge(...iterables) {\n  const sources = new Set(iterables.map(getIterator));\n\n  while (sources.size > 0) {\n    for (const iterator of sources) {\n      const nextVal = await iterator.next();\n\n      if (nextVal.done) {\n        sources.delete(iterator);\n      } else {\n        yield nextVal.value;\n      }\n    }\n  }\n}\n\nfunction pipeline(firstFn, ...fns) {\n  let previousFn = firstFn();\n\n  for (const func of fns) {\n    previousFn = func(previousFn);\n  }\n\n  return previousFn;\n}\n\nasync function* _parallelMap(concurrency, func, iterable) {\n  let transformError = null;\n\n  const wrapFunc = value => ({\n    value: func(value)\n  });\n\n  const stopOnError = async function* (source) {\n    for await (const value of source) {\n      if (transformError) {\n        return;\n      }\n\n      yield value;\n    }\n  };\n\n  const output = pipeline(() => iterable, buffer(1), stopOnError, map(wrapFunc), buffer(concurrency - 1));\n  const itr = getIterator(output);\n\n  while (true) {\n    const _ref3 = await itr.next(),\n          value = _ref3.value,\n          done = _ref3.done;\n\n    if (done) {\n      break;\n    }\n\n    try {\n      const val = await value.value;\n\n      if (!transformError) {\n        yield val;\n      }\n    } catch (error) {\n      transformError = error;\n    }\n  }\n\n  if (transformError) {\n    throw transformError;\n  }\n}\n\nfunction parallelMap(concurrency, func, iterable) {\n  if (func === undefined) {\n    return (curriedFunc, curriedIterable) => parallelMap(concurrency, curriedFunc, curriedIterable);\n  }\n\n  if (iterable === undefined) {\n    return curriedIterable => parallelMap(concurrency, func, curriedIterable);\n  }\n\n  if (concurrency === 1) {\n    return map(func, iterable);\n  }\n\n  return _parallelMap(concurrency, func, iterable);\n}\n\nfunction parallelFlatMap(concurrency, func, iterable) {\n  if (func === undefined) {\n    return (curriedFunc, curriedIterable) => curriedIterable ? parallelFlatMap(concurrency, curriedFunc, curriedIterable) : parallelFlatMap(concurrency, curriedFunc);\n  }\n\n  if (iterable === undefined) {\n    return curriedIterable => parallelFlatMap(concurrency, func, curriedIterable);\n  }\n\n  return filter(i => i !== undefined && i !== null, flatten(parallelMap(concurrency, func, iterable)));\n} /// <reference lib=\"esnext.asynciterable\" />\n\n\nasync function* parallelMerge(...iterables) {\n  const inputs = iterables.map(getIterator);\n  const concurrentWork = new Set();\n  const values = new Map();\n  let lastError = null;\n  let errCb = null;\n  let valueCb = null;\n\n  const notifyError = err => {\n    lastError = err;\n\n    if (errCb) {\n      errCb(err);\n    }\n  };\n\n  const notifyDone = value => {\n    if (valueCb) {\n      valueCb(value);\n    }\n  };\n\n  const waitForQueue = () => new Promise((resolve, reject) => {\n    if (lastError) {\n      reject(lastError);\n    }\n\n    if (values.size > 0) {\n      return resolve();\n    }\n\n    valueCb = resolve;\n    errCb = reject;\n  });\n\n  const queueNext = input => {\n    const nextVal = Promise.resolve(input.next()).then(async ({\n      done,\n      value\n    }) => {\n      if (!done) {\n        values.set(input, value);\n      }\n\n      concurrentWork.delete(nextVal);\n    });\n    concurrentWork.add(nextVal);\n    nextVal.then(notifyDone, notifyError);\n  };\n\n  for (const input of inputs) {\n    queueNext(input);\n  }\n\n  while (true) {\n    // We technically don't have to check `values.size` as the for loop should have emptied it\n    // However I haven't yet found specs verifying that behavior, only tests\n    // the guard in waitForQueue() checking for values is in place for the same reason\n    if (concurrentWork.size === 0 && values.size === 0) {\n      return;\n    }\n\n    await waitForQueue();\n\n    for (const _ref4 of values) {\n      var _ref5 = _slicedToArray(_ref4, 2);\n\n      const input = _ref5[0];\n      const value = _ref5[1];\n      values.delete(input);\n      yield value;\n      queueNext(input);\n    }\n  }\n}\n\nasync function _reduce(func, start, iterable) {\n  let value = start;\n\n  for await (const nextItem of iterable) {\n    value = await func(value, nextItem);\n  }\n\n  return value;\n}\n\nfunction reduce(func, start, iterable) {\n  if (start === undefined) {\n    return (curriedStart, curriedIterable) => curriedIterable ? _reduce(func, curriedStart, curriedIterable) : reduce(func, curriedStart);\n  }\n\n  if (iterable === undefined) {\n    return curriedIterable => reduce(func, start, curriedIterable);\n  }\n\n  return _reduce(func, start, iterable);\n}\n\nasync function* _take(count, iterable) {\n  let taken = 0;\n\n  for await (const val of iterable) {\n    yield await val;\n    taken++;\n\n    if (taken >= count) {\n      break;\n    }\n  }\n}\n\nfunction* _syncTake(count, iterable) {\n  let taken = 0;\n\n  for (const val of iterable) {\n    yield val;\n    taken++;\n\n    if (taken >= count) {\n      break;\n    }\n  }\n}\n\nfunction take(count, iterable) {\n  if (iterable === undefined) {\n    return curriedIterable => take(count, curriedIterable);\n  }\n\n  if (iterable[Symbol.asyncIterator]) {\n    return _take(count, iterable);\n  }\n\n  return _syncTake(count, iterable);\n}\n\nasync function* _asyncTap(func, iterable) {\n  for await (const val of iterable) {\n    await func(val);\n    yield val;\n  }\n}\n\nfunction tap(func, iterable) {\n  if (iterable === undefined) {\n    return curriedIterable => _asyncTap(func, curriedIterable);\n  }\n\n  return _asyncTap(func, iterable);\n}\n\nfunction addTime(a, b) {\n  let seconds = a[0] + b[0];\n  let nanoseconds = a[1] + b[1];\n\n  if (nanoseconds >= 1000000000) {\n    const remainder = nanoseconds % 1000000000;\n    seconds += (nanoseconds - remainder) / 1000000000;\n    nanoseconds = remainder;\n  }\n\n  return [seconds, nanoseconds];\n}\n\nasync function* _asyncTime(config, iterable) {\n  const itr = iterable[Symbol.asyncIterator]();\n  let total = [0, 0];\n\n  while (true) {\n    const start = process.hrtime();\n\n    const _ref6 = await itr.next(),\n          value = _ref6.value,\n          done = _ref6.done;\n\n    const delta = process.hrtime(start);\n    total = addTime(total, delta);\n\n    if (config.progress) {\n      config.progress(delta, total);\n    }\n\n    if (done) {\n      if (config.total) {\n        config.total(total);\n      }\n\n      return value;\n    }\n\n    yield value;\n  }\n}\n\nfunction* _syncTime(config, iterable) {\n  const itr = iterable[Symbol.iterator]();\n  let total = [0, 0];\n\n  while (true) {\n    const start = process.hrtime();\n\n    const _itr$next = itr.next(),\n          value = _itr$next.value,\n          done = _itr$next.done;\n\n    const delta = process.hrtime(start);\n    total = addTime(total, delta);\n\n    if (config.progress) {\n      config.progress(delta, total);\n    }\n\n    if (done) {\n      if (config.total) {\n        config.total(total);\n      }\n\n      return value;\n    }\n\n    yield value;\n  }\n}\n\nfunction time(config = {}, iterable) {\n  if (iterable === undefined) {\n    return curriedIterable => time(config, curriedIterable);\n  }\n\n  if (iterable[Symbol.asyncIterator] !== undefined) {\n    return _asyncTime(config, iterable);\n  } else {\n    return _syncTime(config, iterable);\n  }\n}\n\nfunction _transform(concurrency, func, iterable) {\n  const iterator = getIterator(iterable);\n  const resultQueue = [];\n  const readQueue = [];\n  let ended = false;\n  let reading = false;\n  let inflightCount = 0;\n  let lastError = null;\n\n  function fulfillReadQueue() {\n    while (readQueue.length > 0 && resultQueue.length > 0) {\n      const _readQueue$shift4 = readQueue.shift(),\n            resolve = _readQueue$shift4.resolve;\n\n      const value = resultQueue.shift();\n      resolve({\n        done: false,\n        value\n      });\n    }\n\n    while (readQueue.length > 0 && inflightCount === 0 && ended) {\n      const _readQueue$shift5 = readQueue.shift(),\n            resolve = _readQueue$shift5.resolve,\n            reject = _readQueue$shift5.reject;\n\n      if (lastError) {\n        reject(lastError);\n        lastError = null;\n      } else {\n        resolve({\n          done: true,\n          value: undefined\n        });\n      }\n    }\n  }\n\n  async function fillQueue() {\n    if (ended) {\n      fulfillReadQueue();\n      return;\n    }\n\n    if (reading) {\n      return;\n    }\n\n    if (inflightCount + resultQueue.length >= concurrency) {\n      return;\n    }\n\n    reading = true;\n    inflightCount++;\n\n    try {\n      const _ref7 = await iterator.next(),\n            done = _ref7.done,\n            value = _ref7.value;\n\n      if (done) {\n        ended = true;\n        inflightCount--;\n        fulfillReadQueue();\n      } else {\n        mapAndQueue(value);\n      }\n    } catch (error) {\n      ended = true;\n      inflightCount--;\n      lastError = error;\n      fulfillReadQueue();\n    }\n\n    reading = false;\n    fillQueue();\n  }\n\n  async function mapAndQueue(itrValue) {\n    try {\n      const value = await func(itrValue);\n      resultQueue.push(value);\n    } catch (error) {\n      ended = true;\n      lastError = error;\n    }\n\n    inflightCount--;\n    fulfillReadQueue();\n    fillQueue();\n  }\n\n  async function next() {\n    if (resultQueue.length === 0) {\n      const deferred = defer();\n      readQueue.push(deferred);\n      fillQueue();\n      return deferred.promise;\n    }\n\n    const value = resultQueue.shift();\n    fillQueue();\n    return {\n      done: false,\n      value\n    };\n  }\n\n  const asyncIterableIterator = {\n    next,\n    [Symbol.asyncIterator]: () => asyncIterableIterator\n  };\n  return asyncIterableIterator;\n}\n\nfunction transform(concurrency, func, iterable) {\n  if (func === undefined) {\n    return (curriedFunc, curriedIterable) => curriedIterable ? transform(concurrency, curriedFunc, curriedIterable) : transform(concurrency, curriedFunc);\n  }\n\n  if (iterable === undefined) {\n    return curriedIterable => transform(concurrency, func, curriedIterable);\n  }\n\n  return _transform(concurrency, func, iterable);\n}\n\nasync function _writeToStream(stream, iterable) {\n  let lastError = null;\n  let errCb = null;\n  let drainCb = null;\n\n  const notifyError = err => {\n    lastError = err;\n\n    if (errCb) {\n      errCb(err);\n    }\n  };\n\n  const notifyDrain = () => {\n    if (drainCb) {\n      drainCb();\n    }\n  };\n\n  const cleanup = () => {\n    stream.removeListener('error', notifyError);\n    stream.removeListener('drain', notifyDrain);\n  };\n\n  stream.once('error', notifyError);\n\n  const waitForDrain = () => new Promise((resolve, reject) => {\n    if (lastError) {\n      return reject(lastError);\n    }\n\n    stream.once('drain', notifyDrain);\n    drainCb = resolve;\n    errCb = reject;\n  });\n\n  for await (const value of iterable) {\n    if (stream.write(value) === false) {\n      await waitForDrain();\n    }\n\n    if (lastError) {\n      break;\n    }\n  }\n\n  cleanup();\n\n  if (lastError) {\n    throw lastError;\n  }\n}\n\nfunction writeToStream(stream, iterable) {\n  if (iterable === undefined) {\n    return curriedIterable => _writeToStream(stream, curriedIterable);\n  }\n\n  return _writeToStream(stream, iterable);\n}\n\nexport { batch, buffer, collect, concat, consume, filter, flatMap, flatTransform, flatten, fromStream, getIterator, map, merge, parallelFlatMap, parallelMap, parallelMerge, pipeline, reduce, take, tap, time, transform, writeToStream };","map":null,"metadata":{},"sourceType":"module"}