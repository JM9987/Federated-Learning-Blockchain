{"ast":null,"code":"/* eslint max-nested-callbacks: [\"error\", 8] */\n'use strict';\n\nvar _slicedToArray = require(\"/home/ubuntu/Codigo_Javier/client/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nconst CID = require('cids');\n\nconst errCode = require('err-code');\n\nconst dagCborLinks = require('dag-cbor-links');\n\nconst debug = require('debug'); // const parallelBatch = require('it-parallel-batch')\n\n\nconst first = require('it-first');\n\nconst all = require('it-all');\n\nconst cbor = require('cbor');\n\nconst multibase = require('multibase');\n\nconst multicodec = require('multicodec'); // arbitrary limit to the number of concurrent dag operations\n// const WALK_DAG_CONCURRENCY_LIMIT = 300\n// const IS_PINNED_WITH_TYPE_CONCURRENCY_LIMIT = 300\n// const PIN_DS_KEY = new Key('/local/pins')\n\n\nfunction invalidPinTypeErr(type) {\n  const errMsg = \"Invalid type '\".concat(type, \"', must be one of {direct, indirect, recursive, all}\");\n  return errCode(new Error(errMsg), 'ERR_INVALID_PIN_TYPE');\n}\n\nconst encoder = multibase.encoding('base32upper');\n\nfunction cidToKey(cid) {\n  return \"/\".concat(encoder.encode(cid.multihash));\n}\n\nfunction keyToMultihash(key) {\n  return encoder.decode(key.toString().slice(1));\n}\n/**\n * @typedef {'direct'|'recursive'|'indirect'} PinType\n * @typedef {PinType|'all'} PinQueryType\n */\n\n\nconst PinTypes = {\n  /** @type {'direct'} */\n  direct: 'direct',\n\n  /** @type {'recursive'} */\n  recursive: 'recursive',\n\n  /** @type {'indirect'} */\n  indirect: 'indirect',\n\n  /** @type {'all'} */\n  all: 'all'\n};\n\nclass PinManager {\n  /**\n   * @param {Object} config\n   * @param {import('.').Repo} config.repo\n   * @param {import('.').DagReader} config.dagReader\n   */\n  constructor({\n    repo,\n    dagReader\n  }) {\n    this.repo = repo;\n    this.dag = dagReader;\n    this.log = debug('ipfs:pin');\n    this.directPins = new Set();\n    this.recursivePins = new Set();\n  }\n  /**\n   * @private\n   * @param {CID} cid\n   * @param {Object} options\n   * @param {boolean} [options.preload]\n   */\n\n\n  async *_walkDag(cid, {\n    preload = false\n  }) {\n    const _ref = await this.dag.get(cid, {\n      preload\n    }),\n          node = _ref.value;\n\n    if (cid.codec === 'dag-pb') {\n      for (const link of node.Links) {\n        yield link.Hash;\n        yield* this._walkDag(link.Hash, {\n          preload\n        });\n      }\n    } else if (cid.codec === 'dag-cbor') {\n      for (const _ref2 of dagCborLinks(node)) {\n        var _ref3 = _slicedToArray(_ref2, 2);\n\n        const childCid = _ref3[1];\n        yield childCid;\n        yield* this._walkDag(childCid, {\n          preload\n        });\n      }\n    }\n  }\n  /**\n   * @param {CID} cid\n   * @param {PinOptions & AbortOptions} [options]\n   * @returns {Promise<void>}\n   */\n\n\n  async pinDirectly(cid, options = {}) {\n    await this.dag.get(cid, options);\n    const pin = {\n      depth: 0\n    };\n\n    if (cid.version !== 0) {\n      pin.version = cid.version;\n    }\n\n    if (cid.codec !== 'dag-pb') {\n      pin.codec = multicodec.getNumber(cid.codec);\n    }\n\n    if (options.metadata) {\n      pin.metadata = options.metadata;\n    }\n\n    return this.repo.pins.put(cidToKey(cid), cbor.encode(pin));\n  }\n  /**\n   * @param {CID} cid\n   * @param {AbortOptions} [options]\n   * @returns {Promise<void>}\n   */\n  // eslint-disable-next-line require-await\n\n\n  async unpin(cid, options) {\n    return this.repo.pins.delete(cidToKey(cid));\n  }\n  /**\n   * @param {CID} cid\n   * @param {PreloadOptions & PinOptions & AbortOptions} [options]\n   * @returns {Promise<void>}\n   */\n\n\n  async pinRecursively(cid, options = {}) {\n    await this.fetchCompleteDag(cid, options);\n    const pin = {\n      depth: Infinity\n    };\n\n    if (cid.version !== 0) {\n      pin.version = cid.version;\n    }\n\n    if (cid.codec !== 'dag-pb') {\n      pin.codec = multicodec.getNumber(cid.codec);\n    }\n\n    if (options.metadata) {\n      pin.metadata = options.metadata;\n    }\n\n    await this.repo.pins.put(cidToKey(cid), cbor.encode(pin));\n  }\n  /**\n   * @param {AbortOptions} [options]\n   * @returns {AsyncIterable<{ cid: CID, metadata: any }>}\n   */\n\n\n  async *directKeys(options) {\n    for await (const entry of this.repo.pins.query({\n      filters: [entry => {\n        const pin = cbor.decode(entry.value);\n        return pin.depth === 0;\n      }]\n    })) {\n      const pin = cbor.decode(entry.value);\n      const version = pin.version || 0;\n      const codec = pin.codec ? multicodec.getName(pin.codec) : 'dag-pb';\n      const multihash = keyToMultihash(entry.key);\n      yield {\n        cid: new CID(version, codec, multihash),\n        metadata: pin.metadata\n      };\n    }\n  }\n  /**\n   * @param {AbortOptions} [options]\n   * @returns {AsyncIterable<{ cid: CID, metadata: any }>}\n   */\n\n\n  async *recursiveKeys(options) {\n    for await (const entry of this.repo.pins.query({\n      filters: [entry => {\n        const pin = cbor.decode(entry.value);\n        return pin.depth === Infinity;\n      }]\n    })) {\n      const pin = cbor.decode(entry.value);\n      const version = pin.version || 0;\n      const codec = pin.codec ? multicodec.getName(pin.codec) : 'dag-pb';\n      const multihash = keyToMultihash(entry.key);\n      yield {\n        cid: new CID(version, codec, multihash),\n        metadata: pin.metadata\n      };\n    }\n  }\n  /**\n   * @param {Object} options\n   * @param {boolean} [options.preload]\n   */\n\n\n  async *indirectKeys({\n    preload\n  }) {\n    for await (const _ref4 of this.recursiveKeys()) {\n      const cid = _ref4.cid;\n\n      for await (const childCid of this._walkDag(cid, {\n        preload\n      })) {\n        // recursive pins override indirect pins\n        const types = [PinTypes.recursive];\n        const result = await this.isPinnedWithType(childCid, types);\n\n        if (result.pinned) {\n          continue;\n        }\n\n        yield childCid;\n      }\n    }\n  }\n  /**\n   * @param {CID} cid\n   * @param {PinQueryType|PinQueryType[]} types\n   * @param {AbortOptions} [options]\n   */\n\n\n  async isPinnedWithType(cid, types, options) {\n    if (!Array.isArray(types)) {\n      types = [types];\n    }\n\n    const all = types.includes(PinTypes.all);\n    const direct = types.includes(PinTypes.direct);\n    const recursive = types.includes(PinTypes.recursive);\n    const indirect = types.includes(PinTypes.indirect);\n\n    if (recursive || direct || all) {\n      const result = await first(this.repo.pins.query({\n        prefix: cidToKey(cid),\n        filters: [entry => {\n          if (all) {\n            return true;\n          }\n\n          const pin = cbor.decode(entry.value);\n          return types.includes(pin.depth === 0 ? PinTypes.direct : PinTypes.recursive);\n        }],\n        limit: 1\n      }));\n\n      if (result) {\n        const pin = cbor.decode(result.value);\n        return {\n          cid,\n          pinned: true,\n          reason: pin.depth === 0 ? PinTypes.direct : PinTypes.recursive,\n          metadata: pin.metadata\n        };\n      }\n    }\n\n    const self = this;\n\n    async function* findChild(key, source) {\n      for await (const _ref5 of source) {\n        const parentCid = _ref5.cid;\n\n        for await (const childCid of self._walkDag(parentCid, {\n          preload: false\n        })) {\n          if (childCid.equals(key)) {\n            yield parentCid;\n            return;\n          }\n        }\n      }\n    }\n\n    if (all || indirect) {\n      // indirect (default)\n      // check each recursive key to see if multihash is under it\n      const parentCid = await first(findChild(cid, this.recursiveKeys()));\n\n      if (parentCid) {\n        return {\n          cid,\n          pinned: true,\n          reason: PinTypes.indirect,\n          parent: parentCid\n        };\n      }\n    }\n\n    return {\n      cid,\n      pinned: false\n    };\n  }\n  /**\n   * @param {CID} cid\n   * @param {PreloadOptions & AbortOptions} options\n   */\n\n\n  async fetchCompleteDag(cid, options) {\n    await all(this._walkDag(cid, {\n      preload: options.preload\n    }));\n  }\n  /**\n   * Throws an error if the pin type is invalid\n   *\n   * @param {any} type\n   * @returns {type is PinType}\n   */\n\n\n  static checkPinType(type) {\n    if (typeof type !== 'string' || !Object.keys(PinTypes).includes(type)) {\n      throw invalidPinTypeErr(type);\n    }\n\n    return true;\n  }\n\n}\n\nPinManager.PinTypes = PinTypes;\nmodule.exports = PinManager;\n/**\n * @typedef {Object} PinOptions\n * @property {any} [metadata]\n *\n * @typedef {Object} PreloadOptions\n * @property {boolean} [preload]\n *\n * @typedef {import('.').AbortOptions} AbortOptions\n */","map":null,"metadata":{},"sourceType":"script"}