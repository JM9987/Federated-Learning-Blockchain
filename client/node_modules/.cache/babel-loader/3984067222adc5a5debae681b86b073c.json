{"ast":null,"code":"'use strict';\n\nconst errcode = require('err-code');\n\nconst multihash = require('multihashes');\n\nconst crypto = require('./crypto');\n\nconst equals = require('uint8arrays/equals');\n/**\n * @typedef {import(\"./types\").Digest} Digest\n * @typedef {import(\"multihashes\").HashName} HashName\n */\n\n/**\n * Hash the given `bytes` using the algorithm specified by `alg`.\n *\n * @param {Uint8Array} bytes - The value to hash.\n * @param {HashName} alg - The algorithm to use eg 'sha1'\n * @param {number} [length] - Optionally trim the result to this length.\n * @returns {Promise<Uint8Array>}\n */\n\n\nasync function Multihashing(bytes, alg, length) {\n  const digest = await Multihashing.digest(bytes, alg, length);\n  return multihash.encode(digest, alg, length);\n}\n/**\n * Expose multihash itself, to avoid silly double requires.\n */\n\n\nMultihashing.multihash = multihash;\n/**\n * @param {Uint8Array} bytes - The value to hash.\n * @param {HashName} alg - The algorithm to use eg 'sha1'\n * @param {number} [length] - Optionally trim the result to this length.\n * @returns {Promise<Uint8Array>}\n */\n\nMultihashing.digest = async (bytes, alg, length) => {\n  const hash = Multihashing.createHash(alg);\n  const digest = await hash(bytes);\n  return length ? digest.slice(0, length) : digest;\n};\n/**\n * Creates a function that hashes with the given algorithm\n *\n * @param {HashName} alg - The algorithm to use eg 'sha1'\n * @returns {Digest} - The hash function corresponding to `alg`\n */\n\n\nMultihashing.createHash = function (alg) {\n  if (!alg) {\n    const e = errcode(new Error('hash algorithm must be specified'), 'ERR_HASH_ALGORITHM_NOT_SPECIFIED');\n    throw e;\n  }\n\n  const code = multihash.coerceCode(alg);\n\n  if (!Multihashing.functions[code]) {\n    throw errcode(new Error(\"multihash function '\".concat(alg, \"' not yet supported\")), 'ERR_HASH_ALGORITHM_NOT_SUPPORTED');\n  }\n\n  return Multihashing.functions[code];\n};\n/**\n * Mapping of multihash codes to their hashing functions.\n *\n * @type {Record<number, Digest>}\n */\n// @ts-ignore - most of those functions aren't typed\n\n\nMultihashing.functions = {\n  // identity\n  0x00: crypto.identity,\n  // sha1\n  0x11: crypto.sha1,\n  // sha2-256\n  0x12: crypto.sha2256,\n  // sha2-512\n  0x13: crypto.sha2512,\n  // sha3-512\n  0x14: crypto.sha3512,\n  // sha3-384\n  0x15: crypto.sha3384,\n  // sha3-256\n  0x16: crypto.sha3256,\n  // sha3-224\n  0x17: crypto.sha3224,\n  // shake-128\n  0x18: crypto.shake128,\n  // shake-256\n  0x19: crypto.shake256,\n  // keccak-224\n  0x1A: crypto.keccak224,\n  // keccak-256\n  0x1B: crypto.keccak256,\n  // keccak-384\n  0x1C: crypto.keccak384,\n  // keccak-512\n  0x1D: crypto.keccak512,\n  // murmur3-128\n  0x22: crypto.murmur3128,\n  // murmur3-32\n  0x23: crypto.murmur332,\n  // dbl-sha2-256\n  0x56: crypto.dblSha2256\n}; // add blake functions\n\ncrypto.addBlake(Multihashing.functions);\n/**\n * @param {Uint8Array} bytes\n * @param {Uint8Array} hash\n * @returns {Promise<boolean>}\n */\n\nMultihashing.validate = async (bytes, hash) => {\n  const newHash = await Multihashing(bytes, multihash.decode(hash).name);\n  return equals(hash, newHash);\n};\n\nmodule.exports = Multihashing;","map":null,"metadata":{},"sourceType":"script"}