{"ast":null,"code":"'use strict';\n\nconst createLock = require('./utils/create-lock');\n\nconst isIpfs = require('is-ipfs');\n/**\n * @typedef {Object} MFS\n * @property {ReturnType<typeof import('./stat')>} stat\n * @property {ReturnType<typeof import('./chmod')>} chmod\n * @property {ReturnType<typeof import('./cp')>} cp\n * @property {ReturnType<typeof import('./flush')>} flush\n * @property {ReturnType<typeof import('./mkdir')>} mkdir\n * @property {ReturnType<typeof import('./mv')>} mv\n * @property {ReturnType<typeof import('./rm')>} rm\n * @property {ReturnType<typeof import('./touch')>} touch\n * @property {ReturnType<typeof import('./write')>} write\n * @property {ReturnType<typeof import('./read')>} read\n * @property {ReturnType<typeof import('./ls')>} ls\n */\n// These operations are read-locked at the function level and will execute simultaneously\n\n\nconst readOperations = {\n  stat: require('./stat')\n}; // These operations are locked at the function level and will execute in series\n\nconst writeOperations = {\n  chmod: require('./chmod'),\n  cp: require('./cp'),\n  flush: require('./flush'),\n  mkdir: require('./mkdir'),\n  mv: require('./mv'),\n  rm: require('./rm'),\n  touch: require('./touch')\n}; // These operations are asynchronous and manage their own locking\n\nconst unwrappedOperations = {\n  write: require('./write'),\n  read: require('./read'),\n  ls: require('./ls')\n};\n\nconst wrap = ({\n  options,\n  mfs,\n  operations,\n  lock\n}) => {\n  Object.keys(operations).forEach(key => {\n    mfs[key] = lock(operations[key](options));\n  });\n};\n\nconst defaultOptions = {\n  repoOwner: true,\n  ipld: null,\n  repo: null\n};\n\nfunction createMfs(options) {\n  const _Object$assign = Object.assign({}, defaultOptions || {}, options),\n        repoOwner = _Object$assign.repoOwner;\n\n  options.repo = {\n    blocks: options.blocks,\n    datastore: options.datastore\n  };\n  const lock = createLock(repoOwner);\n\n  const readLock = operation => {\n    return lock.readLock(operation);\n  };\n\n  const writeLock = operation => {\n    return lock.writeLock(operation);\n  };\n\n  const mfs = {};\n  wrap({\n    options,\n    mfs,\n    operations: readOperations,\n    lock: readLock\n  });\n  wrap({\n    options,\n    mfs,\n    operations: writeOperations,\n    lock: writeLock\n  });\n  Object.keys(unwrappedOperations).forEach(key => {\n    mfs[key] = unwrappedOperations[key](options);\n  });\n  return mfs;\n}\n/**\n * @param {Object} context\n * @param {import('..').IPLD} context.ipld\n * @param {import('..').Block} context.block\n * @param {import('..').BlockService} context.blockService\n * @param {import('..').Repo} context.repo\n * @param {import('..').Preload} context.preload\n * @param {import('..').Options} context.options\n * @returns {MFS}\n */\n\n\nmodule.exports = ({\n  ipld,\n  block,\n  blockService,\n  repo,\n  preload,\n  options: constructorOptions\n}) => {\n  const methods = createMfs({\n    ipld,\n    block,\n    blocks: blockService,\n    datastore: repo.root,\n    repoOwner: constructorOptions.repoOwner\n  });\n\n  const withPreload = fn => (...args) => {\n    const paths = args.filter(arg => isIpfs.ipfsPath(arg) || isIpfs.cid(arg));\n\n    if (paths.length) {\n      const options = args[args.length - 1];\n\n      if (options && options.preload !== false) {\n        paths.forEach(path => preload(path));\n      }\n    }\n\n    return fn(...args);\n  };\n\n  return { ...methods,\n    chmod: methods.chmod,\n    cp: withPreload(methods.cp),\n    mkdir: methods.mkdir,\n    stat: withPreload(methods.stat),\n    rm: methods.rm,\n    read: withPreload(methods.read),\n    touch: methods.touch,\n    write: methods.write,\n    mv: withPreload(methods.mv),\n    flush: methods.flush,\n    ls: withPreload(async function* (...args) {\n      for await (const file of methods.ls(...args)) {\n        yield { ...file,\n          size: file.size || 0\n        };\n      }\n    })\n  };\n};","map":null,"metadata":{},"sourceType":"script"}