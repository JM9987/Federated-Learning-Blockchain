{"ast":null,"code":"/*!\n * hkdf.js - hkdf for bcrypto\n * Copyright (c) 2014-2019, Christopher Jeffrey (MIT License).\n * https://github.com/bcoin-org/bcrypto\n *\n * Resources:\n *   https://en.wikipedia.org/wiki/HKDF\n *   https://tools.ietf.org/html/rfc5869\n */\n'use strict';\n\nconst assert = require('../internal/assert');\n/**\n * HKDF\n */\n\n\nfunction extract(hash, ikm, salt) {\n  assert(hash && typeof hash.id === 'string');\n  if (ikm == null) ikm = Buffer.alloc(0);\n  if (salt == null) salt = Buffer.alloc(hash.size, 0x00);\n  return hash.mac(ikm, salt);\n}\n\nfunction expand(hash, prk, info, len) {\n  if (info == null) info = Buffer.alloc(0);\n  assert(hash && typeof hash.id === 'string');\n  assert(Buffer.isBuffer(prk));\n  assert(Buffer.isBuffer(info));\n  assert(len >>> 0 === len);\n  if (prk.length !== hash.size) throw new RangeError('Invalid PRK length.');\n  const blocks = Math.ceil(len / hash.size);\n  if (blocks > 255) throw new RangeError('Invalid output length.');\n  const out = Buffer.alloc(blocks * hash.size);\n  const ctr = Buffer.from([0]);\n  const mac = hash.hmac();\n  let prev = Buffer.alloc(0);\n  let pos = 0;\n\n  for (let i = 0; i < blocks; i++) {\n    ctr[0] += 1;\n    mac.init(prk);\n    mac.update(prev);\n    mac.update(info);\n    mac.update(ctr);\n    prev = mac.final();\n    pos += prev.copy(out, pos);\n  }\n\n  return out.slice(0, len);\n}\n\nfunction derive(hash, ikm, salt, info, len) {\n  const prk = extract(hash, ikm, salt);\n  return expand(hash, prk, info, len);\n}\n/*\n * Expose\n */\n\n\nexports.native = 0;\nexports.extract = extract;\nexports.expand = expand;\nexports.derive = derive;","map":null,"metadata":{},"sourceType":"script"}