{"ast":null,"code":"'use strict';\n\nconst multiaddr = require('multiaddr');\n\nconst PeerId = require('peer-id');\n\nconst arrayEquals = require('libp2p-utils/src/array-equals');\n\nconst Protobuf = require('./peer-record.proto');\n\nconst _require = require('./consts'),\n      ENVELOPE_DOMAIN_PEER_RECORD = _require.ENVELOPE_DOMAIN_PEER_RECORD,\n      ENVELOPE_PAYLOAD_TYPE_PEER_RECORD = _require.ENVELOPE_PAYLOAD_TYPE_PEER_RECORD;\n/**\n * @typedef {import('peer-id')} PeerId\n * @typedef {import('multiaddr')} Multiaddr\n * @typedef {import('libp2p-interfaces/src/record/types').Record} Record\n */\n\n/**\n * @implements {Record}\n */\n\n\nclass PeerRecord {\n  /**\n   * The PeerRecord is used for distributing peer routing records across the network.\n   * It contains the peer's reachable listen addresses.\n   *\n   * @class\n   * @param {Object} params\n   * @param {PeerId} params.peerId\n   * @param {Multiaddr[]} params.multiaddrs - addresses of the associated peer.\n   * @param {number} [params.seqNumber] - monotonically-increasing sequence counter that's used to order PeerRecords in time.\n   */\n  constructor({\n    peerId,\n    multiaddrs = [],\n    seqNumber = Date.now()\n  }) {\n    this.domain = ENVELOPE_DOMAIN_PEER_RECORD;\n    this.codec = ENVELOPE_PAYLOAD_TYPE_PEER_RECORD;\n    this.peerId = peerId;\n    this.multiaddrs = multiaddrs;\n    this.seqNumber = seqNumber; // Cache\n\n    this._marshal = undefined;\n  }\n  /**\n   * Marshal a record to be used in an envelope.\n   *\n   * @returns {Uint8Array}\n   */\n\n\n  marshal() {\n    if (this._marshal) {\n      return this._marshal;\n    }\n\n    this._marshal = Protobuf.PeerRecord.encode({\n      peer_id: this.peerId.toBytes(),\n      seq: this.seqNumber,\n      addresses: this.multiaddrs.map(m => ({\n        multiaddr: m.bytes\n      }))\n    });\n    return this._marshal;\n  }\n  /**\n   * Returns true if `this` record equals the `other`.\n   *\n   * @param {unknown} other\n   * @returns {boolean}\n   */\n\n\n  equals(other) {\n    if (!(other instanceof PeerRecord)) {\n      return false;\n    } // Validate PeerId\n\n\n    if (!this.peerId.equals(other.peerId)) {\n      return false;\n    } // Validate seqNumber\n\n\n    if (this.seqNumber !== other.seqNumber) {\n      return false;\n    } // Validate multiaddrs\n\n\n    if (!arrayEquals(this.multiaddrs, other.multiaddrs)) {\n      return false;\n    }\n\n    return true;\n  }\n\n}\n/**\n * Unmarshal Peer Record Protobuf.\n *\n * @param {Uint8Array} buf - marshaled peer record.\n * @returns {PeerRecord}\n */\n\n\nPeerRecord.createFromProtobuf = buf => {\n  // Decode\n  const peerRecord = Protobuf.PeerRecord.decode(buf);\n  const peerId = PeerId.createFromBytes(peerRecord.peer_id);\n  const multiaddrs = (peerRecord.addresses || []).map(a => multiaddr(a.multiaddr));\n  const seqNumber = peerRecord.seq;\n  return new PeerRecord({\n    peerId,\n    multiaddrs,\n    seqNumber\n  });\n};\n\nPeerRecord.DOMAIN = ENVELOPE_DOMAIN_PEER_RECORD;\nmodule.exports = PeerRecord;","map":null,"metadata":{},"sourceType":"script"}