{"ast":null,"code":"'use strict';\n\nconst get = require('dlv');\n\nconst mergeOptions = require('merge-options');\n\nconst errCode = require('err-code');\n\nconst PubsubRouters = require('../runtime/libp2p-pubsub-routers-nodejs');\n/**\n * @param {Object} config\n * @param {Repo} config.repo\n * @param {IPFSOptions|undefined} config.options\n * @param {PeerId} config.peerId\n * @param {Multiaddr[]|undefined} config.multiaddrs\n * @param {KeychainConfig|undefined} config.keychainConfig\n * @param {Partial<IPFSConfig>|undefined} config.config\n * @returns {LibP2P}\n */\n\n\nmodule.exports = ({\n  options = {},\n  peerId,\n  multiaddrs = [],\n  repo,\n  keychainConfig = {},\n  config = {}\n}) => {\n  const datastore = repo.datastore,\n        keys = repo.keys;\n  const libp2pOptions = getLibp2pOptions({\n    options,\n    config,\n    datastore,\n    keys,\n    keychainConfig,\n    peerId,\n    multiaddrs\n  });\n\n  if (typeof options.libp2p === 'function') {\n    return options.libp2p({\n      libp2pOptions,\n      options,\n      config,\n      datastore,\n      peerId\n    });\n  } // Required inline to reduce startup time\n\n\n  const Libp2p = require('libp2p');\n\n  return new Libp2p(libp2pOptions);\n};\n/**\n * @param {Object} input\n * @param {IPFSOptions} input.options\n * @param {Partial<IPFSConfig>} input.config\n * @param {Repo['datastore']} input.datastore\n * @param {Repo['keys']} input.keys\n * @param {KeychainConfig} input.keychainConfig\n * @param {PeerId} input.peerId\n * @param {Multiaddr[]} input.multiaddrs\n */\n\n\nfunction getLibp2pOptions({\n  options,\n  config,\n  datastore,\n  keys,\n  keychainConfig,\n  peerId,\n  multiaddrs\n}) {\n  const getPubsubRouter = () => {\n    const router = get(config, 'Pubsub.Router') || 'gossipsub';\n\n    if (!PubsubRouters[router]) {\n      throw errCode(new Error(\"Router unavailable. Configure libp2p.modules.pubsub to use the \".concat(router, \" router.\")), 'ERR_NOT_SUPPORTED');\n    }\n\n    return PubsubRouters[router];\n  };\n\n  const libp2pDefaults = {\n    datastore,\n    peerId: peerId,\n    modules: {}\n  };\n  const libp2pOptions = {\n    modules: {\n      pubsub: getPubsubRouter()\n    },\n    config: {\n      peerDiscovery: {\n        mdns: {\n          enabled: get(options, 'config.Discovery.MDNS.Enabled', get(config, 'Discovery.MDNS.Enabled', true))\n        },\n        webRTCStar: {\n          enabled: get(options, 'config.Discovery.webRTCStar.Enabled', get(config, 'Discovery.webRTCStar.Enabled', true))\n        },\n        bootstrap: {\n          list: get(options, 'config.Bootstrap', get(config, 'Bootstrap', []))\n        }\n      },\n      relay: {\n        enabled: get(options, 'relay.enabled', get(config, 'relay.enabled', true)),\n        hop: {\n          enabled: get(options, 'relay.hop.enabled', get(config, 'relay.hop.enabled', false)),\n          active: get(options, 'relay.hop.active', get(config, 'relay.hop.active', false))\n        }\n      },\n      dht: {\n        enabled: get(config, 'Routing.Type', 'none') !== 'none',\n        clientMode: get(config, 'Routing.Type', 'dht') !== 'dhtserver',\n        kBucketSize: get(options, 'dht.kBucketSize', 20)\n      },\n      pubsub: {\n        enabled: get(options, 'config.Pubsub.Enabled', get(config, 'Pubsub.Enabled', true))\n      },\n      nat: {\n        enabled: get(options, 'nat.enabled', !get(config, 'Swarm.DisableNatPortMap', false)),\n        ttl: get(options, 'nat.ttl', 7200),\n        autoUpdate: get(options, 'nat.autoUpdate', true),\n        gateway: get(options, 'nat.gateway'),\n        externalIp: get(options, 'nat.externalIp'),\n        pmp: {\n          enabled: get(options, 'nat.pmp.enabled', false)\n        }\n      }\n    },\n    addresses: {\n      listen: multiaddrs,\n      announce: get(options, 'addresses.announce', get(config, 'Addresses.Announce', []))\n    },\n    connectionManager: get(options, 'connectionManager', {\n      maxConnections: get(options, 'config.Swarm.ConnMgr.HighWater', get(config, 'Swarm.ConnMgr.HighWater')),\n      minConnections: get(options, 'config.Swarm.ConnMgr.LowWater', get(config, 'Swarm.ConnMgr.LowWater'))\n    }),\n    keychain: {\n      datastore: keys,\n      ...keychainConfig\n    }\n  }; // Required inline to reduce startup time\n  // Note: libp2p-nodejs gets replaced by libp2p-browser when webpacked/browserified\n\n  const getEnvLibp2pOptions = require('../runtime/libp2p-nodejs');\n\n  let constructorOptions = get(options, 'libp2p', {});\n\n  if (typeof constructorOptions === 'function') {\n    constructorOptions = {};\n  } // Merge defaults with Node.js/browser/other environments options and configuration\n\n\n  const libp2pConfig = mergeOptions(libp2pDefaults, getEnvLibp2pOptions(), libp2pOptions, constructorOptions);\n  const bootstrapList = get(libp2pConfig, 'config.peerDiscovery.bootstrap.list', []);\n\n  if (bootstrapList.length > 0) {\n    libp2pConfig.modules.peerDiscovery.push(require('libp2p-bootstrap'));\n  }\n\n  return libp2pConfig;\n}\n/**\n * @typedef {Object} KeychainConfig\n * @property {string} [pass]\n *\n * @typedef {import('.').Repo} Repo\n * @typedef {import('.').Multiaddr} Multiaddr\n * @typedef {import('.').PeerId} PeerId\n * @typedef {import('.').Options} IPFSOptions\n * @typedef {import('libp2p')} LibP2P\n * @typedef {import('libp2p').Libp2pOptions & import('libp2p').constructorOptions} Options\n * @typedef {import('.').IPFSConfig} IPFSConfig\n */","map":null,"metadata":{},"sourceType":"script"}