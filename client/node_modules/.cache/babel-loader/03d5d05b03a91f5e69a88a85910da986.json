{"ast":null,"code":"'use strict';\n\nconst _require = require('bignumber.js'),\n      Big = _require.default;\n\nconst _require2 = require('parse-duration'),\n      parseDuration = _require2.default;\n\nconst errCode = require('err-code');\n\nconst withTimeoutOption = require('ipfs-core-utils/src/with-timeout-option');\n/**\n * @param {LibP2P} libp2p\n * @param {BWOptions} opts\n * @returns {BandwidthInfo}\n */\n\n\nfunction getBandwidthStats(libp2p, opts) {\n  let stats;\n\n  if (!libp2p.metrics) {\n    stats = undefined;\n  } else if (opts.peer) {\n    stats = libp2p.metrics.forPeer(opts.peer);\n  } else if (opts.proto) {\n    stats = libp2p.metrics.forProtocol(opts.proto);\n  } else {\n    stats = libp2p.metrics.global;\n  }\n\n  if (!stats) {\n    return {\n      totalIn: new Big(0),\n      totalOut: new Big(0),\n      rateIn: new Big(0),\n      rateOut: new Big(0)\n    };\n  }\n\n  const _stats = stats,\n        movingAverages = _stats.movingAverages,\n        snapshot = _stats.snapshot;\n  return {\n    totalIn: snapshot.dataReceived,\n    totalOut: snapshot.dataSent,\n    rateIn: new Big(movingAverages.dataReceived[60000].movingAverage() / 60),\n    rateOut: new Big(movingAverages.dataSent[60000].movingAverage() / 60)\n  };\n}\n/**\n * @param {Object} config\n * @param {import('.').NetworkService} config.network\n */\n\n\nmodule.exports = ({\n  network\n}) => {\n  /**\n   * Get IPFS bandwidth information\n   *\n   * @param {BWOptions & AbortOptions} options\n   * @returns {AsyncIterable<BandwidthInfo>}\n   */\n  const bw = async function* (options = {}) {\n    const _ref = await network.use(options),\n          libp2p = _ref.libp2p;\n\n    if (!options.poll) {\n      yield getBandwidthStats(libp2p, options);\n      return;\n    }\n\n    const interval = options.interval || 1000;\n    let ms = -1;\n\n    try {\n      ms = typeof interval === 'string' ? parseDuration(interval) || -1 : interval;\n      if (!ms || ms < 0) throw new Error('invalid duration');\n    } catch (err) {\n      throw errCode(err, 'ERR_INVALID_POLL_INTERVAL');\n    }\n\n    let timeoutId;\n\n    try {\n      while (true) {\n        yield getBandwidthStats(libp2p, options); // eslint-disable-next-line no-loop-func\n\n        await new Promise(resolve => {\n          timeoutId = setTimeout(resolve, ms);\n        });\n      }\n    } finally {\n      clearTimeout(timeoutId);\n    }\n  };\n\n  return withTimeoutOption(bw);\n};\n/**\n * @typedef {Object} BWOptions\n * @property {PeerId} [peer] - Specifies a peer to print bandwidth for\n * @property {string} [proto] - Specifies a protocol to print bandwidth for\n * @property {boolean} [poll] - Is used to yield bandwidth info at an interval\n * @property {number|string} [interval=1000] - The time interval to wait between updating output, if `poll` is `true`.\n *\n * @typedef {Object} BandwidthInfo\n * @property {Big} totalIn\n * @property {Big} totalOut\n * @property {Big} rateIn\n * @property {Big} rateOut\n *\n * @typedef {import('.').LibP2P} LibP2P\n * @typedef {import('.').PeerId} PeerId\n * @typedef {import('.').CID} CID\n * @typedef {import('.').AbortOptions} AbortOptions\n */","map":null,"metadata":{},"sourceType":"script"}