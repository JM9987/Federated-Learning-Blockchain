{"ast":null,"code":"/*eslint-disable*/\n\"use strict\";\n\nvar $protobuf = require(\"protobufjs/minimal\"); // Common aliases\n\n\nvar $Reader = $protobuf.Reader,\n    $Writer = $protobuf.Writer,\n    $util = $protobuf.util; // Exported root namespace\n\nvar $root = $protobuf.roots[\"libp2p-crypto-keys\"] || ($protobuf.roots[\"libp2p-crypto-keys\"] = {});\n/**\n * KeyType enum.\n * @exports KeyType\n * @enum {number}\n * @property {number} RSA=0 RSA value\n * @property {number} Ed25519=1 Ed25519 value\n * @property {number} Secp256k1=2 Secp256k1 value\n */\n\n$root.KeyType = function () {\n  var valuesById = {},\n      values = Object.create(valuesById);\n  values[valuesById[0] = \"RSA\"] = 0;\n  values[valuesById[1] = \"Ed25519\"] = 1;\n  values[valuesById[2] = \"Secp256k1\"] = 2;\n  return values;\n}();\n\n$root.PublicKey = function () {\n  /**\n   * Properties of a PublicKey.\n   * @exports IPublicKey\n   * @interface IPublicKey\n   * @property {KeyType} Type PublicKey Type\n   * @property {Uint8Array} Data PublicKey Data\n   */\n\n  /**\n   * Constructs a new PublicKey.\n   * @exports PublicKey\n   * @classdesc Represents a PublicKey.\n   * @implements IPublicKey\n   * @constructor\n   * @param {IPublicKey=} [p] Properties to set\n   */\n  function PublicKey(p) {\n    if (p) for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];\n  }\n  /**\n   * PublicKey Type.\n   * @member {KeyType} Type\n   * @memberof PublicKey\n   * @instance\n   */\n\n\n  PublicKey.prototype.Type = 0;\n  /**\n   * PublicKey Data.\n   * @member {Uint8Array} Data\n   * @memberof PublicKey\n   * @instance\n   */\n\n  PublicKey.prototype.Data = $util.newBuffer([]);\n  /**\n   * Encodes the specified PublicKey message. Does not implicitly {@link PublicKey.verify|verify} messages.\n   * @function encode\n   * @memberof PublicKey\n   * @static\n   * @param {IPublicKey} m PublicKey message or plain object to encode\n   * @param {$protobuf.Writer} [w] Writer to encode to\n   * @returns {$protobuf.Writer} Writer\n   */\n\n  PublicKey.encode = function encode(m, w) {\n    if (!w) w = $Writer.create();\n    w.uint32(8).int32(m.Type);\n    w.uint32(18).bytes(m.Data);\n    return w;\n  };\n  /**\n   * Decodes a PublicKey message from the specified reader or buffer.\n   * @function decode\n   * @memberof PublicKey\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from\n   * @param {number} [l] Message length if known beforehand\n   * @returns {PublicKey} PublicKey\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n\n  PublicKey.decode = function decode(r, l) {\n    if (!(r instanceof $Reader)) r = $Reader.create(r);\n    var c = l === undefined ? r.len : r.pos + l,\n        m = new $root.PublicKey();\n\n    while (r.pos < c) {\n      var t = r.uint32();\n\n      switch (t >>> 3) {\n        case 1:\n          m.Type = r.int32();\n          break;\n\n        case 2:\n          m.Data = r.bytes();\n          break;\n\n        default:\n          r.skipType(t & 7);\n          break;\n      }\n    }\n\n    if (!m.hasOwnProperty(\"Type\")) throw $util.ProtocolError(\"missing required 'Type'\", {\n      instance: m\n    });\n    if (!m.hasOwnProperty(\"Data\")) throw $util.ProtocolError(\"missing required 'Data'\", {\n      instance: m\n    });\n    return m;\n  };\n  /**\n   * Creates a PublicKey message from a plain object. Also converts values to their respective internal types.\n   * @function fromObject\n   * @memberof PublicKey\n   * @static\n   * @param {Object.<string,*>} d Plain object\n   * @returns {PublicKey} PublicKey\n   */\n\n\n  PublicKey.fromObject = function fromObject(d) {\n    if (d instanceof $root.PublicKey) return d;\n    var m = new $root.PublicKey();\n\n    switch (d.Type) {\n      case \"RSA\":\n      case 0:\n        m.Type = 0;\n        break;\n\n      case \"Ed25519\":\n      case 1:\n        m.Type = 1;\n        break;\n\n      case \"Secp256k1\":\n      case 2:\n        m.Type = 2;\n        break;\n    }\n\n    if (d.Data != null) {\n      if (typeof d.Data === \"string\") $util.base64.decode(d.Data, m.Data = $util.newBuffer($util.base64.length(d.Data)), 0);else if (d.Data.length) m.Data = d.Data;\n    }\n\n    return m;\n  };\n  /**\n   * Creates a plain object from a PublicKey message. Also converts values to other types if specified.\n   * @function toObject\n   * @memberof PublicKey\n   * @static\n   * @param {PublicKey} m PublicKey\n   * @param {$protobuf.IConversionOptions} [o] Conversion options\n   * @returns {Object.<string,*>} Plain object\n   */\n\n\n  PublicKey.toObject = function toObject(m, o) {\n    if (!o) o = {};\n    var d = {};\n\n    if (o.defaults) {\n      d.Type = o.enums === String ? \"RSA\" : 0;\n      if (o.bytes === String) d.Data = \"\";else {\n        d.Data = [];\n        if (o.bytes !== Array) d.Data = $util.newBuffer(d.Data);\n      }\n    }\n\n    if (m.Type != null && m.hasOwnProperty(\"Type\")) {\n      d.Type = o.enums === String ? $root.KeyType[m.Type] : m.Type;\n    }\n\n    if (m.Data != null && m.hasOwnProperty(\"Data\")) {\n      d.Data = o.bytes === String ? $util.base64.encode(m.Data, 0, m.Data.length) : o.bytes === Array ? Array.prototype.slice.call(m.Data) : m.Data;\n    }\n\n    return d;\n  };\n  /**\n   * Converts this PublicKey to JSON.\n   * @function toJSON\n   * @memberof PublicKey\n   * @instance\n   * @returns {Object.<string,*>} JSON object\n   */\n\n\n  PublicKey.prototype.toJSON = function toJSON() {\n    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n  };\n\n  return PublicKey;\n}();\n\n$root.PrivateKey = function () {\n  /**\n   * Properties of a PrivateKey.\n   * @exports IPrivateKey\n   * @interface IPrivateKey\n   * @property {KeyType} Type PrivateKey Type\n   * @property {Uint8Array} Data PrivateKey Data\n   */\n\n  /**\n   * Constructs a new PrivateKey.\n   * @exports PrivateKey\n   * @classdesc Represents a PrivateKey.\n   * @implements IPrivateKey\n   * @constructor\n   * @param {IPrivateKey=} [p] Properties to set\n   */\n  function PrivateKey(p) {\n    if (p) for (var ks = Object.keys(p), i = 0; i < ks.length; ++i) if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];\n  }\n  /**\n   * PrivateKey Type.\n   * @member {KeyType} Type\n   * @memberof PrivateKey\n   * @instance\n   */\n\n\n  PrivateKey.prototype.Type = 0;\n  /**\n   * PrivateKey Data.\n   * @member {Uint8Array} Data\n   * @memberof PrivateKey\n   * @instance\n   */\n\n  PrivateKey.prototype.Data = $util.newBuffer([]);\n  /**\n   * Encodes the specified PrivateKey message. Does not implicitly {@link PrivateKey.verify|verify} messages.\n   * @function encode\n   * @memberof PrivateKey\n   * @static\n   * @param {IPrivateKey} m PrivateKey message or plain object to encode\n   * @param {$protobuf.Writer} [w] Writer to encode to\n   * @returns {$protobuf.Writer} Writer\n   */\n\n  PrivateKey.encode = function encode(m, w) {\n    if (!w) w = $Writer.create();\n    w.uint32(8).int32(m.Type);\n    w.uint32(18).bytes(m.Data);\n    return w;\n  };\n  /**\n   * Decodes a PrivateKey message from the specified reader or buffer.\n   * @function decode\n   * @memberof PrivateKey\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from\n   * @param {number} [l] Message length if known beforehand\n   * @returns {PrivateKey} PrivateKey\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n\n  PrivateKey.decode = function decode(r, l) {\n    if (!(r instanceof $Reader)) r = $Reader.create(r);\n    var c = l === undefined ? r.len : r.pos + l,\n        m = new $root.PrivateKey();\n\n    while (r.pos < c) {\n      var t = r.uint32();\n\n      switch (t >>> 3) {\n        case 1:\n          m.Type = r.int32();\n          break;\n\n        case 2:\n          m.Data = r.bytes();\n          break;\n\n        default:\n          r.skipType(t & 7);\n          break;\n      }\n    }\n\n    if (!m.hasOwnProperty(\"Type\")) throw $util.ProtocolError(\"missing required 'Type'\", {\n      instance: m\n    });\n    if (!m.hasOwnProperty(\"Data\")) throw $util.ProtocolError(\"missing required 'Data'\", {\n      instance: m\n    });\n    return m;\n  };\n  /**\n   * Creates a PrivateKey message from a plain object. Also converts values to their respective internal types.\n   * @function fromObject\n   * @memberof PrivateKey\n   * @static\n   * @param {Object.<string,*>} d Plain object\n   * @returns {PrivateKey} PrivateKey\n   */\n\n\n  PrivateKey.fromObject = function fromObject(d) {\n    if (d instanceof $root.PrivateKey) return d;\n    var m = new $root.PrivateKey();\n\n    switch (d.Type) {\n      case \"RSA\":\n      case 0:\n        m.Type = 0;\n        break;\n\n      case \"Ed25519\":\n      case 1:\n        m.Type = 1;\n        break;\n\n      case \"Secp256k1\":\n      case 2:\n        m.Type = 2;\n        break;\n    }\n\n    if (d.Data != null) {\n      if (typeof d.Data === \"string\") $util.base64.decode(d.Data, m.Data = $util.newBuffer($util.base64.length(d.Data)), 0);else if (d.Data.length) m.Data = d.Data;\n    }\n\n    return m;\n  };\n  /**\n   * Creates a plain object from a PrivateKey message. Also converts values to other types if specified.\n   * @function toObject\n   * @memberof PrivateKey\n   * @static\n   * @param {PrivateKey} m PrivateKey\n   * @param {$protobuf.IConversionOptions} [o] Conversion options\n   * @returns {Object.<string,*>} Plain object\n   */\n\n\n  PrivateKey.toObject = function toObject(m, o) {\n    if (!o) o = {};\n    var d = {};\n\n    if (o.defaults) {\n      d.Type = o.enums === String ? \"RSA\" : 0;\n      if (o.bytes === String) d.Data = \"\";else {\n        d.Data = [];\n        if (o.bytes !== Array) d.Data = $util.newBuffer(d.Data);\n      }\n    }\n\n    if (m.Type != null && m.hasOwnProperty(\"Type\")) {\n      d.Type = o.enums === String ? $root.KeyType[m.Type] : m.Type;\n    }\n\n    if (m.Data != null && m.hasOwnProperty(\"Data\")) {\n      d.Data = o.bytes === String ? $util.base64.encode(m.Data, 0, m.Data.length) : o.bytes === Array ? Array.prototype.slice.call(m.Data) : m.Data;\n    }\n\n    return d;\n  };\n  /**\n   * Converts this PrivateKey to JSON.\n   * @function toJSON\n   * @memberof PrivateKey\n   * @instance\n   * @returns {Object.<string,*>} JSON object\n   */\n\n\n  PrivateKey.prototype.toJSON = function toJSON() {\n    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n  };\n\n  return PrivateKey;\n}();\n\nmodule.exports = $root;","map":null,"metadata":{},"sourceType":"script"}