{"ast":null,"code":"'use strict';\n\nconst normaliseInput = require('ipfs-core-utils/src/pins/normalise-input');\n\nconst _require = require('../../utils'),\n      resolvePath = _require.resolvePath;\n\nconst withTimeoutOption = require('ipfs-core-utils/src/with-timeout-option');\n\nconst _require2 = require('./pin-manager'),\n      PinTypes = _require2.PinTypes;\n/**\n * @param {Object} config\n * @param {import('.').PinManager} config.pinManager\n * @param {import('.').GCLock} config.gcLock\n * @param {import('.').DagReader} config.dagReader\n */\n\n\nmodule.exports = ({\n  pinManager,\n  gcLock,\n  dagReader\n}) => {\n  /**\n   * Unpin one or more blocks from your repo\n   *\n   * @param {Source} source - Unpin all pins from the source\n   * @param {AbortOptions} [_options]\n   * @returns {AsyncIterable<CID>}\n   * @example\n   * ```js\n   * const source = [\n   *   CID.from('QmWATWQ7fVPP2EFGu71UkfnqhYXDYH566qy47CnJDgvs8u')\n   * ]\n   * for await (const cid of ipfs.pin.rmAll(source)) {\n   *   console.log(cid)\n   * }\n   * // prints the CIDs that were unpinned\n   * // CID('QmWATWQ7fVPP2EFGu71UkfnqhYXDYH566qy47CnJDgvs8u')\n   * ```\n   */\n  async function* rmAll(source, _options = {}) {\n    const release = await gcLock.readLock();\n\n    try {\n      // verify that each hash can be unpinned\n      for await (const _ref of normaliseInput(source)) {\n        const path = _ref.path;\n        const recursive = _ref.recursive;\n        const cid = await resolvePath(dagReader, path);\n\n        const _ref2 = await pinManager.isPinnedWithType(cid, PinTypes.all),\n              pinned = _ref2.pinned,\n              reason = _ref2.reason;\n\n        if (!pinned) {\n          throw new Error(\"\".concat(cid, \" is not pinned\"));\n        }\n\n        switch (reason) {\n          case PinTypes.recursive:\n            if (!recursive) {\n              throw new Error(\"\".concat(cid, \" is pinned recursively\"));\n            }\n\n            await pinManager.unpin(cid);\n            yield cid;\n            break;\n\n          case PinTypes.direct:\n            await pinManager.unpin(cid);\n            yield cid;\n            break;\n\n          default:\n            throw new Error(\"\".concat(cid, \" is pinned indirectly under \").concat(reason));\n        }\n      }\n    } finally {\n      release();\n    }\n  }\n\n  return withTimeoutOption(rmAll);\n};\n/**\n * @typedef {import('.').CID} CID\n * @typedef {import('.').AbortOptions} AbortOptions\n * @typedef {import('./add-all').Source} Source\n */","map":null,"metadata":{},"sourceType":"script"}