{"ast":null,"code":"'use strict';\n\nconst debug = require('debug');\n\nconst log = Object.assign(debug('libp2p:circuit'), {\n  error: debug('libp2p:circuit:err')\n});\n\nconst mafmt = require('mafmt');\n\nconst multiaddr = require('multiaddr');\n\nconst PeerId = require('peer-id');\n\nconst _require = require('./protocol'),\n      CircuitPB = _require.CircuitRelay;\n\nconst toConnection = require('libp2p-utils/src/stream-to-ma-conn');\n\nconst _require2 = require('./multicodec'),\n      multicodec = _require2.relay;\n\nconst createListener = require('./listener');\n\nconst _require3 = require('./circuit/hop'),\n      handleCanHop = _require3.handleCanHop,\n      handleHop = _require3.handleHop,\n      hop = _require3.hop;\n\nconst _require4 = require('./circuit/stop'),\n      handleStop = _require4.handleStop;\n\nconst StreamHandler = require('./circuit/stream-handler');\n\nconst transportSymbol = Symbol.for('@libp2p/js-libp2p-circuit/circuit');\n/**\n * @typedef {import('multiaddr')} Multiaddr\n * @typedef {import('libp2p-interfaces/src/connection').Connection} Connection\n * @typedef {import('libp2p-interfaces/src/stream-muxer/types').MuxedStream} MuxedStream\n * @typedef {import('../types').CircuitRequest} CircuitRequest\n */\n\nclass Circuit {\n  /**\n   * Creates an instance of the Circuit Transport.\n   *\n   * @class\n   * @param {object} options\n   * @param {import('../')} options.libp2p\n   * @param {import('../upgrader')} options.upgrader\n   */\n  constructor({\n    libp2p,\n    upgrader\n  }) {\n    this._dialer = libp2p.dialer;\n    this._registrar = libp2p.registrar;\n    this._connectionManager = libp2p.connectionManager;\n    this._upgrader = upgrader;\n    this._options = libp2p._config.relay;\n    this._libp2p = libp2p;\n    this.peerId = libp2p.peerId;\n\n    this._registrar.handle(multicodec, this._onProtocol.bind(this));\n  }\n  /**\n   * @param {Object} props\n   * @param {Connection} props.connection\n   * @param {MuxedStream} props.stream\n   */\n\n\n  async _onProtocol({\n    connection,\n    stream\n  }) {\n    /** @type {import('./circuit/stream-handler')<CircuitRequest>} */\n    const streamHandler = new StreamHandler({\n      stream\n    });\n    const request = await streamHandler.read();\n\n    if (!request) {\n      return;\n    }\n\n    const circuit = this;\n    let virtualConnection;\n\n    switch (request.type) {\n      case CircuitPB.Type.CAN_HOP:\n        {\n          log('received CAN_HOP request from %s', connection.remotePeer.toB58String());\n          await handleCanHop({\n            circuit,\n            connection,\n            streamHandler\n          });\n          break;\n        }\n\n      case CircuitPB.Type.HOP:\n        {\n          log('received HOP request from %s', connection.remotePeer.toB58String());\n          virtualConnection = await handleHop({\n            connection,\n            request,\n            streamHandler,\n            circuit\n          });\n          break;\n        }\n\n      case CircuitPB.Type.STOP:\n        {\n          log('received STOP request from %s', connection.remotePeer.toB58String());\n          virtualConnection = await handleStop({\n            connection,\n            request,\n            streamHandler\n          });\n          break;\n        }\n\n      default:\n        {\n          log('Request of type %s not supported', request.type);\n        }\n    }\n\n    if (virtualConnection) {\n      const remoteAddr = multiaddr(request.dstPeer.addrs[0]);\n      const localAddr = multiaddr(request.srcPeer.addrs[0]);\n      const maConn = toConnection({\n        stream: virtualConnection,\n        remoteAddr,\n        localAddr\n      });\n      const type = request.type === CircuitPB.Type.HOP ? 'relay' : 'inbound';\n      log('new %s connection %s', type, maConn.remoteAddr);\n      const conn = await this._upgrader.upgradeInbound(maConn);\n      log('%s connection %s upgraded', type, maConn.remoteAddr);\n      this.handler && this.handler(conn);\n    }\n  }\n  /**\n   * Dial a peer over a relay\n   *\n   * @param {Multiaddr} ma - the multiaddr of the peer to dial\n   * @param {Object} options - dial options\n   * @param {AbortSignal} [options.signal] - An optional abort signal\n   * @returns {Promise<Connection>} - the connection\n   */\n\n\n  async dial(ma, options) {\n    // Check the multiaddr to see if it contains a relay and a destination peer\n    const addrs = ma.toString().split('/p2p-circuit');\n    const relayAddr = multiaddr(addrs[0]);\n    const destinationAddr = multiaddr(addrs[addrs.length - 1]);\n    const relayPeer = PeerId.createFromCID(relayAddr.getPeerId());\n    const destinationPeer = PeerId.createFromCID(destinationAddr.getPeerId());\n    let disconnectOnFailure = false;\n\n    let relayConnection = this._connectionManager.get(relayPeer);\n\n    if (!relayConnection) {\n      relayConnection = await this._dialer.connectToPeer(relayAddr, options);\n      disconnectOnFailure = true;\n    }\n\n    try {\n      const virtualConnection = await hop({\n        connection: relayConnection,\n        request: {\n          type: CircuitPB.Type.HOP,\n          srcPeer: {\n            id: this.peerId.toBytes(),\n            addrs: this._libp2p.multiaddrs.map(addr => addr.bytes)\n          },\n          dstPeer: {\n            id: destinationPeer.toBytes(),\n            addrs: [multiaddr(destinationAddr).bytes]\n          }\n        }\n      });\n      const localAddr = relayAddr.encapsulate(\"/p2p-circuit/p2p/\".concat(this.peerId.toB58String()));\n      const maConn = toConnection({\n        stream: virtualConnection,\n        remoteAddr: ma,\n        localAddr\n      });\n      log('new outbound connection %s', maConn.remoteAddr);\n      return this._upgrader.upgradeOutbound(maConn);\n    } catch (err) {\n      log.error('Circuit relay dial failed', err);\n      disconnectOnFailure && (await relayConnection.close());\n      throw err;\n    }\n  }\n  /**\n   * Create a listener\n   *\n   * @param {any} options\n   * @param {Function} handler\n   * @returns {import('libp2p-interfaces/src/transport/types').Listener}\n   */\n\n\n  createListener(options, handler) {\n    if (typeof options === 'function') {\n      handler = options;\n      options = {};\n    } // Called on successful HOP and STOP requests\n\n\n    this.handler = handler;\n    return createListener(this._libp2p);\n  }\n  /**\n   * Filter check for all Multiaddrs that this transport can dial on\n   *\n   * @param {Multiaddr[]} multiaddrs\n   * @returns {Multiaddr[]}\n   */\n\n\n  filter(multiaddrs) {\n    multiaddrs = Array.isArray(multiaddrs) ? multiaddrs : [multiaddrs];\n    return multiaddrs.filter(ma => {\n      return mafmt.Circuit.matches(ma);\n    });\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'Circuit';\n  }\n  /**\n   * Checks if the given value is a Transport instance.\n   *\n   * @param {any} other\n   * @returns {other is Transport}\n   */\n\n\n  static isTransport(other) {\n    return Boolean(other && other[transportSymbol]);\n  }\n\n}\n\nmodule.exports = Circuit;","map":null,"metadata":{},"sourceType":"script"}