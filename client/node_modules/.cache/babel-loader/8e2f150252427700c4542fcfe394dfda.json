{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.PeerScore = void 0;\n\nconst peer_score_params_1 = require(\"./peer-score-params\");\n\nconst peer_stats_1 = require(\"./peer-stats\");\n\nconst compute_score_1 = require(\"./compute-score\");\n\nconst message_deliveries_1 = require(\"./message-deliveries\");\n\nconst constants_1 = require(\"../constants\");\n\nconst peer_id_1 = __importDefault(require(\"peer-id\"));\n\nconst debug = require(\"debug\");\n\nconst pubsubErrors = require(\"libp2p-interfaces/src/pubsub/errors\");\n\nconst _pubsubErrors$codes = pubsubErrors.codes,\n      ERR_INVALID_SIGNATURE = _pubsubErrors$codes.ERR_INVALID_SIGNATURE,\n      ERR_MISSING_SIGNATURE = _pubsubErrors$codes.ERR_MISSING_SIGNATURE;\nconst log = debug('libp2p:gossipsub:score');\n\nclass PeerScore {\n  constructor(params, connectionManager, msgId) {\n    peer_score_params_1.validatePeerScoreParams(params);\n    this.params = params;\n    this._connectionManager = connectionManager;\n    this.peerStats = new Map();\n    this.peerIPs = new Map();\n    this.deliveryRecords = new message_deliveries_1.MessageDeliveries();\n    this.msgId = msgId;\n  }\n  /**\n   * Start PeerScore instance\n   * @returns {void}\n   */\n\n\n  start() {\n    if (this._backgroundInterval) {\n      log('Peer score already running');\n      return;\n    }\n\n    this._backgroundInterval = setInterval(() => this.background(), this.params.decayInterval);\n    log('started');\n  }\n  /**\n   * Stop PeerScore instance\n   * @returns {void}\n   */\n\n\n  stop() {\n    if (!this._backgroundInterval) {\n      log('Peer score already stopped');\n      return;\n    }\n\n    clearInterval(this._backgroundInterval);\n    delete this._backgroundInterval;\n    this.peerIPs.clear();\n    this.peerStats.clear();\n    this.deliveryRecords.clear();\n    log('stopped');\n  }\n  /**\n   * Periodic maintenance\n   * @returns {void}\n   */\n\n\n  background() {\n    this._refreshScores();\n\n    this._updateIPs();\n\n    this.deliveryRecords.gc();\n  }\n  /**\n   * Decays scores, and purges score records for disconnected peers once their expiry has elapsed.\n   * @returns {void}\n   */\n\n\n  _refreshScores() {\n    const now = Date.now();\n    const decayToZero = this.params.decayToZero;\n    this.peerStats.forEach((pstats, id) => {\n      if (!pstats.connected) {\n        // has the retention perious expired?\n        if (now > pstats.expire) {\n          // yes, throw it away (but clean up the IP tracking first)\n          this._removeIPs(id, pstats.ips);\n\n          this.peerStats.delete(id);\n        } // we don't decay retained scores, as the peer is not active.\n        // this way the peer cannot reset a negative score by simply disconnecting and reconnecting,\n        // unless the retention period has ellapsed.\n        // similarly, a well behaved peer does not lose its score by getting disconnected.\n\n\n        return;\n      }\n\n      Object.entries(pstats.topics).forEach(([topic, tstats]) => {\n        const tparams = this.params.topics[topic];\n\n        if (!tparams) {\n          // we are not scoring this topic\n          // should be unreachable, we only add scored topics to pstats\n          return;\n        } // decay counters\n\n\n        tstats.firstMessageDeliveries *= tparams.firstMessageDeliveriesDecay;\n\n        if (tstats.firstMessageDeliveries < decayToZero) {\n          tstats.firstMessageDeliveries = 0;\n        }\n\n        tstats.meshMessageDeliveries *= tparams.meshMessageDeliveriesDecay;\n\n        if (tstats.meshMessageDeliveries < decayToZero) {\n          tstats.meshMessageDeliveries = 0;\n        }\n\n        tstats.meshFailurePenalty *= tparams.meshFailurePenaltyDecay;\n\n        if (tstats.meshFailurePenalty < decayToZero) {\n          tstats.meshFailurePenalty = 0;\n        }\n\n        tstats.invalidMessageDeliveries *= tparams.invalidMessageDeliveriesDecay;\n\n        if (tstats.invalidMessageDeliveries < decayToZero) {\n          tstats.invalidMessageDeliveries = 0;\n        } // update mesh time and activate mesh message delivery parameter if need be\n\n\n        if (tstats.inMesh) {\n          tstats.meshTime = now - tstats.graftTime;\n\n          if (tstats.meshTime > tparams.meshMessageDeliveriesActivation) {\n            tstats.meshMessageDeliveriesActive = true;\n          }\n        }\n      }); // decay P7 counter\n\n      pstats.behaviourPenalty *= this.params.behaviourPenaltyDecay;\n\n      if (pstats.behaviourPenalty < decayToZero) {\n        pstats.behaviourPenalty = 0;\n      }\n    });\n  }\n  /**\n   * Return the score for a peer\n   * @param {string} id\n   * @returns {Number}\n   */\n\n\n  score(id) {\n    const pstats = this.peerStats.get(id);\n\n    if (!pstats) {\n      return 0;\n    }\n\n    return compute_score_1.computeScore(id, pstats, this.params, this.peerIPs);\n  }\n  /**\n   * Apply a behavioural penalty to a peer\n   * @param {string} id\n   * @param {Number} penalty\n   * @returns {void}\n   */\n\n\n  addPenalty(id, penalty) {\n    const pstats = this.peerStats.get(id);\n\n    if (!pstats) {\n      return;\n    }\n\n    pstats.behaviourPenalty += penalty;\n  }\n  /**\n   * @param {string} id\n   * @returns {void}\n   */\n\n\n  addPeer(id) {\n    // create peer stats (not including topic stats for each topic to be scored)\n    // topic stats will be added as needed\n    const pstats = peer_stats_1.createPeerStats({\n      connected: true\n    });\n    this.peerStats.set(id, pstats); // get + update peer IPs\n\n    const ips = this._getIPs(id);\n\n    this._setIPs(id, ips, pstats.ips);\n\n    pstats.ips = ips;\n  }\n  /**\n   * @param {string} id\n   * @returns {void}\n   */\n\n\n  removePeer(id) {\n    const pstats = this.peerStats.get(id);\n\n    if (!pstats) {\n      return;\n    } // decide whether to retain the score; this currently only retains non-positive scores\n    // to dissuade attacks on the score function.\n\n\n    if (this.score(id) > 0) {\n      this._removeIPs(id, pstats.ips);\n\n      this.peerStats.delete(id);\n      return;\n    } // furthermore, when we decide to retain the score, the firstMessageDelivery counters are\n    // reset to 0 and mesh delivery penalties applied.\n\n\n    Object.entries(pstats.topics).forEach(([topic, tstats]) => {\n      tstats.firstMessageDeliveries = 0;\n      const threshold = this.params.topics[topic].meshMessageDeliveriesThreshold;\n\n      if (tstats.inMesh && tstats.meshMessageDeliveriesActive && tstats.meshMessageDeliveries < threshold) {\n        const deficit = threshold - tstats.meshMessageDeliveries;\n        tstats.meshFailurePenalty += deficit * deficit;\n      }\n\n      tstats.inMesh = false;\n    });\n    pstats.connected = false;\n    pstats.expire = Date.now() + this.params.retainScore;\n  }\n  /**\n   * @param {string} id\n   * @param {String} topic\n   * @returns {void}\n   */\n\n\n  graft(id, topic) {\n    const pstats = this.peerStats.get(id);\n\n    if (!pstats) {\n      return;\n    }\n\n    const tstats = peer_stats_1.ensureTopicStats(topic, pstats, this.params);\n\n    if (!tstats) {\n      return;\n    }\n\n    tstats.inMesh = true;\n    tstats.graftTime = Date.now();\n    tstats.meshTime = 0;\n    tstats.meshMessageDeliveriesActive = false;\n  }\n  /**\n   * @param {string} id\n   * @param {string} topic\n   * @returns {void}\n   */\n\n\n  prune(id, topic) {\n    const pstats = this.peerStats.get(id);\n\n    if (!pstats) {\n      return;\n    }\n\n    const tstats = peer_stats_1.ensureTopicStats(topic, pstats, this.params);\n\n    if (!tstats) {\n      return;\n    } // sticky mesh delivery rate failure penalty\n\n\n    const threshold = this.params.topics[topic].meshMessageDeliveriesThreshold;\n\n    if (tstats.meshMessageDeliveriesActive && tstats.meshMessageDeliveries < threshold) {\n      const deficit = threshold - tstats.meshMessageDeliveries;\n      tstats.meshFailurePenalty += deficit * deficit;\n    }\n\n    tstats.inMesh = false;\n  }\n  /**\n   * @param {InMessage} message\n   * @returns {void}\n   */\n\n\n  validateMessage(message) {\n    this.deliveryRecords.ensureRecord(this.msgId(message));\n  }\n  /**\n   * @param {InMessage} message\n   * @returns {void}\n   */\n\n\n  deliverMessage(message) {\n    const id = message.receivedFrom;\n\n    this._markFirstMessageDelivery(id, message);\n\n    const drec = this.deliveryRecords.ensureRecord(this.msgId(message));\n    const now = Date.now(); // defensive check that this is the first delivery trace -- delivery status should be unknown\n\n    if (drec.status !== message_deliveries_1.DeliveryRecordStatus.unknown) {\n      log('unexpected delivery: message from %s was first seen %s ago and has delivery status %d', id, now - drec.firstSeen, message_deliveries_1.DeliveryRecordStatus[drec.status]);\n      return;\n    } // mark the message as valid and reward mesh peers that have already forwarded it to us\n\n\n    drec.status = message_deliveries_1.DeliveryRecordStatus.valid;\n    drec.validated = now;\n    drec.peers.forEach(p => {\n      // this check is to make sure a peer can't send us a message twice and get a double count\n      // if it is a first delivery.\n      if (p !== id) {\n        this._markDuplicateMessageDelivery(p, message);\n      }\n    });\n  }\n  /**\n   * @param {InMessage} message\n   * @param {string} reason\n   * @returns {void}\n   */\n\n\n  rejectMessage(message, reason) {\n    const id = message.receivedFrom;\n\n    switch (reason) {\n      case ERR_MISSING_SIGNATURE:\n      case ERR_INVALID_SIGNATURE:\n        this._markInvalidMessageDelivery(id, message);\n\n        return;\n    }\n\n    const drec = this.deliveryRecords.ensureRecord(this.msgId(message)); // defensive check that this is the first rejection -- delivery status should be unknown\n\n    if (drec.status !== message_deliveries_1.DeliveryRecordStatus.unknown) {\n      log('unexpected rejection: message from %s was first seen %s ago and has delivery status %d', id, Date.now() - drec.firstSeen, message_deliveries_1.DeliveryRecordStatus[drec.status]);\n      return;\n    }\n\n    switch (reason) {\n      case constants_1.ERR_TOPIC_VALIDATOR_IGNORE:\n        // we were explicitly instructed by the validator to ignore the message but not penalize the peer\n        drec.status = message_deliveries_1.DeliveryRecordStatus.ignored;\n        return;\n    } // mark the message as invalid and penalize peers that have already forwarded it.\n\n\n    drec.status = message_deliveries_1.DeliveryRecordStatus.invalid;\n\n    this._markInvalidMessageDelivery(id, message);\n\n    drec.peers.forEach(p => {\n      this._markInvalidMessageDelivery(p, message);\n    });\n  }\n  /**\n   * @param {InMessage} message\n   * @returns {void}\n   */\n\n\n  duplicateMessage(message) {\n    const id = message.receivedFrom;\n    const drec = this.deliveryRecords.ensureRecord(this.msgId(message));\n\n    if (drec.peers.has(id)) {\n      // we have already seen this duplicate\n      return;\n    }\n\n    switch (drec.status) {\n      case message_deliveries_1.DeliveryRecordStatus.unknown:\n        // the message is being validated; track the peer delivery and wait for\n        // the Deliver/Reject/Ignore notification.\n        drec.peers.add(id);\n        break;\n\n      case message_deliveries_1.DeliveryRecordStatus.valid:\n        // mark the peer delivery time to only count a duplicate delivery once.\n        drec.peers.add(id);\n\n        this._markDuplicateMessageDelivery(id, message, drec.validated);\n\n        break;\n\n      case message_deliveries_1.DeliveryRecordStatus.invalid:\n        // we no longer track delivery time\n        this._markInvalidMessageDelivery(id, message);\n\n        break;\n    }\n  }\n  /**\n   * Increments the \"invalid message deliveries\" counter for all scored topics the message is published in.\n   * @param {string} id\n   * @param {InMessage} message\n   * @returns {void}\n   */\n\n\n  _markInvalidMessageDelivery(id, message) {\n    const pstats = this.peerStats.get(id);\n\n    if (!pstats) {\n      return;\n    }\n\n    message.topicIDs.forEach(topic => {\n      const tstats = peer_stats_1.ensureTopicStats(topic, pstats, this.params);\n\n      if (!tstats) {\n        return;\n      }\n\n      tstats.invalidMessageDeliveries += 1;\n    });\n  }\n  /**\n   * Increments the \"first message deliveries\" counter for all scored topics the message is published in,\n   * as well as the \"mesh message deliveries\" counter, if the peer is in the mesh for the topic.\n   * @param {string} id\n   * @param {InMessage} message\n   * @returns {void}\n   */\n\n\n  _markFirstMessageDelivery(id, message) {\n    const pstats = this.peerStats.get(id);\n\n    if (!pstats) {\n      return;\n    }\n\n    message.topicIDs.forEach(topic => {\n      const tstats = peer_stats_1.ensureTopicStats(topic, pstats, this.params);\n\n      if (!tstats) {\n        return;\n      }\n\n      let cap = this.params.topics[topic].firstMessageDeliveriesCap;\n      tstats.firstMessageDeliveries += 1;\n\n      if (tstats.firstMessageDeliveries > cap) {\n        tstats.firstMessageDeliveries = cap;\n      }\n\n      if (!tstats.inMesh) {\n        return;\n      }\n\n      cap = this.params.topics[topic].meshMessageDeliveriesCap;\n      tstats.meshMessageDeliveries += 1;\n\n      if (tstats.meshMessageDeliveries > cap) {\n        tstats.meshMessageDeliveries = cap;\n      }\n    });\n  }\n  /**\n   * Increments the \"mesh message deliveries\" counter for messages we've seen before,\n   * as long the message was received within the P3 window.\n   * @param {string} id\n   * @param {InMessage} message\n   * @param {number} validatedTime\n   * @returns {void}\n   */\n\n\n  _markDuplicateMessageDelivery(id, message, validatedTime = 0) {\n    const pstats = this.peerStats.get(id);\n\n    if (!pstats) {\n      return;\n    }\n\n    const now = validatedTime ? Date.now() : 0;\n    message.topicIDs.forEach(topic => {\n      const tstats = peer_stats_1.ensureTopicStats(topic, pstats, this.params);\n\n      if (!tstats) {\n        return;\n      }\n\n      if (!tstats.inMesh) {\n        return;\n      }\n\n      const tparams = this.params.topics[topic]; // check against the mesh delivery window -- if the validated time is passed as 0, then\n      // the message was received before we finished validation and thus falls within the mesh\n      // delivery window.\n\n      if (validatedTime && now > validatedTime + tparams.meshMessageDeliveriesWindow) {\n        return;\n      }\n\n      const cap = tparams.meshMessageDeliveriesCap;\n      tstats.meshMessageDeliveries += 1;\n\n      if (tstats.meshMessageDeliveries > cap) {\n        tstats.meshMessageDeliveries = cap;\n      }\n    });\n  }\n  /**\n   * Gets the current IPs for a peer.\n   * @param {string} id\n   * @returns {Array<string>}\n   */\n\n\n  _getIPs(id) {\n    return this._connectionManager.getAll(peer_id_1.default.createFromB58String(id)).map(c => c.remoteAddr.toOptions().host);\n  }\n  /**\n   * Adds tracking for the new IPs in the list, and removes tracking from the obsolete IPs.\n   * @param {string} id\n   * @param {Array<string>} newIPs\n   * @param {Array<string>} oldIPs\n   * @returns {void}\n   */\n\n\n  _setIPs(id, newIPs, oldIPs) {\n    // add the new IPs to the tracking\n    // eslint-disable-next-line no-labels\n    addNewIPs: for (const ip of newIPs) {\n      // check if it is in the old ips list\n      for (const xip of oldIPs) {\n        if (ip === xip) {\n          // eslint-disable-next-line no-labels\n          continue addNewIPs;\n        }\n      } // no, it's a new one -- add it to the tracker\n\n\n      let peers = this.peerIPs.get(ip);\n\n      if (!peers) {\n        peers = new Set();\n        this.peerIPs.set(ip, peers);\n      }\n\n      peers.add(id);\n    } // remove the obsolete old IPs from the tracking\n    // eslint-disable-next-line no-labels\n\n\n    removeOldIPs: for (const ip of oldIPs) {\n      // check if it is in the new ips list\n      for (const xip of newIPs) {\n        if (ip === xip) {\n          // eslint-disable-next-line no-labels\n          continue removeOldIPs;\n        }\n      } // no, its obselete -- remove it from the tracker\n\n\n      const peers = this.peerIPs.get(ip);\n\n      if (!peers) {\n        continue;\n      }\n\n      peers.delete(id);\n\n      if (!peers.size) {\n        this.peerIPs.delete(ip);\n      }\n    }\n  }\n  /**\n   * Removes an IP list from the tracking list for a peer.\n   * @param {string} id\n   * @param {Array<string>} ips\n   * @returns {void}\n   */\n\n\n  _removeIPs(id, ips) {\n    ips.forEach(ip => {\n      const peers = this.peerIPs.get(ip);\n\n      if (!peers) {\n        return;\n      }\n\n      peers.delete(id);\n\n      if (!peers.size) {\n        this.peerIPs.delete(ip);\n      }\n    });\n  }\n  /**\n   * Update all peer IPs to currently open connections\n   * @returns {void}\n   */\n\n\n  _updateIPs() {\n    this.peerStats.forEach((pstats, id) => {\n      const newIPs = this._getIPs(id);\n\n      this._setIPs(id, newIPs, pstats.ips);\n\n      pstats.ips = newIPs;\n    });\n  }\n\n}\n\nexports.PeerScore = PeerScore;","map":null,"metadata":{},"sourceType":"script"}