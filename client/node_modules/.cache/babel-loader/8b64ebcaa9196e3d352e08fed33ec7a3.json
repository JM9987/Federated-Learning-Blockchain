{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.computeScore = void 0;\n\nfunction computeScore(peer, pstats, params, peerIPs) {\n  let score = 0; // topic stores\n\n  Object.entries(pstats.topics).forEach(([topic, tstats]) => {\n    // the topic parameters\n    const topicParams = params.topics[topic];\n\n    if (!topicParams) {\n      // we are not scoring this topic\n      return;\n    }\n\n    let topicScore = 0; // P1: time in Mesh\n\n    if (tstats.inMesh) {\n      let p1 = tstats.meshTime / topicParams.timeInMeshQuantum;\n\n      if (p1 > topicParams.timeInMeshCap) {\n        p1 = topicParams.timeInMeshCap;\n      }\n\n      topicScore += p1 * topicParams.timeInMeshWeight;\n    } // P2: first message deliveries\n\n\n    const p2 = tstats.firstMessageDeliveries;\n    topicScore += p2 * topicParams.firstMessageDeliveriesWeight; // P3: mesh message deliveries\n\n    if (tstats.meshMessageDeliveriesActive) {\n      if (tstats.meshMessageDeliveries < topicParams.meshMessageDeliveriesThreshold) {\n        const deficit = topicParams.meshMessageDeliveriesThreshold - tstats.meshMessageDeliveries;\n        const p3 = deficit * deficit;\n        topicScore += p3 * topicParams.meshMessageDeliveriesWeight;\n      }\n    } // P3b:\n    // NOTE: the weight of P3b is negative (validated in validateTopicScoreParams) so this detracts\n\n\n    const p3b = tstats.meshFailurePenalty;\n    topicScore += p3b * topicParams.meshFailurePenaltyWeight; // P4: invalid messages\n    // NOTE: the weight of P4 is negative (validated in validateTopicScoreParams) so this detracts\n\n    const p4 = tstats.invalidMessageDeliveries * tstats.invalidMessageDeliveries;\n    topicScore += p4 * topicParams.invalidMessageDeliveriesWeight; // update score, mixing with topic weight\n\n    score += topicScore * topicParams.topicWeight;\n  }); // apply the topic score cap, if any\n\n  if (params.topicScoreCap > 0 && score > params.topicScoreCap) {\n    score = params.topicScoreCap;\n  } // P5: application-specific score\n\n\n  const p5 = params.appSpecificScore(peer);\n  score += p5 * params.appSpecificWeight; // P6: IP colocation factor\n\n  pstats.ips.forEach(ip => {\n    if (params.IPColocationFactorWhitelist.has(ip)) {\n      return;\n    } // P6 has a cliff (IPColocationFactorThreshold)\n    // It's only applied if at least that many peers are connected to us from that source IP addr.\n    // It is quadratic, and the weight is negative (validated in validatePeerScoreParams)\n\n\n    const peersInIP = peerIPs.get(ip);\n    const numPeersInIP = peersInIP ? peersInIP.size : 0;\n\n    if (numPeersInIP > params.IPColocationFactorThreshold) {\n      const surplus = numPeersInIP - params.IPColocationFactorThreshold;\n      const p6 = surplus * surplus;\n      score += p6 * params.IPColocationFactorWeight;\n    }\n  }); // P7: behavioural pattern penalty\n\n  const p7 = pstats.behaviourPenalty * pstats.behaviourPenalty;\n  score += p7 * params.behaviourPenaltyWeight;\n  return score;\n}\n\nexports.computeScore = computeScore;","map":null,"metadata":{},"sourceType":"script"}