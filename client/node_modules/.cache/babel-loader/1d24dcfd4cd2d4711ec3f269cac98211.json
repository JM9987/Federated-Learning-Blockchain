{"ast":null,"code":"'use strict';\n\nconst debug = require('debug');\n\nconst log = Object.assign(debug('libp2p:persistent-peer-store'), {\n  error: debug('libp2p:persistent-peer-store:err')\n});\n\nconst _require = require('interface-datastore'),\n      Key = _require.Key;\n\nconst multiaddr = require('multiaddr');\n\nconst PeerId = require('peer-id');\n\nconst PeerStore = require('..');\n\nconst _require2 = require('./consts'),\n      NAMESPACE_ADDRESS = _require2.NAMESPACE_ADDRESS,\n      NAMESPACE_COMMON = _require2.NAMESPACE_COMMON,\n      NAMESPACE_KEYS = _require2.NAMESPACE_KEYS,\n      NAMESPACE_METADATA = _require2.NAMESPACE_METADATA,\n      NAMESPACE_PROTOCOL = _require2.NAMESPACE_PROTOCOL;\n\nconst Addresses = require('./pb/address-book.proto');\n\nconst Protocols = require('./pb/proto-book.proto');\n/**\n * @typedef {Object} PersistentPeerStoreProperties\n * @property {PeerId} peerId\n * @property {any} datastore\n *\n * @typedef {Object} PersistentPeerStoreOptions\n * @property {number} [threshold = 5] - Number of dirty peers allowed before commit data.\n */\n\n/**\n * Responsible for managing the persistence of data in the PeerStore.\n */\n\n\nclass PersistentPeerStore extends PeerStore {\n  /**\n   * @class\n   * @param {PersistentPeerStoreProperties & PersistentPeerStoreOptions} properties\n   */\n  constructor({\n    peerId,\n    datastore,\n    threshold = 5\n  }) {\n    super({\n      peerId\n    });\n    /**\n     * Backend datastore used to persist data.\n     */\n\n    this._datastore = datastore;\n    /**\n     * Peers modified after the latest data persisted.\n     */\n\n    this._dirtyPeers = new Set();\n    /**\n     * Peers metadata changed mapping peer identifers to metadata changed.\n     *\n     * @type {Map<string, Set<string>>}\n     */\n\n    this._dirtyMetadata = new Map();\n    this.threshold = threshold;\n    this._addDirtyPeer = this._addDirtyPeer.bind(this);\n  }\n  /**\n   * Start Persistent PeerStore.\n   *\n   * @returns {Promise<void>}\n   */\n\n\n  async start() {\n    log('PeerStore is starting'); // Handlers for dirty peers\n\n    this.on('change:protocols', this._addDirtyPeer);\n    this.on('change:multiaddrs', this._addDirtyPeer);\n    this.on('change:pubkey', this._addDirtyPeerKey);\n    this.on('change:metadata', this._addDirtyPeerMetadata); // Load data\n\n    for await (const entry of this._datastore.query({\n      prefix: NAMESPACE_COMMON\n    })) {\n      await this._processDatastoreEntry(entry);\n    }\n\n    log('PeerStore started');\n  }\n  /**\n   * Stop Persistent PeerStore.\n   *\n   * @returns {Promise<void>}\n   */\n\n\n  async stop() {\n    log('PeerStore is stopping');\n    this.removeAllListeners();\n    await this._commitData();\n    log('PeerStore stopped');\n  }\n  /**\n   * Add modified peer to the dirty set\n   *\n   * @private\n   * @param {Object} params\n   * @param {PeerId} params.peerId\n   */\n\n\n  _addDirtyPeer({\n    peerId\n  }) {\n    const peerIdstr = peerId.toB58String();\n    log('add dirty peer', peerIdstr);\n\n    this._dirtyPeers.add(peerIdstr);\n\n    if (this._dirtyPeers.size >= this.threshold) {\n      // Commit current data\n      this._commitData().catch(err => {\n        log.error('error committing data', err);\n      });\n    }\n  }\n  /**\n   * Add modified peer key to the dirty set\n   *\n   * @private\n   * @param {Object} params\n   * @param {PeerId} params.peerId\n   */\n\n\n  _addDirtyPeerKey({\n    peerId\n  }) {\n    // Not add if inline key available\n    if (peerId.hasInlinePublicKey()) {\n      return;\n    }\n\n    const peerIdstr = peerId.toB58String();\n    log('add dirty peer key', peerIdstr);\n\n    this._dirtyPeers.add(peerIdstr);\n\n    if (this._dirtyPeers.size >= this.threshold) {\n      // Commit current data\n      this._commitData().catch(err => {\n        log.error('error committing data', err);\n      });\n    }\n  }\n  /**\n   * Add modified metadata peer to the set.\n   *\n   * @private\n   * @param {Object} params\n   * @param {PeerId} params.peerId\n   * @param {string} params.metadata\n   */\n\n\n  _addDirtyPeerMetadata({\n    peerId,\n    metadata\n  }) {\n    const peerIdstr = peerId.toB58String();\n    log('add dirty metadata peer', peerIdstr);\n\n    this._dirtyPeers.add(peerIdstr); // Add dirty metadata key\n\n\n    const mData = this._dirtyMetadata.get(peerIdstr) || new Set();\n    mData.add(metadata);\n\n    this._dirtyMetadata.set(peerIdstr, mData);\n\n    if (this._dirtyPeers.size >= this.threshold) {\n      // Commit current data\n      this._commitData().catch(err => {\n        log.error('error committing data', err);\n      });\n    }\n  }\n  /**\n   * Add all the peers current data to a datastore batch and commit it.\n   *\n   * @private\n   * @returns {Promise<void>}\n   */\n\n\n  async _commitData() {\n    const commitPeers = Array.from(this._dirtyPeers);\n\n    if (!commitPeers.length) {\n      return;\n    } // Clear Dirty Peers set\n\n\n    this._dirtyPeers.clear();\n\n    log('create batch commit');\n\n    const batch = this._datastore.batch();\n\n    for (const peerIdStr of commitPeers) {\n      // PeerId\n      const peerId = this.keyBook.data.get(peerIdStr) || PeerId.createFromCID(peerIdStr); // Address Book\n\n      this._batchAddressBook(peerId, batch); // Key Book\n\n\n      !peerId.hasInlinePublicKey() && this._batchKeyBook(peerId, batch); // Metadata Book\n\n      this._batchMetadataBook(peerId, batch); // Proto Book\n\n\n      this._batchProtoBook(peerId, batch);\n    }\n\n    await batch.commit();\n    log('batch committed');\n  }\n  /**\n   * Add address book data of the peer to the batch.\n   *\n   * @private\n   * @param {PeerId} peerId\n   * @param {Object} batch\n   */\n\n\n  _batchAddressBook(peerId, batch) {\n    const b32key = peerId.toString();\n    const key = new Key(\"\".concat(NAMESPACE_ADDRESS).concat(b32key));\n    const entry = this.addressBook.data.get(peerId.toB58String());\n\n    try {\n      // Deleted from the book\n      if (!entry) {\n        batch.delete(key);\n        return;\n      }\n\n      const encodedData = Addresses.encode({\n        addrs: entry.addresses.map(address => ({\n          multiaddr: address.multiaddr.bytes,\n          isCertified: address.isCertified\n        })),\n        certified_record: entry.record ? {\n          seq: entry.record.seqNumber,\n          raw: entry.record.raw\n        } : undefined\n      });\n      batch.put(key, encodedData);\n    } catch (err) {\n      log.error(err);\n    }\n  }\n  /**\n   * Add Key book data of the peer to the batch.\n   *\n   * @private\n   * @param {PeerId} peerId\n   * @param {Object} batch\n   */\n\n\n  _batchKeyBook(peerId, batch) {\n    const b32key = peerId.toString();\n    const key = new Key(\"\".concat(NAMESPACE_KEYS).concat(b32key));\n\n    try {\n      // Deleted from the book\n      if (!peerId.pubKey) {\n        batch.delete(key);\n        return;\n      }\n\n      const encodedData = peerId.marshalPubKey();\n      batch.put(key, encodedData);\n    } catch (err) {\n      log.error(err);\n    }\n  }\n  /**\n   * Add metadata book data of the peer to the batch.\n   *\n   * @private\n   * @param {PeerId} peerId\n   * @param {Object} batch\n   */\n\n\n  _batchMetadataBook(peerId, batch) {\n    const b32key = peerId.toString();\n    const dirtyMetada = this._dirtyMetadata.get(peerId.toB58String()) || [];\n\n    try {\n      dirtyMetada.forEach(dirtyKey => {\n        const key = new Key(\"\".concat(NAMESPACE_METADATA).concat(b32key, \"/\").concat(dirtyKey));\n        const dirtyValue = this.metadataBook.getValue(peerId, dirtyKey);\n\n        if (dirtyValue) {\n          batch.put(key, dirtyValue);\n        } else {\n          batch.delete(key);\n        }\n      });\n    } catch (err) {\n      log.error(err);\n    }\n  }\n  /**\n   * Add proto book data of the peer to the batch.\n   *\n   * @private\n   * @param {PeerId} peerId\n   * @param {Object} batch\n   */\n\n\n  _batchProtoBook(peerId, batch) {\n    const b32key = peerId.toString();\n    const key = new Key(\"\".concat(NAMESPACE_PROTOCOL).concat(b32key));\n    const protocols = this.protoBook.get(peerId);\n\n    try {\n      // Deleted from the book\n      if (!protocols) {\n        batch.delete(key);\n        return;\n      }\n\n      const encodedData = Protocols.encode({\n        protocols\n      });\n      batch.put(key, encodedData);\n    } catch (err) {\n      log.error(err);\n    }\n  }\n  /**\n   * Process datastore entry and add its data to the correct book.\n   *\n   * @private\n   * @param {Object} params\n   * @param {Key} params.key - datastore key\n   * @param {Uint8Array} params.value - datastore value stored\n   * @returns {Promise<void>}\n   */\n\n\n  async _processDatastoreEntry({\n    key,\n    value\n  }) {\n    try {\n      const keyParts = key.toString().split('/');\n      const peerId = PeerId.createFromCID(keyParts[3]);\n      let decoded;\n\n      switch (keyParts[2]) {\n        case 'addrs':\n          decoded = Addresses.decode(value); // @ts-ignore protected function\n\n          this.addressBook._setData(peerId, {\n            addresses: decoded.addrs.map(address => ({\n              multiaddr: multiaddr(address.multiaddr),\n              isCertified: Boolean(address.isCertified)\n            })),\n            record: decoded.certified_record ? {\n              raw: decoded.certified_record.raw,\n              seqNumber: decoded.certified_record.seq\n            } : undefined\n          }, {\n            emit: false\n          });\n\n          break;\n\n        case 'keys':\n          decoded = await PeerId.createFromPubKey(value); // @ts-ignore protected function\n\n          this.keyBook._setData(decoded, decoded, {\n            emit: false\n          });\n\n          break;\n\n        case 'metadata':\n          this.metadataBook._setValue(peerId, keyParts[4], value, {\n            emit: false\n          });\n\n          break;\n\n        case 'protos':\n          decoded = Protocols.decode(value); // @ts-ignore protected function\n\n          this.protoBook._setData(peerId, new Set(decoded.protocols), {\n            emit: false\n          });\n\n          break;\n\n        default:\n          log('invalid data persisted for: ', key.toString());\n      }\n    } catch (err) {\n      log.error(err);\n    }\n  }\n\n}\n\nmodule.exports = PersistentPeerStore;","map":null,"metadata":{},"sourceType":"script"}