{"ast":null,"code":"'use strict';\n/** @typedef {import('../types').EventEmitterFactory} Events */\n\n/** @type Events */\n\nconst EventEmitter = require('events');\n\nconst multiaddr = require('multiaddr');\n\nconst PeerId = require('peer-id');\n/**\n * @typedef {import('multiaddr')} Multiaddr\n */\n\n/**\n * @typedef {Object} AddressManagerOptions\n * @property {string[]} [listen = []] - list of multiaddrs string representation to listen.\n * @property {string[]} [announce = []] - list of multiaddrs string representation to announce.\n */\n\n/**\n * @fires AddressManager#change:addresses Emitted when a addresses change.\n */\n\n\nclass AddressManager extends EventEmitter {\n  /**\n   * Responsible for managing the peer addresses.\n   * Peers can specify their listen and announce addresses.\n   * The listen addresses will be used by the libp2p transports to listen for new connections,\n   * while the announce addresses will be used for the peer addresses' to other peers in the network.\n   *\n   * @class\n   * @param {PeerId} peerId - The Peer ID of the node\n   * @param {object} [options]\n   * @param {Array<string>} [options.listen = []] - list of multiaddrs string representation to listen.\n   * @param {Array<string>} [options.announce = []] - list of multiaddrs string representation to announce.\n   */\n  constructor(peerId, {\n    listen = [],\n    announce = []\n  } = {}) {\n    super();\n    this.peerId = peerId;\n    this.listen = new Set(listen.map(ma => ma.toString()));\n    this.announce = new Set(announce.map(ma => ma.toString()));\n    this.observed = new Set();\n  }\n  /**\n   * Get peer listen multiaddrs.\n   *\n   * @returns {Multiaddr[]}\n   */\n\n\n  getListenAddrs() {\n    return Array.from(this.listen).map(a => multiaddr(a));\n  }\n  /**\n   * Get peer announcing multiaddrs.\n   *\n   * @returns {Multiaddr[]}\n   */\n\n\n  getAnnounceAddrs() {\n    return Array.from(this.announce).map(a => multiaddr(a));\n  }\n  /**\n   * Get observed multiaddrs.\n   *\n   * @returns {Array<Multiaddr>}\n   */\n\n\n  getObservedAddrs() {\n    return Array.from(this.observed).map(a => multiaddr(a));\n  }\n  /**\n   * Add peer observed addresses\n   *\n   * @param {string | Multiaddr} addr\n   */\n\n\n  addObservedAddr(addr) {\n    let ma = multiaddr(addr);\n    const remotePeer = ma.getPeerId(); // strip our peer id if it has been passed\n\n    if (remotePeer) {\n      const remotePeerId = PeerId.createFromB58String(remotePeer); // use same encoding for comparison\n\n      if (remotePeerId.equals(this.peerId)) {\n        ma = ma.decapsulate(multiaddr(\"/p2p/\".concat(this.peerId)));\n      }\n    }\n\n    const addrString = ma.toString(); // do not trigger the change:addresses event if we already know about this address\n\n    if (this.observed.has(addrString)) {\n      return;\n    }\n\n    this.observed.add(addrString);\n    this.emit('change:addresses');\n  }\n\n}\n\nmodule.exports = AddressManager;","map":null,"metadata":{},"sourceType":"script"}