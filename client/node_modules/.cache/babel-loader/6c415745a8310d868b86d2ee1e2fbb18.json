{"ast":null,"code":"'use strict';\n\nconst debug = require('debug');\n\nconst log = Object.assign(debug('libp2p:peer-store:address-book'), {\n  error: debug('libp2p:peer-store:address-book:err')\n});\n\nconst errcode = require('err-code');\n\nconst multiaddr = require('multiaddr');\n\nconst PeerId = require('peer-id');\n\nconst Book = require('./book');\n\nconst PeerRecord = require('../record/peer-record');\n\nconst _require = require('../errors'),\n      ERR_INVALID_PARAMETERS = _require.codes.ERR_INVALID_PARAMETERS;\n\nconst Envelope = require('../record/envelope');\n/**\n * @typedef {import('multiaddr')} Multiaddr\n * @typedef {import('./')} PeerStore\n */\n\n/**\n * @typedef {Object} Address\n * @property {Multiaddr} multiaddr peer multiaddr.\n * @property {boolean} isCertified obtained from a signed peer record.\n *\n * @typedef {Object} CertifiedRecord\n * @property {Uint8Array} raw raw envelope.\n * @property {number} seqNumber seq counter.\n *\n * @typedef {Object} Entry\n * @property {Address[]} addresses peer Addresses.\n * @property {CertifiedRecord} record certified peer record.\n */\n\n/**\n * @extends {Book}\n */\n\n\nclass AddressBook extends Book {\n  /**\n   * The AddressBook is responsible for keeping the known multiaddrs of a peer.\n   *\n   * @class\n   * @param {PeerStore} peerStore\n   */\n  constructor(peerStore) {\n    /**\n     * PeerStore Event emitter, used by the AddressBook to emit:\n     * \"peer\" - emitted when a peer is discovered by the node.\n     * \"change:multiaddrs\" - emitted when the known multiaddrs of a peer change.\n     */\n    super({\n      peerStore,\n      eventName: 'change:multiaddrs',\n      eventProperty: 'multiaddrs',\n      eventTransformer: data => {\n        if (!data.addresses) {\n          return [];\n        }\n\n        return data.addresses.map(address => address.multiaddr);\n      }\n    });\n    /**\n     * Map known peers to their known Address Entries.\n     *\n     * @type {Map<string, Entry>}\n     */\n\n    this.data = new Map();\n  }\n  /**\n   * ConsumePeerRecord adds addresses from a signed peer record contained in a record envelope.\n   * This will return a boolean that indicates if the record was successfully processed and added\n   * into the AddressBook.\n   *\n   * @param {Envelope} envelope\n   * @returns {boolean}\n   */\n\n\n  consumePeerRecord(envelope) {\n    let peerRecord;\n\n    try {\n      peerRecord = PeerRecord.createFromProtobuf(envelope.payload);\n    } catch (err) {\n      log.error('invalid peer record received');\n      return false;\n    } // Verify peerId\n\n\n    if (!peerRecord.peerId.equals(envelope.peerId)) {\n      log('signing key does not match PeerId in the PeerRecord');\n      return false;\n    } // ensure the record has multiaddrs\n\n\n    if (!peerRecord.multiaddrs || !peerRecord.multiaddrs.length) {\n      return false;\n    }\n\n    const peerId = peerRecord.peerId;\n    const id = peerId.toB58String();\n    const entry = this.data.get(id) || {\n      record: undefined\n    };\n    const storedRecord = entry.record; // ensure seq is greater than, or equal to, the last received\n\n    if (storedRecord && storedRecord.seqNumber >= peerRecord.seqNumber) {\n      return false;\n    }\n\n    const addresses = this._toAddresses(peerRecord.multiaddrs, true); // Replace unsigned addresses by the new ones from the record\n    // TODO: Once we have ttls for the addresses, we should merge these in.\n\n\n    this._setData(peerId, {\n      addresses,\n      record: {\n        raw: envelope.marshal(),\n        seqNumber: peerRecord.seqNumber\n      }\n    });\n\n    log(\"stored provided peer record for \".concat(id));\n    return true;\n  }\n  /**\n   * Get the raw Envelope for a peer. Returns\n   * undefined if no Envelope is found.\n   *\n   * @param {PeerId} peerId\n   * @returns {Uint8Array|undefined}\n   */\n\n\n  getRawEnvelope(peerId) {\n    const entry = this.data.get(peerId.toB58String());\n\n    if (!entry || !entry.record || !entry.record.raw) {\n      return undefined;\n    }\n\n    return entry.record.raw;\n  }\n  /**\n   * Get an Envelope containing a PeerRecord for the given peer.\n   * Returns undefined if no record exists.\n   *\n   * @param {PeerId} peerId\n   * @returns {Promise<Envelope|void>|undefined}\n   */\n\n\n  getPeerRecord(peerId) {\n    const raw = this.getRawEnvelope(peerId);\n\n    if (!raw) {\n      return undefined;\n    }\n\n    return Envelope.createFromProtobuf(raw);\n  }\n  /**\n   * Set known multiaddrs of a provided peer.\n   * This will replace previously stored multiaddrs, if available.\n   * Replacing stored multiaddrs might result in losing obtained certified addresses.\n   * If you are not sure, it's recommended to use `add` instead.\n   *\n   * @override\n   * @param {PeerId} peerId\n   * @param {Multiaddr[]} multiaddrs\n   * @returns {AddressBook}\n   */\n\n\n  set(peerId, multiaddrs) {\n    if (!PeerId.isPeerId(peerId)) {\n      log.error('peerId must be an instance of peer-id to store data');\n      throw errcode(new Error('peerId must be an instance of peer-id'), ERR_INVALID_PARAMETERS);\n    }\n\n    const addresses = this._toAddresses(multiaddrs); // Not replace multiaddrs\n\n\n    if (!addresses.length) {\n      return this;\n    }\n\n    const id = peerId.toB58String();\n    const entry = this.data.get(id); // Already knows the peer\n\n    if (entry && entry.addresses && entry.addresses.length === addresses.length) {\n      const intersection = entry.addresses.filter(addr => addresses.some(newAddr => addr.multiaddr.equals(newAddr.multiaddr))); // Are new addresses equal to the old ones?\n      // If yes, no changes needed!\n\n      if (intersection.length === entry.addresses.length) {\n        log(\"the addresses provided to store are equal to the already stored for \".concat(id));\n        return this;\n      }\n    }\n\n    this._setData(peerId, {\n      addresses,\n      record: entry && entry.record\n    });\n\n    log(\"stored provided multiaddrs for \".concat(id)); // Notify the existance of a new peer\n\n    if (!entry) {\n      this._ps.emit('peer', peerId);\n    }\n\n    return this;\n  }\n  /**\n   * Add known addresses of a provided peer.\n   * If the peer is not known, it is set with the given addresses.\n   *\n   * @param {PeerId} peerId\n   * @param {Multiaddr[]} multiaddrs\n   * @returns {AddressBook}\n   */\n\n\n  add(peerId, multiaddrs) {\n    if (!PeerId.isPeerId(peerId)) {\n      log.error('peerId must be an instance of peer-id to store data');\n      throw errcode(new Error('peerId must be an instance of peer-id'), ERR_INVALID_PARAMETERS);\n    }\n\n    const addresses = this._toAddresses(multiaddrs);\n\n    const id = peerId.toB58String();\n    const entry = this.data.get(id);\n\n    if (entry && entry.addresses) {\n      // Add recorded uniquely to the new array (Union)\n      entry.addresses.forEach(addr => {\n        if (!addresses.find(r => r.multiaddr.equals(addr.multiaddr))) {\n          addresses.push(addr);\n        }\n      }); // If the recorded length is equal to the new after the unique union\n      // The content is the same, no need to update.\n\n      if (entry.addresses.length === addresses.length) {\n        log(\"the addresses provided to store are already stored for \".concat(id));\n        return this;\n      }\n    }\n\n    this._setData(peerId, {\n      addresses,\n      record: entry && entry.record\n    });\n\n    log(\"added provided multiaddrs for \".concat(id)); // Notify the existance of a new peer\n\n    if (!(entry && entry.addresses)) {\n      this._ps.emit('peer', peerId);\n    }\n\n    return this;\n  }\n  /**\n   * Get the known data of a provided peer.\n   *\n   * @override\n   * @param {PeerId} peerId\n   * @returns {Address[]|undefined}\n   */\n\n\n  get(peerId) {\n    if (!PeerId.isPeerId(peerId)) {\n      throw errcode(new Error('peerId must be an instance of peer-id'), ERR_INVALID_PARAMETERS);\n    }\n\n    const entry = this.data.get(peerId.toB58String());\n    return entry && entry.addresses ? [...entry.addresses] : undefined;\n  }\n  /**\n   * Transforms received multiaddrs into Address.\n   *\n   * @private\n   * @param {Multiaddr[]} multiaddrs\n   * @param {boolean} [isCertified]\n   * @returns {Address[]}\n   */\n\n\n  _toAddresses(multiaddrs, isCertified = false) {\n    if (!multiaddrs) {\n      log.error('multiaddrs must be provided to store data');\n      throw errcode(new Error('multiaddrs must be provided'), ERR_INVALID_PARAMETERS);\n    } // create Address for each address\n\n\n    const addresses = [];\n    multiaddrs.forEach(addr => {\n      if (!multiaddr.isMultiaddr(addr)) {\n        log.error(\"multiaddr \".concat(addr, \" must be an instance of multiaddr\"));\n        throw errcode(new Error(\"multiaddr \".concat(addr, \" must be an instance of multiaddr\")), ERR_INVALID_PARAMETERS);\n      }\n\n      addresses.push({\n        multiaddr: addr,\n        isCertified\n      });\n    });\n    return addresses;\n  }\n  /**\n   * Get the known multiaddrs for a given peer. All returned multiaddrs\n   * will include the encapsulated `PeerId` of the peer.\n   * Returns `undefined` if there are no known multiaddrs for the given peer.\n   *\n   * @param {PeerId} peerId\n   * @param {(addresses: Address[]) => Address[]} [addressSorter]\n   * @returns {Multiaddr[]|undefined}\n   */\n\n\n  getMultiaddrsForPeer(peerId, addressSorter = ms => ms) {\n    if (!PeerId.isPeerId(peerId)) {\n      throw errcode(new Error('peerId must be an instance of peer-id'), ERR_INVALID_PARAMETERS);\n    }\n\n    const entry = this.data.get(peerId.toB58String());\n\n    if (!entry || !entry.addresses) {\n      return undefined;\n    }\n\n    return addressSorter(entry.addresses || []).map(address => {\n      const multiaddr = address.multiaddr;\n      const idString = multiaddr.getPeerId();\n      if (idString && idString === peerId.toB58String()) return multiaddr;\n      return multiaddr.encapsulate(\"/p2p/\".concat(peerId.toB58String()));\n    });\n  }\n\n}\n\nmodule.exports = AddressBook;","map":null,"metadata":{},"sourceType":"script"}