{"ast":null,"code":"'use strict';\n\nvar _toArray = require(\"/home/ubuntu/Codigo_Javier/client/node_modules/@babel/runtime/helpers/toArray\");\n\nconst isIpfs = require('is-ipfs');\n\nconst CID = require('cids');\n\nconst _require = require('ipfs-core-utils/src/cid'),\n      cidToString = _require.cidToString;\n\nconst withTimeoutOption = require('ipfs-core-utils/src/with-timeout-option');\n/**\n * @param {Object} config\n * @param {import('.').IPLD} config.ipld\n * @param {import('.').Name} config.name - An IPFS core interface name API\n */\n\n\nmodule.exports = ({\n  ipld,\n  name\n}) => {\n  /**\n   * Resolve the value of names to IPFS\n   *\n   * There are a number of mutable name protocols that can link among themselves\n   * and into IPNS. For example IPNS references can (currently) point at an IPFS\n   * object, and DNS links can point at other DNS links, IPNS entries, or IPFS\n   * objects. This command accepts any of these identifiers and resolves them\n   * to the referenced item.\n   *\n   * @param {string} path - The name to resolve\n   * @param {ResolveOptions} [opts]\n   * @returns {Promise<string>} - A string representing the resolved name\n   * @example\n   * ```js\n   * // Resolve the value of your identity:\n   * const name = '/ipns/QmatmE9msSfkKxoffpHwNLNKgwZG8eT9Bud6YoPab52vpy'\n   *\n   * const res = await ipfs.resolve(name)\n   * console.log(res)\n   * // Logs: /ipfs/Qmcqtw8FfrVSBaRmbWwHxt3AuySBhJLcvmFYi3Lbc4xnwj\n   *\n   * // Resolve the value of another name recursively:\n   * const name = '/ipns/QmbCMUZw6JFeZ7Wp9jkzbye3Fzp2GGcPgC3nmeUjfVF87n'\n   *\n   * // Where:\n   * // /ipns/QmbCMUZw6JFeZ7Wp9jkzbye3Fzp2GGcPgC3nmeUjfVF87n\n   * // ...resolves to:\n   * // /ipns/QmatmE9msSfkKxoffpHwNLNKgwZG8eT9Bud6YoPab52vpy\n   * // ...which in turn resolves to:\n   * // /ipfs/Qmcqtw8FfrVSBaRmbWwHxt3AuySBhJLcvmFYi3Lbc4xnwj\n   *\n   * const res = await ipfs.resolve(name, { recursive: true })\n   * console.log(res)\n   * // Logs: /ipfs/Qmcqtw8FfrVSBaRmbWwHxt3AuySBhJLcvmFYi3Lbc4xnwj\n   *\n   * // Resolve the value of an IPFS path:\n   * const name = '/ipfs/QmeZy1fGbwgVSrqbfh9fKQrAWgeyRnj7h8fsHS1oy3k99x/beep/boop'\n   * const res = await ipfs.resolve(name)\n   * console.log(res)\n   * // Logs: /ipfs/QmYRMjyvAiHKN9UTi8Bzt1HUspmSRD8T8DwxfSMzLgBon1\n   * ```\n   */\n  async function resolve(path, opts = {}) {\n    if (!isIpfs.path(path)) {\n      throw new Error('invalid argument ' + path);\n    }\n\n    if (isIpfs.ipnsPath(path)) {\n      if (!name) {\n        throw new Error('failed to resolve IPNS path: name API unavailable');\n      }\n\n      for await (const resolvedPath of name.resolve(path, opts)) {\n        path = resolvedPath;\n      }\n    }\n\n    const _path$split = path.split('/'),\n          _path$split2 = _toArray(_path$split),\n          hash = _path$split2[2],\n          rest = _path$split2.slice(3); // ['', 'ipfs', 'hash', ...path]\n\n\n    const cid = new CID(hash); // nothing to resolve return the input\n\n    if (rest.length === 0) {\n      return \"/ipfs/\".concat(cidToString(cid, {\n        base: opts.cidBase\n      }));\n    }\n\n    path = rest.join('/');\n    const results = ipld.resolve(cid, path);\n    let value = cid;\n    let remainderPath = path;\n\n    for await (const result of results) {\n      if (CID.isCID(result.value)) {\n        value = result.value;\n        remainderPath = result.remainderPath;\n      }\n    }\n\n    return \"/ipfs/\".concat(cidToString(value, {\n      base: opts.cidBase\n    })).concat(remainderPath ? '/' + remainderPath : '');\n  }\n\n  return withTimeoutOption(resolve);\n};\n/**\n * @typedef {ResolveSettings & AbortOptions} ResolveOptions\n *\n * @typedef {Object} ResolveSettings\n * @property {boolean} [recursive=true] - Resolve until result is an IPFS name.\n * @property {import('cids').BaseNameOrCode} [cidBase='base58btc'] - Multibase codec name the CID in the resolved path will be encoded with.\n *\n * @typedef {import('.').AbortOptions} AbortOptions\n */","map":null,"metadata":{},"sourceType":"script"}