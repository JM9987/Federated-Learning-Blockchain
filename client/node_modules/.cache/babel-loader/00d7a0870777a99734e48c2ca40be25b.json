{"ast":null,"code":"/* eslint-disable no-unreachable */\n'use strict';\n\nconst isIpfs = require('is-ipfs');\n\nconst CID = require('cids');\n\nconst Key = require('interface-datastore').Key;\n\nconst errCode = require('err-code');\n\nconst toCidAndPath = require('ipfs-core-utils/src/to-cid-and-path');\n\nconst withTimeoutOption = require('ipfs-core-utils/src/with-timeout-option');\n/** @type {typeof Object.assign} */\n\n\nconst mergeOptions = require('merge-options');\n\nexports.mergeOptions = mergeOptions;\nconst ERR_BAD_PATH = 'ERR_BAD_PATH';\nexports.OFFLINE_ERROR = 'This command must be run in online mode. Try running \\'ipfs daemon\\' first.';\nexports.MFS_ROOT_KEY = new Key('/local/filesroot');\nexports.MFS_MAX_CHUNK_SIZE = 262144;\nexports.MFS_MAX_LINKS = 174;\n/**\n * Returns a well-formed ipfs Path.\n * The returned path will always be prefixed with /ipfs/ or /ipns/.\n *\n * @param  {string} pathStr - An ipfs-path, or ipns-path or a cid\n * @returns {string} - ipfs-path or ipns-path\n * @throws on an invalid @param pathStr\n */\n\nconst normalizePath = pathStr => {\n  if (isIpfs.cid(pathStr)) {\n    return \"/ipfs/\".concat(new CID(pathStr));\n  } else if (isIpfs.path(pathStr)) {\n    return pathStr;\n  } else {\n    throw errCode(new Error(\"invalid path: \".concat(pathStr)), ERR_BAD_PATH);\n  }\n}; // TODO: do we need both normalizePath and normalizeCidPath?\n\n/**\n * @param {Uint8Array|CID|string} path\n * @returns {string}\n */\n\n\nconst normalizeCidPath = path => {\n  if (path instanceof Uint8Array) {\n    return new CID(path).toString();\n  }\n\n  if (CID.isCID(path)) {\n    return path.toString();\n  }\n\n  if (path.indexOf('/ipfs/') === 0) {\n    path = path.substring('/ipfs/'.length);\n  }\n\n  if (path.charAt(path.length - 1) === '/') {\n    path = path.substring(0, path.length - 1);\n  }\n\n  return path;\n};\n/**\n * Resolve various styles of an ipfs-path to the hash of the target node.\n * Follows links in the path.\n *\n * Accepts formats:\n * - <base58 string>\n * - <base58 string>/link/to/venus\n * - /ipfs/<base58 string>/link/to/pluto\n * - multihash Buffer\n *\n * @param {import('./components').DagReader} dag\n * @param {CID | string} ipfsPath - A CID or IPFS path\n * @param {Object} [options] - Optional options passed directly to dag.resolve\n * @returns {Promise<CID>}\n */\n\n\nconst resolvePath = async function (dag, ipfsPath, options = {}) {\n  if (isIpfs.cid(ipfsPath)) {\n    // @ts-ignore - CID|string seems to confuse typedef\n    return new CID(ipfsPath);\n  }\n\n  const _toCidAndPath = toCidAndPath(ipfsPath),\n        cid = _toCidAndPath.cid,\n        path = _toCidAndPath.path;\n\n  if (!path) {\n    return cid;\n  }\n\n  const result = await dag.resolve(cid, { ...options,\n    path\n  });\n  return result.cid;\n};\n/**\n * @typedef {import('ipfs-core-types/src/files').InputFile} InputFile\n * @typedef {import('ipfs-core-types/src/files').UnixFSFile} UnixFSFile\n * @typedef {import('ipfs-core-types/src/files').IPFSEntry} IPFSEntry\n * @typedef {import('ipfs-core-types/src').AbortOptions} AbortOptions\n *\n * @param {InputFile|UnixFSFile} file\n * @param {Object} [options]\n * @param {boolean} [options.includeContent]\n * @returns {IPFSEntry}\n */\n\n\nconst mapFile = (file, options = {}) => {\n  /** @type {IPFSEntry} */\n  const output = {\n    cid: file.cid,\n    path: file.path,\n    name: file.name,\n    depth: file.path.split('/').length,\n    size: 0,\n    type: 'file'\n  };\n\n  if (file.unixfs) {\n    // @ts-ignore - TS type can't be changed from File to Directory\n    output.type = file.unixfs.type === 'directory' ? 'dir' : 'file';\n\n    if (file.unixfs.type === 'file') {\n      output.size = file.unixfs.fileSize();\n\n      if (options.includeContent) {\n        // @ts-expect-error - content is readonly\n        output.content = file.content();\n      }\n    }\n\n    output.mode = file.unixfs.mode;\n    output.mtime = file.unixfs.mtime;\n  }\n\n  return output;\n};\n\nconst withTimeout = withTimeoutOption(\n/**\n * @template T\n * @param {Promise<T>|T} promise\n * @param {AbortOptions} [_options]\n * @returns {Promise<T>}\n */\nasync (promise, _options) => await promise);\nexports.normalizePath = normalizePath;\nexports.normalizeCidPath = normalizeCidPath;\nexports.resolvePath = resolvePath;\nexports.mapFile = mapFile;\nexports.withTimeoutOption = withTimeoutOption;\nexports.withTimeout = withTimeout;","map":null,"metadata":{},"sourceType":"script"}