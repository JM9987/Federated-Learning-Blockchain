{"ast":null,"code":"'use strict';\n\nconst debug = require('debug');\n\nconst log = Object.assign(debug('libp2p:circuit:hop'), {\n  error: debug('libp2p:circuit:hop:err')\n});\n\nconst errCode = require('err-code');\n\nconst PeerId = require('peer-id');\n\nconst _require = require('./utils'),\n      validateAddrs = _require.validateAddrs;\n\nconst StreamHandler = require('./stream-handler');\n\nconst _require2 = require('../protocol'),\n      CircuitPB = _require2.CircuitRelay;\n\nconst _require3 = require('it-pipe'),\n      pipe = _require3.pipe;\n\nconst _require4 = require('../../errors'),\n      Errors = _require4.codes;\n\nconst _require5 = require('./stop'),\n      stop = _require5.stop;\n\nconst multicodec = require('./../multicodec');\n/**\n * @typedef {import('../../types').CircuitRequest} CircuitRequest\n * @typedef {import('libp2p-interfaces/src/connection').Connection} Connection\n * @typedef {import('./stream-handler')<CircuitRequest>} StreamHandlerT\n * @typedef {import('../transport')} Transport\n */\n\n/**\n * @typedef {Object} HopRequest\n * @property {Connection} connection\n * @property {CircuitRequest} request\n * @property {StreamHandlerT} streamHandler\n * @property {Transport} circuit\n */\n\n/**\n * @param {HopRequest} options\n * @returns {Promise<void>}\n */\n\n\nasync function handleHop({\n  connection,\n  request,\n  streamHandler,\n  circuit\n}) {\n  // Ensure hop is enabled\n  if (!circuit._options.hop.enabled) {\n    log('HOP request received but we are not acting as a relay');\n    return streamHandler.end({\n      type: CircuitPB.Type.STATUS,\n      code: CircuitPB.Status.HOP_CANT_SPEAK_RELAY\n    });\n  } // Validate the HOP request has the required input\n\n\n  try {\n    validateAddrs(request, streamHandler);\n  } catch (err) {\n    return log.error('invalid hop request via peer %s', connection.remotePeer.toB58String(), err);\n  } // Get the connection to the destination (stop) peer\n\n\n  const destinationPeer = new PeerId(request.dstPeer.id);\n\n  const destinationConnection = circuit._connectionManager.get(destinationPeer);\n\n  if (!destinationConnection && !circuit._options.hop.active) {\n    log('HOP request received but we are not connected to the destination peer');\n    return streamHandler.end({\n      type: CircuitPB.Type.STATUS,\n      code: CircuitPB.Status.HOP_NO_CONN_TO_DST\n    });\n  } // TODO: Handle being an active relay\n\n\n  if (!destinationConnection) {\n    return;\n  } // Handle the incoming HOP request by performing a STOP request\n\n\n  const stopRequest = {\n    type: CircuitPB.Type.STOP,\n    dstPeer: request.dstPeer,\n    srcPeer: request.srcPeer\n  };\n  let destinationStream;\n\n  try {\n    destinationStream = await stop({\n      connection: destinationConnection,\n      request: stopRequest\n    });\n  } catch (err) {\n    return log.error(err);\n  }\n\n  log('hop request from %s is valid', connection.remotePeer.toB58String());\n  streamHandler.write({\n    type: CircuitPB.Type.STATUS,\n    code: CircuitPB.Status.SUCCESS\n  });\n  const sourceStream = streamHandler.rest(); // Short circuit the two streams to create the relayed connection\n\n  return pipe(sourceStream, destinationStream, sourceStream);\n}\n/**\n * Performs a HOP request to a relay peer, to request a connection to another\n * peer. A new, virtual, connection will be created between the two via the relay.\n *\n * @param {object} options\n * @param {Connection} options.connection - Connection to the relay\n * @param {CircuitRequest} options.request\n * @returns {Promise<Connection>}\n */\n\n\nasync function hop({\n  connection,\n  request\n}) {\n  // Create a new stream to the relay\n  const _ref = await connection.newStream([multicodec.relay]),\n        stream = _ref.stream; // Send the HOP request\n\n\n  const streamHandler = new StreamHandler({\n    stream\n  });\n  streamHandler.write(request);\n  const response = await streamHandler.read();\n\n  if (response.code === CircuitPB.Status.SUCCESS) {\n    log('hop request was successful');\n    return streamHandler.rest();\n  }\n\n  log('hop request failed with code %d, closing stream', response.code);\n  streamHandler.close();\n  throw errCode(new Error(\"HOP request failed with code \".concat(response.code)), Errors.ERR_HOP_REQUEST_FAILED);\n}\n/**\n * Performs a CAN_HOP request to a relay peer, in order to understand its capabilities.\n *\n * @param {object} options\n * @param {Connection} options.connection - Connection to the relay\n * @returns {Promise<boolean>}\n */\n\n\nasync function canHop({\n  connection\n}) {\n  // Create a new stream to the relay\n  const _ref2 = await connection.newStream([multicodec.relay]),\n        stream = _ref2.stream; // Send the HOP request\n\n\n  const streamHandler = new StreamHandler({\n    stream\n  });\n  streamHandler.write({\n    type: CircuitPB.Type.CAN_HOP\n  });\n  const response = await streamHandler.read();\n  await streamHandler.close();\n\n  if (response.code !== CircuitPB.Status.SUCCESS) {\n    return false;\n  }\n\n  return true;\n}\n/**\n * Creates an unencoded CAN_HOP response based on the Circuits configuration\n *\n * @param {Object} options\n * @param {Connection} options.connection\n * @param {StreamHandlerT} options.streamHandler\n * @param {Transport} options.circuit\n * @private\n */\n\n\nfunction handleCanHop({\n  connection,\n  streamHandler,\n  circuit\n}) {\n  const canHop = circuit._options.hop.enabled;\n  log('can hop (%s) request from %s', canHop, connection.remotePeer.toB58String());\n  streamHandler.end({\n    type: CircuitPB.Type.STATUS,\n    code: canHop ? CircuitPB.Status.SUCCESS : CircuitPB.Status.HOP_CANT_SPEAK_RELAY\n  });\n}\n\nmodule.exports = {\n  handleHop,\n  hop,\n  canHop,\n  handleCanHop\n};","map":null,"metadata":{},"sourceType":"script"}