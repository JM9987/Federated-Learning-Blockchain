{"ast":null,"code":"'use strict';\n\nconst toUri = require('multiaddr-to-uri');\n\nconst debug = require('debug');\n\nconst CID = require('cids');\n\nconst shuffle = require('array-shuffle');\n\nconst _require = require('native-abort-controller'),\n      AbortController = _require.AbortController;\n\nconst preload = require('./runtime/preload-nodejs');\n/** @type {typeof import('hashlru').default} */\n// @ts-ignore - hashlru has incorrect typedefs\n\n\nconst hashlru = require('hashlru');\n\nconst log = Object.assign(debug('ipfs:preload'), {\n  error: debug('ipfs:preload:error')\n});\n/**\n * @param {Options & AbortOptions} [options]\n */\n\nconst createPreloader = (options = {}) => {\n  options.enabled = Boolean(options.enabled);\n  options.addresses = options.addresses || [];\n  options.cache = options.cache || 1000;\n\n  if (!options.enabled || !options.addresses.length) {\n    log('preload disabled');\n\n    const api = () => {};\n\n    return Object.assign(api, {\n      start: () => {},\n      stop: () => {}\n    });\n  }\n\n  let stopped = true;\n  let requests = [];\n  const apiUris = options.addresses.map(toUri); // Avoid preloading the same CID over and over again\n\n  const cache = hashlru(options.cache);\n  /**\n   * @param {string|CID} path\n   * @returns {Promise<void>}\n   */\n\n  const api = async path => {\n    try {\n      if (stopped) throw new Error(\"preload \".concat(path, \" but preloader is not started\"));\n\n      if (typeof path !== 'string') {\n        path = new CID(path).toString();\n      }\n\n      if (cache.has(path)) {\n        // we've preloaded this recently, don't preload it again\n        return;\n      } // make sure we don't preload this again any time soon\n\n\n      cache.set(path, true);\n      const fallbackApiUris = shuffle(apiUris);\n      let success = false;\n      const now = Date.now();\n\n      for (const uri of fallbackApiUris) {\n        if (stopped) throw new Error(\"preload aborted for \".concat(path));\n        let controller;\n\n        try {\n          controller = new AbortController();\n          requests = requests.concat(controller);\n          await preload(\"\".concat(uri, \"/api/v0/refs?r=true&arg=\").concat(encodeURIComponent(path)), {\n            signal: controller.signal\n          });\n          success = true;\n        } catch (err) {\n          if (err.type !== 'aborted') log.error(err);\n        } finally {\n          requests = requests.filter(r => r !== controller);\n        }\n\n        if (success) break;\n      }\n\n      log(\"\".concat(success ? '' : 'un', \"successfully preloaded \").concat(path, \" in \").concat(Date.now() - now, \"ms\"));\n    } catch (err) {\n      log.error(err);\n    }\n  };\n  /**\n   * @returns {void}\n   */\n\n\n  api.start = () => {\n    stopped = false;\n  };\n  /**\n   * @returns {void}\n   */\n\n\n  api.stop = () => {\n    stopped = true;\n    log(\"aborting \".concat(requests.length, \" pending preload request(s)\"));\n    requests.forEach(r => r.abort());\n    requests = [];\n  };\n\n  return api;\n};\n\nmodule.exports = createPreloader;\n/**\n * @typedef {ReturnType<typeof createPreloader>} Preload\n *\n * @typedef {object} Options\n * @property {boolean} [enabled = false] - Whether to preload anything\n * @property {number} [cache = 1000] - How many CIDs to cache\n * @property {string[]} [addresses = []] - Which preload servers to use.\n * **NOTE:** nodes specified here should also be added to your node's bootstrap address list at `config.Boostrap`.\n *\n * @typedef {import('./components').AbortOptions} AbortOptions\n */","map":null,"metadata":{},"sourceType":"script"}