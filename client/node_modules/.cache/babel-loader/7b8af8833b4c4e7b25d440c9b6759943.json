{"ast":null,"code":"'use strict';\n\nconst errCode = require('err-code');\n\nconst uint8arraysConcat = require('uint8arrays/concat');\n\nconst uint8arraysFromString = require('uint8arrays/from-string');\n\nconst cryptoKeys = require('libp2p-crypto/src/keys');\n\nconst PeerId = require('peer-id');\n\nconst varint = require('varint');\n\nconst uint8arraysEquals = require('uint8arrays/equals');\n\nconst _require = require('../../errors'),\n      codes = _require.codes;\n\nconst Protobuf = require('./envelope.proto');\n/**\n * @typedef {import('libp2p-interfaces/src/record/types').Record} Record\n */\n\n\nclass Envelope {\n  /**\n   * The Envelope is responsible for keeping an arbitrary signed record\n   * by a libp2p peer.\n   *\n   * @class\n   * @param {object} params\n   * @param {PeerId} params.peerId\n   * @param {Uint8Array} params.payloadType\n   * @param {Uint8Array} params.payload - marshaled record\n   * @param {Uint8Array} params.signature - signature of the domain string :: type hint :: payload.\n   */\n  constructor({\n    peerId,\n    payloadType,\n    payload,\n    signature\n  }) {\n    this.peerId = peerId;\n    this.payloadType = payloadType;\n    this.payload = payload;\n    this.signature = signature; // Cache\n\n    this._marshal = undefined;\n  }\n  /**\n   * Marshal the envelope content.\n   *\n   * @returns {Uint8Array}\n   */\n\n\n  marshal() {\n    if (this._marshal) {\n      return this._marshal;\n    }\n\n    const publicKey = cryptoKeys.marshalPublicKey(this.peerId.pubKey);\n    this._marshal = Protobuf.Envelope.encode({\n      public_key: publicKey,\n      payload_type: this.payloadType,\n      payload: this.payload,\n      signature: this.signature\n    });\n    return this._marshal;\n  }\n  /**\n   * Verifies if the other Envelope is identical to this one.\n   *\n   * @param {Envelope} other\n   * @returns {boolean}\n   */\n\n\n  equals(other) {\n    return uint8arraysEquals(this.peerId.pubKey.bytes, other.peerId.pubKey.bytes) && uint8arraysEquals(this.payloadType, other.payloadType) && uint8arraysEquals(this.payload, other.payload) && uint8arraysEquals(this.signature, other.signature);\n  }\n  /**\n   * Validate envelope data signature for the given domain.\n   *\n   * @param {string} domain\n   * @returns {Promise<boolean>}\n   */\n\n\n  validate(domain) {\n    const signData = formatSignaturePayload(domain, this.payloadType, this.payload);\n    return this.peerId.pubKey.verify(signData, this.signature);\n  }\n\n}\n/**\n * Helper function that prepares a Uint8Array to sign or verify a signature.\n *\n * @param {string} domain\n * @param {Uint8Array} payloadType\n * @param {Uint8Array} payload\n * @returns {Uint8Array}\n */\n\n\nconst formatSignaturePayload = (domain, payloadType, payload) => {\n  // When signing, a peer will prepare a Uint8Array by concatenating the following:\n  // - The length of the domain separation string string in bytes\n  // - The domain separation string, encoded as UTF-8\n  // - The length of the payload_type field in bytes\n  // - The value of the payload_type field\n  // - The length of the payload field in bytes\n  // - The value of the payload field\n  const domainUint8Array = uint8arraysFromString(domain);\n  const domainLength = varint.encode(domainUint8Array.byteLength);\n  const payloadTypeLength = varint.encode(payloadType.length);\n  const payloadLength = varint.encode(payload.length);\n  return uint8arraysConcat([new Uint8Array(domainLength), domainUint8Array, new Uint8Array(payloadTypeLength), payloadType, new Uint8Array(payloadLength), payload]);\n};\n/**\n * Unmarshal a serialized Envelope protobuf message.\n *\n * @param {Uint8Array} data\n * @returns {Promise<Envelope>}\n */\n\n\nEnvelope.createFromProtobuf = async data => {\n  const envelopeData = Protobuf.Envelope.decode(data);\n  const peerId = await PeerId.createFromPubKey(envelopeData.public_key);\n  return new Envelope({\n    peerId,\n    payloadType: envelopeData.payload_type,\n    payload: envelopeData.payload,\n    signature: envelopeData.signature\n  });\n};\n/**\n * Seal marshals the given Record, places the marshaled bytes inside an Envelope\n * and signs it with the given peerId's private key.\n *\n * @async\n * @param {Record} record\n * @param {PeerId} peerId\n * @returns {Promise<Envelope>}\n */\n\n\nEnvelope.seal = async (record, peerId) => {\n  const domain = record.domain;\n  const payloadType = record.codec;\n  const payload = record.marshal();\n  const signData = formatSignaturePayload(domain, payloadType, payload);\n  const signature = await peerId.privKey.sign(signData);\n  return new Envelope({\n    peerId,\n    payloadType,\n    payload,\n    signature\n  });\n};\n/**\n * Open and certify a given marshalled envelope.\n * Data is unmarshalled and the signature validated for the given domain.\n *\n * @param {Uint8Array} data\n * @param {string} domain\n * @returns {Promise<Envelope>}\n */\n\n\nEnvelope.openAndCertify = async (data, domain) => {\n  const envelope = await Envelope.createFromProtobuf(data);\n  const valid = await envelope.validate(domain);\n\n  if (!valid) {\n    throw errCode(new Error('envelope signature is not valid for the given domain'), codes.ERR_SIGNATURE_NOT_VALID);\n  }\n\n  return envelope;\n};\n\nmodule.exports = Envelope;","map":null,"metadata":{},"sourceType":"script"}