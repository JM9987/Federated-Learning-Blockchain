{"ast":null,"code":"\"use strict\";\n\nvar _slicedToArray = require(\"/home/ubuntu/Codigo_Javier/client/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.AbstractHandshake = exports.MIN_NONCE = void 0;\n\nconst buffer_1 = require(\"buffer\");\n\nconst aead_1 = __importDefault(require(\"bcrypto/lib/js/aead\"));\n\nconst x25519_1 = __importDefault(require(\"bcrypto/lib/js/x25519\"));\n\nconst sha256_1 = __importDefault(require(\"bcrypto/lib/js/sha256\"));\n\nconst utils_1 = require(\"../utils\");\n\nconst logger_1 = require(\"../logger\");\n\nexports.MIN_NONCE = 0;\n\nclass AbstractHandshake {\n  encryptWithAd(cs, ad, plaintext) {\n    const e = this.encrypt(cs.k, cs.n, ad, plaintext);\n    this.setNonce(cs, this.incrementNonce(cs.n));\n    return e;\n  }\n\n  decryptWithAd(cs, ad, ciphertext) {\n    const _this$decrypt = this.decrypt(cs.k, cs.n, ad, ciphertext),\n          plaintext = _this$decrypt.plaintext,\n          valid = _this$decrypt.valid;\n\n    this.setNonce(cs, this.incrementNonce(cs.n));\n    return {\n      plaintext,\n      valid\n    };\n  } // Cipher state related\n\n\n  hasKey(cs) {\n    return !this.isEmptyKey(cs.k);\n  }\n\n  setNonce(cs, nonce) {\n    cs.n = nonce;\n  }\n\n  createEmptyKey() {\n    return buffer_1.Buffer.alloc(32);\n  }\n\n  isEmptyKey(k) {\n    const emptyKey = this.createEmptyKey();\n    return emptyKey.equals(k);\n  }\n\n  incrementNonce(n) {\n    return n + 1;\n  }\n\n  nonceToBytes(n) {\n    const nonce = buffer_1.Buffer.alloc(12);\n    nonce.writeUInt32LE(n, 4);\n    return nonce;\n  }\n\n  encrypt(k, n, ad, plaintext) {\n    const nonce = this.nonceToBytes(n);\n    const ctx = new aead_1.default();\n    plaintext = buffer_1.Buffer.from(plaintext);\n    ctx.init(k, nonce);\n    ctx.aad(ad);\n    ctx.encrypt(plaintext); // Encryption is done on the sent reference\n\n    return buffer_1.Buffer.concat([plaintext, ctx.final()]);\n  }\n\n  encryptAndHash(ss, plaintext) {\n    let ciphertext;\n\n    if (this.hasKey(ss.cs)) {\n      ciphertext = this.encryptWithAd(ss.cs, ss.h, plaintext);\n    } else {\n      ciphertext = plaintext;\n    }\n\n    this.mixHash(ss, ciphertext);\n    return ciphertext;\n  }\n\n  decrypt(k, n, ad, ciphertext) {\n    const nonce = this.nonceToBytes(n);\n    const ctx = new aead_1.default();\n    ciphertext = buffer_1.Buffer.from(ciphertext);\n    const tag = ciphertext.slice(ciphertext.length - 16);\n    ciphertext = ciphertext.slice(0, ciphertext.length - 16);\n    ctx.init(k, nonce);\n    ctx.aad(ad);\n    ctx.decrypt(ciphertext); // Decryption is done on the sent reference\n\n    return {\n      plaintext: ciphertext,\n      valid: ctx.verify(tag)\n    };\n  }\n\n  decryptAndHash(ss, ciphertext) {\n    let plaintext;\n    let valid = true;\n\n    if (this.hasKey(ss.cs)) {\n      var _this$decryptWithAd = this.decryptWithAd(ss.cs, ss.h, ciphertext);\n\n      plaintext = _this$decryptWithAd.plaintext;\n      valid = _this$decryptWithAd.valid;\n    } else {\n      plaintext = ciphertext;\n    }\n\n    this.mixHash(ss, ciphertext);\n    return {\n      plaintext,\n      valid\n    };\n  }\n\n  dh(privateKey, publicKey) {\n    try {\n      const derived = x25519_1.default.derive(publicKey, privateKey);\n      const result = buffer_1.Buffer.alloc(32);\n      derived.copy(result);\n      return result;\n    } catch (e) {\n      logger_1.logger(e.message);\n      return buffer_1.Buffer.alloc(32);\n    }\n  }\n\n  mixHash(ss, data) {\n    ss.h = this.getHash(ss.h, data);\n  }\n\n  getHash(a, b) {\n    return sha256_1.default.digest(buffer_1.Buffer.from([...a, ...b]));\n  }\n\n  mixKey(ss, ikm) {\n    const _utils_1$getHkdf = utils_1.getHkdf(ss.ck, ikm),\n          _utils_1$getHkdf2 = _slicedToArray(_utils_1$getHkdf, 2),\n          ck = _utils_1$getHkdf2[0],\n          tempK = _utils_1$getHkdf2[1];\n\n    ss.cs = this.initializeKey(tempK);\n    ss.ck = ck;\n  }\n\n  initializeKey(k) {\n    const n = exports.MIN_NONCE;\n    return {\n      k,\n      n\n    };\n  } // Symmetric state related\n\n\n  initializeSymmetric(protocolName) {\n    const protocolNameBytes = buffer_1.Buffer.from(protocolName, 'utf-8');\n    const h = this.hashProtocolName(protocolNameBytes);\n    const ck = h;\n    const key = this.createEmptyKey();\n    const cs = this.initializeKey(key);\n    return {\n      cs,\n      ck,\n      h\n    };\n  }\n\n  hashProtocolName(protocolName) {\n    if (protocolName.length <= 32) {\n      const h = buffer_1.Buffer.alloc(32);\n      protocolName.copy(h);\n      return h;\n    } else {\n      return this.getHash(protocolName, buffer_1.Buffer.alloc(0));\n    }\n  }\n\n  split(ss) {\n    const _utils_1$getHkdf3 = utils_1.getHkdf(ss.ck, buffer_1.Buffer.alloc(0)),\n          _utils_1$getHkdf4 = _slicedToArray(_utils_1$getHkdf3, 2),\n          tempk1 = _utils_1$getHkdf4[0],\n          tempk2 = _utils_1$getHkdf4[1];\n\n    const cs1 = this.initializeKey(tempk1);\n    const cs2 = this.initializeKey(tempk2);\n    return {\n      cs1,\n      cs2\n    };\n  }\n\n  writeMessageRegular(cs, payload) {\n    const ciphertext = this.encryptWithAd(cs, buffer_1.Buffer.alloc(0), payload);\n    const ne = this.createEmptyKey();\n    const ns = buffer_1.Buffer.alloc(0);\n    return {\n      ne,\n      ns,\n      ciphertext\n    };\n  }\n\n  readMessageRegular(cs, message) {\n    return this.decryptWithAd(cs, buffer_1.Buffer.alloc(0), message.ciphertext);\n  }\n\n}\n\nexports.AbstractHandshake = AbstractHandshake;","map":null,"metadata":{},"sourceType":"script"}