{"ast":null,"code":"'use strict';\n\nconst PeerId = require('peer-id');\n\nconst CID = require('cids');\n\nconst errCode = require('err-code');\n\nconst _require = require('../errors'),\n      NotEnabledError = _require.NotEnabledError;\n\nconst get = require('dlv');\n\nconst withTimeoutOption = require('ipfs-core-utils/src/with-timeout-option');\n/**\n * @param {Object} config\n * @param {import('.').NetworkService} config.network\n * @param {import('.').Repo} config.repo\n */\n\n\nmodule.exports = ({\n  network,\n  repo\n}) => {\n  const _get$put$findProvs$fi = {\n    /**\n     * Given a key, query the DHT for its best value.\n     *\n     * @param {Uint8Array|string} key\n     * @param {AbortOptions} [options] - The key associated with the value to find\n     * @returns {Promise<Uint8Array>}\n     */\n    async get(key, options = {}) {\n      const _ref = await use(network, options),\n            libp2p = _ref.libp2p;\n\n      return libp2p._dht.get(normalizeCID(key), options);\n    },\n\n    /**\n     * Write a key/value pair to the DHT.\n     *\n     * Given a key of the form /foo/bar and a value of any\n     * form, this will write that value to the DHT with\n     * that key.\n     *\n     * @param {Uint8Array} key\n     * @param {Uint8Array} value\n     * @param {AbortOptions} [options]\n     * @returns {AsyncIterable<QueryEvent>}\n     */\n    async *put(key, value, options) {\n      const _ref2 = await use(network, options),\n            libp2p = _ref2.libp2p;\n\n      yield* libp2p._dht.put(normalizeCID(key), value);\n    },\n\n    /**\n     * Find peers in the DHT that can provide a specific value, given a CID.\n     *\n     * @param {CID} cid - They key to find providers for.\n     * @param {FindProvsOptions & AbortOptions} [options] - findProviders options\n     * @returns {AsyncIterable<PeerInfo>}\n     *\n     * @example\n     * ```js\n     * const providers = ipfs.dht.findProvs('QmdPAhQRxrDKqkGPvQzBvjYe3kU8kiEEAd2J6ETEamKAD9')\n     * for await (const provider of providers) {\n     *   console.log(provider.id.toString())\n     * }\n     * ```\n     */\n    async *findProvs(cid, options = {}) {\n      const _ref3 = await use(network, options),\n            libp2p = _ref3.libp2p;\n\n      if (options.numProviders) {\n        options.maxNumProviders = options.numProviders;\n      }\n\n      for await (const peer of libp2p._dht.findProviders(normalizeCID(cid), options)) {\n        yield {\n          id: peer.id.toB58String(),\n          addrs: peer.addrs\n        };\n      }\n    },\n\n    /**\n     * Query the DHT for all multiaddresses associated with a `PeerId`.\n     *\n     * @param {PeerId|CID} peerId - The id of the peer to search for.\n     * @param {AbortOptions} [options]\n     * @returns {Promise<{id: string, addrs: Multiaddr[]}>}\n     * @example\n     * ```js\n     * const info = await ipfs.dht.findPeer('QmcZf59bWwK5XFi76CZX8cbJ4BhTzzA3gU1ZjYZcYW3dwt')\n     *\n     * console.log(info.id)\n     * // QmcZf59bWwK5XFi76CZX8cbJ4BhTzzA3gU1ZjYZcYW3dwt\n     *\n     * info.addrs.forEach(addr => console.log(addr.toString()))\n     * // '/ip4/147.75.94.115/udp/4001/quic'\n     * // '/ip6/2604:1380:3000:1f00::1/udp/4001/quic'\n     * // '/dnsaddr/bootstrap.libp2p.io'\n     * // '/ip6/2604:1380:3000:1f00::1/tcp/4001'\n     * // '/ip4/147.75.94.115/tcp/4001'\n     * ```\n     */\n    async findPeer(peerId, options) {\n      const _ref4 = await use(network, options),\n            libp2p = _ref4.libp2p;\n\n      if (typeof peerId === 'string') {\n        peerId = PeerId.createFromCID(peerId);\n      }\n\n      const peer = await libp2p._dht.findPeer(peerId);\n      return {\n        id: peer.id.toB58String(),\n        addrs: peer.multiaddrs\n      };\n    },\n\n    /**\n     * Announce to the network that we are providing given values.\n     *\n     * @param {CID|CID[]} cids - The keys that should be announced.\n     * @param {ProvideOptions & AbortOptions} [options] - provide options\n     * @returns {AsyncIterable<QueryEvent>}\n     */\n    async *provide(cids, options = {}) {\n      const _ref5 = await use(network, options),\n            libp2p = _ref5.libp2p;\n\n      cids = Array.isArray(cids) ? cids : [cids];\n\n      for (const i in cids) {\n        if (typeof cids[i] === 'string') {\n          try {\n            cids[i] = new CID(cids[i]);\n          } catch (err) {\n            throw errCode(err, 'ERR_INVALID_CID');\n          }\n        }\n      } // ensure blocks are actually local\n\n\n      const hasCids = await Promise.all(cids.map(cid => repo.blocks.has(cid)));\n      const hasAll = hasCids.every(has => has);\n\n      if (!hasAll) {\n        throw errCode(new Error('block(s) not found locally, cannot provide'), 'ERR_BLOCK_NOT_FOUND');\n      }\n\n      if (options.recursive) {\n        // TODO: Implement recursive providing\n        throw errCode(new Error('not implemented yet'), 'ERR_NOT_IMPLEMENTED_YET');\n      }\n\n      for (const cid of cids) {\n        yield libp2p._dht.provide(cid);\n      }\n    },\n\n    /**\n     * Find the closest peers to a given `PeerId`, by querying the DHT.\n     *\n     * @param {string|PeerId} peerId - The `PeerId` to run the query against.\n     * @param {AbortOptions} [options]\n     * @returns {AsyncIterable<{ id: CID, addrs: Multiaddr[] }>}\n     */\n    async *query(peerId, options) {\n      const _ref6 = await use(network, options),\n            libp2p = _ref6.libp2p;\n\n      if (typeof peerId === 'string') {\n        peerId = PeerId.createFromCID(peerId);\n      }\n\n      for await (const closerPeerId of libp2p._dht.getClosestPeers(peerId.toBytes())) {\n        yield {\n          id: closerPeerId.toB58String(),\n          addrs: [] // TODO: get addrs?\n\n        };\n      }\n    }\n\n  },\n        get = _get$put$findProvs$fi.get,\n        put = _get$put$findProvs$fi.put,\n        findProvs = _get$put$findProvs$fi.findProvs,\n        findPeer = _get$put$findProvs$fi.findPeer,\n        provide = _get$put$findProvs$fi.provide,\n        query = _get$put$findProvs$fi.query;\n  return {\n    get: withTimeoutOption(get),\n    put: withTimeoutOption(put),\n    findProvs: withTimeoutOption(findProvs),\n    findPeer: withTimeoutOption(findPeer),\n    provide: withTimeoutOption(provide),\n    query: withTimeoutOption(query)\n  };\n};\n/**\n * Turns given cid in some stringifyeable represenation, to Uint8Array\n * representation. Throws an error if given value isn't a vaild CID.\n *\n * @param {any} cid\n * @returns {Uint8Array}\n */\n\n\nconst parseCID = cid => {\n  try {\n    const cidStr = cid.toString().split('/').filter(part => part && part !== 'ipfs' && part !== 'ipns')[0];\n    return new CID(cidStr).bytes;\n  } catch (error) {\n    throw errCode(error, 'ERR_INVALID_CID');\n  }\n};\n/**\n * Turns given cid in some represenation to Uint8Array reperesentation.\n *\n * @param {any} cid\n */\n\n\nconst normalizeCID = cid => cid instanceof Uint8Array ? cid : parseCID(cid);\n/**\n * @param {import('.').NetworkService} network\n * @param {AbortOptions} [options]\n */\n\n\nconst use = async (network, options) => {\n  const net = await network.use(options);\n\n  if (get(net.libp2p, '_config.dht.enabled', false)) {\n    return net;\n  } else {\n    throw new NotEnabledError('dht not enabled');\n  }\n};\n/**\n * @typedef {Object} QueryEvent\n * @property {PeerId} id\n * @property {number} type\n * @property {string} extra\n * @property {PeerInfo[]} responses\n *\n * @typedef {Object} ProvideOptions\n * @property {boolean} [recursive=false] - Provide not only the given object but also all objects linked from it.\n *\n * @typedef {Object} FindProvsOptions\n * @property {number} [numProviders] - maximum number of providers to find\n * @property {number} [maxNumProviders]\n *\n * @typedef {Object} PeerInfo\n * @property {PeerId} id\n * @property {Multiaddr[]} addrs\n *\n * @typedef {import('multiaddr')} Multiaddr\n * @typedef {import('../utils').AbortOptions} AbortOptions\n */","map":null,"metadata":{},"sourceType":"script"}