{"ast":null,"code":"'use strict';\n\nconst log = require('debug')('ipfs:components:peer:storage');\n\nconst createRepo = require('../runtime/repo-nodejs');\n\nconst getDefaultConfig = require('../runtime/config-nodejs');\n\nconst ERR_REPO_NOT_INITIALIZED = require('ipfs-repo').errors.ERR_REPO_NOT_INITIALIZED;\n\nconst uint8ArrayFromString = require('uint8arrays/from-string');\n\nconst uint8ArrayToString = require('uint8arrays/to-string');\n\nconst PeerId = require('peer-id');\n\nconst _require = require('../utils'),\n      mergeOptions = _require.mergeOptions;\n\nconst configService = require('./config');\n\nconst _require2 = require('../errors'),\n      NotEnabledError = _require2.NotEnabledError;\n\nconst createLibP2P = require('./libp2p');\n\nclass Storage {\n  /**\n   * @private\n   * @param {PeerId} peerId\n   * @param {Keychain} keychain\n   * @param {Repo} repo\n   * @param {Print} print\n   * @param {boolean} isNew\n   */\n  constructor(peerId, keychain, repo, print, isNew) {\n    this.print = print;\n    this.peerId = peerId;\n    this.keychain = keychain;\n    this.repo = repo;\n    this.print = print;\n    this.isNew = isNew;\n  }\n  /**\n   *\n   * @param {Options} options\n   */\n\n\n  static async start(options) {\n    const autoMigrate = options.repoAutoMigrate,\n          inputRepo = options.repo,\n          print = options.print,\n          silent = options.silent;\n    const repo = typeof inputRepo === 'string' || inputRepo == null ? createRepo({\n      path: inputRepo,\n      autoMigrate,\n      silent\n    }) : inputRepo;\n\n    const _ref = await loadRepo(repo, options),\n          peerId = _ref.peerId,\n          keychain = _ref.keychain,\n          isNew = _ref.isNew; // TODO: throw error?\n    // @ts-ignore On start, keychain will always be available\n\n\n    return new Storage(peerId, keychain, repo, print, isNew);\n  }\n\n}\n\nmodule.exports = Storage;\n/**\n *\n * @param {Repo} repo\n * @param {RepoOptions & InitOptions} options\n * @returns {Promise<{peerId: PeerId, keychain?: Keychain, isNew:boolean }>}\n */\n\nconst loadRepo = async (repo, options) => {\n  const openError = await openRepo(repo);\n\n  if (openError == null) {\n    // If opened successfully configure repo\n    return { ...(await configureRepo(repo, options)),\n      isNew: false\n    };\n  } else if (openError.code === ERR_REPO_NOT_INITIALIZED) {\n    if (options.allowNew === false) {\n      throw new NotEnabledError('Initialization of new repos disabled by config, pass `config.init.isNew: true` to enable it');\n    } else {\n      // If failed to open, because repo isn't initilaized and initalizing a\n      // new repo allowed, init repo:\n      return { ...(await initRepo(repo, options)),\n        isNew: true\n      };\n    }\n  } else {\n    throw openError;\n  }\n};\n/**\n * Attempts to open given repo unless it is already open and returns result\n * containing repo or an error if failed.\n *\n * @param {Repo} repo\n * @returns {Promise<(Error & { code: number }) | null>}\n */\n\n\nconst openRepo = async repo => {\n  // If repo is closed attempt to open it.\n  if (repo.closed) {\n    try {\n      await repo.open();\n      return null;\n    } catch (error) {\n      return error;\n    }\n  } else {\n    return null;\n  }\n};\n/**\n * @param {Repo} repo\n * @param {RepoOptions & InitOptions} options\n * @returns {Promise<{peerId: PeerId, keychain?: Keychain}>}\n */\n\n\nconst initRepo = async (repo, options) => {\n  // 1. Verify that repo does not exist yet (if it does and we could not\n  // open it we give up)\n  const exists = await repo.exists();\n  log('repo exists?', exists);\n\n  if (exists === true) {\n    throw new Error('repo already exists');\n  } // 2. Restore `peerId` from a given `.privateKey` or init new using\n  // provide options.\n\n\n  const peerId = options.privateKey ? await decodePeerId(options.privateKey) : await initPeerId(options);\n  const identity = peerIdToIdentity(peerId);\n  log('peer identity: %s', identity.PeerID); // 3. Init new repo with provided `.config` and restored / initalized\n  // peerd identity.\n\n  const config = { ...mergeOptions(applyProfiles(getDefaultConfig(), options.profiles), options.config),\n    Identity: identity\n  };\n  await repo.init(config); // 4. Open initalized repo.\n\n  await repo.open();\n  log('repo opened'); // Create libp2p for Keychain creation\n\n  const libp2p = createLibP2P({\n    options: undefined,\n    multiaddrs: undefined,\n    peerId,\n    repo,\n    config,\n    keychainConfig: {\n      pass: options.pass\n    }\n  });\n\n  if (libp2p.keychain && libp2p.keychain.opts) {\n    await libp2p.loadKeychain();\n    await repo.config.set('Keychain', {\n      dek: libp2p.keychain.opts.dek\n    });\n  }\n\n  return {\n    peerId,\n    keychain: libp2p.keychain\n  };\n};\n/**\n * Takes `peerId` either represented as a string serialized string or\n * an instance and returns a `PeerId` instance.\n *\n * @param {PeerId|string} peerId\n * @returns {Promise<PeerId>|PeerId}\n */\n\n\nconst decodePeerId = peerId => {\n  log('using user-supplied private-key');\n  return typeof peerId === 'object' ? peerId : PeerId.createFromPrivKey(uint8ArrayFromString(peerId, 'base64pad'));\n};\n/**\n * Initializes new PeerId by generting an underlying keypair.\n *\n * @param {Object} options\n * @param {KeyType} [options.algorithm='RSA']\n * @param {number} [options.bits=2048]\n * @param {Print} options.print\n * @returns {Promise<PeerId>}\n */\n\n\nconst initPeerId = ({\n  print,\n  algorithm = 'RSA',\n  bits = 2048\n}) => {\n  // Generate peer identity keypair + transform to desired format + add to config.\n  print('generating %s-bit (rsa only) %s keypair...', bits, algorithm);\n  return PeerId.create({\n    keyType: algorithm,\n    bits\n  });\n};\n/**\n * @param {PeerId} peerId\n */\n\n\nconst peerIdToIdentity = peerId => ({\n  PeerID: peerId.toB58String(),\n\n  /** @type {string} */\n  PrivKey: uint8ArrayToString(peerId.privKey.bytes, 'base64pad')\n});\n/**\n * Applies passed `profiles` and a `config`  to an open repo.\n *\n * @param {Repo} repo\n * @param {ConfigureOptions} options\n * @returns {Promise<{peerId: PeerId, keychain?: Keychain}>}\n */\n\n\nconst configureRepo = async (repo, {\n  config,\n  profiles,\n  pass\n}) => {\n  const original = await repo.config.getAll();\n  const changed = mergeConfigs(applyProfiles(original, profiles), config);\n\n  if (original !== changed) {\n    await repo.config.replace(changed);\n  } // @ts-ignore - Identity may not be present\n\n\n  const peerId = await PeerId.createFromPrivKey(changed.Identity.PrivKey);\n  const libp2p = createLibP2P({\n    options: undefined,\n    multiaddrs: undefined,\n    peerId,\n    repo,\n    config: changed,\n    keychainConfig: {\n      pass,\n      ...changed.Keychain\n    }\n  });\n\n  if (libp2p.keychain) {\n    await libp2p.loadKeychain();\n  }\n\n  return {\n    peerId,\n    keychain: libp2p.keychain\n  };\n};\n/**\n * @param {IPFSConfig} config\n * @param {Partial<IPFSConfig>} [changes]\n */\n\n\nconst mergeConfigs = (config, changes) => changes ? mergeOptions(config, changes) : config;\n/**\n * Apply profiles (e.g. ['server', 'lowpower']) to config\n *\n * @param {IPFSConfig} config\n * @param {string[]} [profiles]\n */\n\n\nconst applyProfiles = (config, profiles) => {\n  return (profiles || []).reduce((config, name) => {\n    const profile = configService.profiles[name];\n\n    if (!profile) {\n      throw new Error(\"Could not find profile with name '\".concat(name, \"'\"));\n    }\n\n    log('applying profile %s', name);\n    return profile.transform(config);\n  }, config);\n};\n/**\n * @typedef {StorageOptions & RepoOptions & InitOptions} Options\n *\n * @typedef {Object} StorageOptions\n * @property {Repo|string} [repo='~/.jsipfs'] - The file path at which to store the\n * IPFS nodeâ€™s data. Alternatively, you can set up a customized storage system\n * by providing an Repo implementation. (In browser default is 'ipfs').\n * @property {boolean} [repoAutoMigrate=true] - js-ipfs comes bundled with a tool\n * that automatically migrates your IPFS repository when a new version is\n * available.\n * @property {boolean} [repoOwner]\n * @property {IPLDOptions} [ipld]\n *\n *\n * @typedef {Object} RepoOptions\n * @property {Print} print\n * @property {IPFSConfig} [config]\n * @property {boolean} [silent]\n *\n * @typedef {Object} ConfigureOptions\n * @property {IPFSConfig} [options.config]\n * @property {string[]} [options.profiles]\n * @property {string} [options.pass]\n *\n * @typedef {Object} InitOptions - On Frist run js-ipfs will initalize a repo\n * which can be customized through this settings.\n * @property {boolean} [emptyRepo=false] - Whether to remove built-in assets,\n * like the instructional tour and empty mutable file system, from the repo.\n * @property {KeyType} [algorithm='RSA'] - The type of key to use.\n * @property {number} [bits=2048] - Number of bits to use in the generated key\n * pair (rsa only).\n * @property {PeerId|string} [privateKey] - A pre-generated private key to use.\n * **NOTE: This overrides `bits`.**\n * @property {string} [pass] - A passphrase to encrypt keys. You should\n * generally use the top-level `pass` option instead of the `init.pass`\n * option (this one will take its value from the top-level option if not set).\n * @property {string[]} [profiles] - Apply profile settings to config.\n * @property {boolean} [allowNew=true] - Set to `false` to disallow\n * initialization if the repo does not already exist.\n *\n * @typedef {import('.').IPLDOptions} IPLDOptions\n * @typedef {import('.').Print} Print\n * @typedef {import('.').IPFSConfig} IPFSConfig\n * @typedef {import('ipfs-core-types/src/repo').Repo<IPFSConfig>} Repo\n * @typedef {import('libp2p-crypto').KeyType} KeyType\n * @typedef {import('libp2p/src/keychain')} Keychain\n */","map":null,"metadata":{},"sourceType":"script"}