{"ast":null,"code":"'use strict';\n\nconst debug = require('debug');\n/** @typedef {import('../types').EventEmitterFactory} Events */\n\n/** @type Events */\n\n\nconst EventEmitter = require('events');\n\nconst errcode = require('err-code');\n\nconst _require = require('it-pipe'),\n      pipe = _require.pipe;\n\nconst MulticodecTopology = require('../topology/multicodec-topology');\n\nconst _require2 = require('./errors'),\n      codes = _require2.codes;\n/**\n * @type {typeof import('./message')}\n */\n\n\nconst message = require('./message');\n\nconst PeerStreams = require('./peer-streams');\n\nconst _require3 = require('./signature-policy'),\n      SignaturePolicy = _require3.SignaturePolicy;\n\nconst utils = require('./utils');\n\nconst _require4 = require('./message/sign'),\n      signMessage = _require4.signMessage,\n      verifySignature = _require4.verifySignature;\n/**\n * @typedef {any} Libp2p\n * @typedef {import('peer-id')} PeerId\n * @typedef {import('bl')} BufferList\n * @typedef {import('../stream-muxer/types').MuxedStream} MuxedStream\n * @typedef {import('../connection/connection')} Connection\n * @typedef {import('./message').RPC} RPC\n * @typedef {import('./message').SubOpts} RPCSubOpts\n * @typedef {import('./message').Message} RPCMessage\n * @typedef {import('./signature-policy').SignaturePolicyType} SignaturePolicyType\n */\n\n/**\n * @typedef {Object} InMessage\n * @property {string} [from]\n * @property {string} receivedFrom\n * @property {string[]} topicIDs\n * @property {Uint8Array} [seqno]\n * @property {Uint8Array} data\n * @property {Uint8Array} [signature]\n * @property {Uint8Array} [key]\n */\n\n/**\n * PubsubBaseProtocol handles the peers and connections logic for pubsub routers\n * and specifies the API that pubsub routers should have.\n */\n\n\nclass PubsubBaseProtocol extends EventEmitter {\n  /**\n   * @param {Object} props\n   * @param {string} props.debugName - log namespace\n   * @param {Array<string>|string} props.multicodecs - protocol identificers to connect\n   * @param {Libp2p} props.libp2p\n   * @param {SignaturePolicyType} [props.globalSignaturePolicy = SignaturePolicy.StrictSign] - defines how signatures should be handled\n   * @param {boolean} [props.canRelayMessage = false] - if can relay messages not subscribed\n   * @param {boolean} [props.emitSelf = false] - if publish should emit to self, if subscribed\n   * @abstract\n   */\n  constructor({\n    debugName,\n    multicodecs,\n    libp2p,\n    globalSignaturePolicy = SignaturePolicy.StrictSign,\n    canRelayMessage = false,\n    emitSelf = false\n  }) {\n    if (typeof debugName !== 'string') {\n      throw new Error('a debugname `string` is required');\n    }\n\n    if (!multicodecs) {\n      throw new Error('multicodecs are required');\n    }\n\n    if (!libp2p) {\n      throw new Error('libp2p is required');\n    }\n\n    super();\n    this.log = debug(debugName);\n    this.log.err = debug(\"\".concat(debugName, \":error\"));\n    /**\n     * @type {Array<string>}\n     */\n\n    this.multicodecs = utils.ensureArray(multicodecs);\n    this._libp2p = libp2p;\n    this.registrar = libp2p.registrar;\n    /**\n     * @type {PeerId}\n     */\n\n    this.peerId = libp2p.peerId;\n    this.started = false;\n    /**\n     * Map of topics to which peers are subscribed to\n     *\n     * @type {Map<string, Set<string>>}\n     */\n\n    this.topics = new Map();\n    /**\n     * List of our subscriptions\n     *\n     * @type {Set<string>}\n     */\n\n    this.subscriptions = new Set();\n    /**\n     * Map of peer streams\n     *\n     * @type {Map<string, import('./peer-streams')>}\n     */\n\n    this.peers = new Map(); // validate signature policy\n\n    if (!SignaturePolicy[globalSignaturePolicy]) {\n      throw errcode(new Error('Invalid global signature policy'), codes.ERR_INVALID_SIGUATURE_POLICY);\n    }\n    /**\n     * The signature policy to follow by default\n     *\n     * @type {string}\n     */\n\n\n    this.globalSignaturePolicy = globalSignaturePolicy;\n    /**\n     * If router can relay received messages, even if not subscribed\n     *\n     * @type {boolean}\n     */\n\n    this.canRelayMessage = canRelayMessage;\n    /**\n     * if publish should emit to self, if subscribed\n     *\n     * @type {boolean}\n     */\n\n    this.emitSelf = emitSelf;\n    /**\n     * Topic validator function\n     *\n     * @typedef {function(string, InMessage): Promise<void>} validator\n     */\n\n    /**\n     * Topic validator map\n     *\n     * Keyed by topic\n     * Topic validators are functions with the following input:\n     *\n     * @type {Map<string, validator>}\n     */\n\n    this.topicValidators = new Map();\n    this._registrarId = undefined;\n    this._onIncomingStream = this._onIncomingStream.bind(this);\n    this._onPeerConnected = this._onPeerConnected.bind(this);\n    this._onPeerDisconnected = this._onPeerDisconnected.bind(this);\n  } // LIFECYCLE METHODS\n\n  /**\n   * Register the pubsub protocol onto the libp2p node.\n   *\n   * @returns {void}\n   */\n\n\n  start() {\n    if (this.started) {\n      return;\n    }\n\n    this.log('starting'); // Incoming streams\n    // Called after a peer dials us\n\n    this.registrar.handle(this.multicodecs, this._onIncomingStream); // register protocol with topology\n    // Topology callbacks called on connection manager changes\n\n    const topology = new MulticodecTopology({\n      multicodecs: this.multicodecs,\n      handlers: {\n        onConnect: this._onPeerConnected,\n        onDisconnect: this._onPeerDisconnected\n      }\n    });\n    this._registrarId = this.registrar.register(topology);\n    this.log('started');\n    this.started = true;\n  }\n  /**\n   * Unregister the pubsub protocol and the streams with other peers will be closed.\n   *\n   * @returns {void}\n   */\n\n\n  stop() {\n    if (!this.started) {\n      return;\n    } // unregister protocol and handlers\n\n\n    this.registrar.unregister(this._registrarId);\n    this.log('stopping');\n    this.peers.forEach(peerStreams => peerStreams.close());\n    this.peers = new Map();\n    this.subscriptions = new Set();\n    this.started = false;\n    this.log('stopped');\n  }\n  /**\n   * On an inbound stream opened.\n   *\n   * @protected\n   * @param {Object} props\n   * @param {string} props.protocol\n   * @param {MuxedStream} props.stream\n   * @param {Connection} props.connection - connection\n   */\n\n\n  _onIncomingStream({\n    protocol,\n    stream,\n    connection\n  }) {\n    const peerId = connection.remotePeer;\n    const idB58Str = peerId.toB58String();\n\n    const peer = this._addPeer(peerId, protocol);\n\n    const inboundStream = peer.attachInboundStream(stream);\n\n    this._processMessages(idB58Str, inboundStream, peer);\n  }\n  /**\n   * Registrar notifies an established connection with pubsub protocol.\n   *\n   * @protected\n   * @param {PeerId} peerId - remote peer-id\n   * @param {Connection} conn - connection to the peer\n   */\n\n\n  async _onPeerConnected(peerId, conn) {\n    const idB58Str = peerId.toB58String();\n    this.log('connected', idB58Str);\n\n    try {\n      const _ref = await conn.newStream(this.multicodecs),\n            stream = _ref.stream,\n            protocol = _ref.protocol;\n\n      const peer = this._addPeer(peerId, protocol);\n\n      await peer.attachOutboundStream(stream);\n    } catch (err) {\n      this.log.err(err);\n    } // Immediately send my own subscriptions to the newly established conn\n\n\n    this._sendSubscriptions(idB58Str, Array.from(this.subscriptions), true);\n  }\n  /**\n   * Registrar notifies a closing connection with pubsub protocol.\n   *\n   * @protected\n   * @param {PeerId} peerId - peerId\n   * @param {Error} [err] - error for connection end\n   */\n\n\n  _onPeerDisconnected(peerId, err) {\n    const idB58Str = peerId.toB58String();\n    this.log('connection ended', idB58Str, err ? err.message : '');\n\n    this._removePeer(peerId);\n  }\n  /**\n   * Notifies the router that a peer has been connected\n   *\n   * @protected\n   * @param {PeerId} peerId\n   * @param {string} protocol\n   * @returns {PeerStreams}\n   */\n\n\n  _addPeer(peerId, protocol) {\n    const id = peerId.toB58String();\n    const existing = this.peers.get(id); // If peer streams already exists, do nothing\n\n    if (existing) {\n      return existing;\n    } // else create a new peer streams\n\n\n    this.log('new peer', id);\n    const peerStreams = new PeerStreams({\n      id: peerId,\n      protocol\n    });\n    this.peers.set(id, peerStreams);\n    peerStreams.once('close', () => this._removePeer(peerId));\n    return peerStreams;\n  }\n  /**\n   * Notifies the router that a peer has been disconnected.\n   *\n   * @protected\n   * @param {PeerId} peerId\n   * @returns {PeerStreams | undefined}\n   */\n\n\n  _removePeer(peerId) {\n    if (!peerId) return;\n    const id = peerId.toB58String();\n    const peerStreams = this.peers.get(id);\n    if (!peerStreams) return; // close peer streams\n\n    peerStreams.removeAllListeners();\n    peerStreams.close(); // delete peer streams\n\n    this.log('delete peer', id);\n    this.peers.delete(id); // remove peer from topics map\n\n    for (const peers of this.topics.values()) {\n      peers.delete(id);\n    }\n\n    return peerStreams;\n  } // MESSAGE METHODS\n\n  /**\n   * Responsible for processing each RPC message received by other peers.\n   *\n   * @param {string} idB58Str - peer id string in base58\n   * @param {AsyncIterable<Uint8Array|BufferList>} stream - inbound stream\n   * @param {PeerStreams} peerStreams - PubSub peer\n   * @returns {Promise<void>}\n   */\n\n\n  async _processMessages(idB58Str, stream, peerStreams) {\n    try {\n      await pipe(stream, async source => {\n        for await (const data of source) {\n          const rpcBytes = data instanceof Uint8Array ? data : data.slice();\n\n          const rpcMsg = this._decodeRpc(rpcBytes);\n\n          this._processRpc(idB58Str, peerStreams, rpcMsg);\n        }\n      });\n    } catch (err) {\n      this._onPeerDisconnected(peerStreams.id, err);\n    }\n  }\n  /**\n   * Handles an rpc request from a peer\n   *\n   * @param {string} idB58Str\n   * @param {PeerStreams} peerStreams\n   * @param {RPC} rpc\n   * @returns {boolean}\n   */\n\n\n  _processRpc(idB58Str, peerStreams, rpc) {\n    this.log('rpc from', idB58Str);\n    const subs = rpc.subscriptions;\n    const msgs = rpc.msgs;\n\n    if (subs.length) {\n      // update peer subscriptions\n      subs.forEach(subOpt => this._processRpcSubOpt(idB58Str, subOpt));\n      this.emit('pubsub:subscription-change', peerStreams.id, subs);\n    }\n\n    if (!this._acceptFrom(idB58Str)) {\n      this.log('received message from unacceptable peer %s', idB58Str);\n      return false;\n    }\n\n    if (msgs.length) {\n      msgs.forEach(message => {\n        if (!(this.canRelayMessage || message.topicIDs.some(topic => this.subscriptions.has(topic)))) {\n          this.log('received message we didn\\'t subscribe to. Dropping.');\n          return;\n        }\n\n        const msg = utils.normalizeInRpcMessage(message, idB58Str);\n\n        this._processRpcMessage(msg);\n      });\n    }\n\n    return true;\n  }\n  /**\n   * Handles a subscription change from a peer\n   *\n   * @param {string} id\n   * @param {RPCSubOpts} subOpt\n   */\n\n\n  _processRpcSubOpt(id, subOpt) {\n    const t = subOpt.topicID;\n    let topicSet = this.topics.get(t);\n\n    if (!topicSet) {\n      topicSet = new Set();\n      this.topics.set(t, topicSet);\n    }\n\n    if (subOpt.subscribe) {\n      // subscribe peer to new topic\n      topicSet.add(id);\n    } else {\n      // unsubscribe from existing topic\n      topicSet.delete(id);\n    }\n  }\n  /**\n   * Handles an message from a peer\n   *\n   * @param {InMessage} msg\n   * @returns {Promise<void>}\n   */\n\n\n  async _processRpcMessage(msg) {\n    if (this.peerId.toB58String() === msg.from && !this.emitSelf) {\n      return;\n    } // Ensure the message is valid before processing it\n\n\n    try {\n      await this.validate(msg);\n    } catch (err) {\n      this.log('Message is invalid, dropping it. %O', err);\n      return;\n    } // Emit to self\n\n\n    this._emitMessage(msg);\n\n    this._publish(utils.normalizeOutRpcMessage(msg));\n  }\n  /**\n   * Emit a message from a peer\n   *\n   * @param {InMessage} message\n   */\n\n\n  _emitMessage(message) {\n    message.topicIDs.forEach(topic => {\n      if (this.subscriptions.has(topic)) {\n        this.emit(topic, message);\n      }\n    });\n  }\n  /**\n   * The default msgID implementation\n   * Child class can override this.\n   *\n   * @param {RPCMessage} msg - the message object\n   * @returns {Uint8Array} message id as bytes\n   */\n\n\n  getMsgId(msg) {\n    const signaturePolicy = this.globalSignaturePolicy;\n\n    switch (signaturePolicy) {\n      case SignaturePolicy.StrictSign:\n        return utils.msgId(msg.from, msg.seqno);\n\n      case SignaturePolicy.StrictNoSign:\n        return utils.noSignMsgId(msg.data);\n\n      default:\n        throw errcode(new Error('Cannot get message id: unhandled signature policy: ' + signaturePolicy), codes.ERR_UNHANDLED_SIGNATURE_POLICY);\n    }\n  }\n  /**\n   * Whether to accept a message from a peer\n   * Override to create a graylist\n   *\n   * @override\n   * @param {string} id\n   * @returns {boolean}\n   */\n\n\n  _acceptFrom(id) {\n    return true;\n  }\n  /**\n   * Decode Uint8Array into an RPC object.\n   * This can be override to use a custom router protobuf.\n   *\n   * @param {Uint8Array} bytes\n   * @returns {RPC}\n   */\n\n\n  _decodeRpc(bytes) {\n    return message.rpc.RPC.decode(bytes);\n  }\n  /**\n   * Encode RPC object into a Uint8Array.\n   * This can be override to use a custom router protobuf.\n   *\n   * @param {RPC} rpc\n   * @returns {Uint8Array}\n   */\n\n\n  _encodeRpc(rpc) {\n    return message.rpc.RPC.encode(rpc);\n  }\n  /**\n   * Send an rpc object to a peer\n   *\n   * @param {string} id - peer id\n   * @param {RPC} rpc\n   * @returns {void}\n   */\n\n\n  _sendRpc(id, rpc) {\n    const peerStreams = this.peers.get(id);\n\n    if (!peerStreams || !peerStreams.isWritable) {\n      const msg = \"Cannot send RPC to \".concat(id, \" as there is no open stream to it available\");\n      this.log.err(msg);\n      return;\n    }\n\n    peerStreams.write(this._encodeRpc(rpc));\n  }\n  /**\n   * Send subscroptions to a peer\n   *\n   * @param {string} id - peer id\n   * @param {string[]} topics\n   * @param {boolean} subscribe - set to false for unsubscriptions\n   * @returns {void}\n   */\n\n\n  _sendSubscriptions(id, topics, subscribe) {\n    return this._sendRpc(id, {\n      subscriptions: topics.map(t => ({\n        topicID: t,\n        subscribe: subscribe\n      }))\n    });\n  }\n  /**\n   * Validates the given message. The signature will be checked for authenticity.\n   * Throws an error on invalid messages\n   *\n   * @param {InMessage} message\n   * @returns {Promise<void>}\n   */\n\n\n  async validate(message) {\n    // eslint-disable-line require-await\n    const signaturePolicy = this.globalSignaturePolicy;\n\n    switch (signaturePolicy) {\n      case SignaturePolicy.StrictNoSign:\n        if (message.from) {\n          throw errcode(new Error('StrictNoSigning: from should not be present'), codes.ERR_UNEXPECTED_FROM);\n        }\n\n        if (message.signature) {\n          throw errcode(new Error('StrictNoSigning: signature should not be present'), codes.ERR_UNEXPECTED_SIGNATURE);\n        }\n\n        if (message.key) {\n          throw errcode(new Error('StrictNoSigning: key should not be present'), codes.ERR_UNEXPECTED_KEY);\n        }\n\n        if (message.seqno) {\n          throw errcode(new Error('StrictNoSigning: seqno should not be present'), codes.ERR_UNEXPECTED_SEQNO);\n        }\n\n        break;\n\n      case SignaturePolicy.StrictSign:\n        if (!message.signature) {\n          throw errcode(new Error('StrictSigning: Signing required and no signature was present'), codes.ERR_MISSING_SIGNATURE);\n        }\n\n        if (!message.seqno) {\n          throw errcode(new Error('StrictSigning: Signing required and no seqno was present'), codes.ERR_MISSING_SEQNO);\n        }\n\n        if (!(await verifySignature(message))) {\n          throw errcode(new Error('StrictSigning: Invalid message signature'), codes.ERR_INVALID_SIGNATURE);\n        }\n\n        break;\n\n      default:\n        throw errcode(new Error('Cannot validate message: unhandled signature policy: ' + signaturePolicy), codes.ERR_UNHANDLED_SIGNATURE_POLICY);\n    }\n\n    for (const topic of message.topicIDs) {\n      const validatorFn = this.topicValidators.get(topic);\n\n      if (!validatorFn) {\n        continue;\n      }\n\n      await validatorFn(topic, message);\n    }\n  }\n  /**\n   * Normalizes the message and signs it, if signing is enabled.\n   * Should be used by the routers to create the message to send.\n   *\n   * @protected\n   * @param {RPCMessage} message\n   * @returns {Promise<RPCMessage>}\n   */\n\n\n  _buildMessage(message) {\n    const signaturePolicy = this.globalSignaturePolicy;\n\n    switch (signaturePolicy) {\n      case SignaturePolicy.StrictSign:\n        message.from = this.peerId.toB58String();\n        message.seqno = utils.randomSeqno();\n        return signMessage(this.peerId, utils.normalizeOutRpcMessage(message));\n\n      case SignaturePolicy.StrictNoSign:\n        return message;\n\n      default:\n        throw errcode(new Error('Cannot build message: unhandled signature policy: ' + signaturePolicy), codes.ERR_UNHANDLED_SIGNATURE_POLICY);\n    }\n  } // API METHODS\n\n  /**\n   * Get a list of the peer-ids that are subscribed to one topic.\n   *\n   * @param {string} topic\n   * @returns {Array<string>}\n   */\n\n\n  getSubscribers(topic) {\n    if (!this.started) {\n      throw errcode(new Error('not started yet'), 'ERR_NOT_STARTED_YET');\n    }\n\n    if (!topic || typeof topic !== 'string') {\n      throw errcode(new Error('a string topic must be provided'), 'ERR_NOT_VALID_TOPIC');\n    }\n\n    const peersInTopic = this.topics.get(topic);\n\n    if (!peersInTopic) {\n      return [];\n    }\n\n    return Array.from(peersInTopic);\n  }\n  /**\n   * Publishes messages to all subscribed peers\n   *\n   * @override\n   * @param {string} topic\n   * @param {Uint8Array} message\n   * @returns {Promise<void>}\n   */\n\n\n  async publish(topic, message) {\n    if (!this.started) {\n      throw new Error('Pubsub has not started');\n    }\n\n    this.log('publish', topic, message);\n    const from = this.peerId.toB58String();\n    let msgObject = {\n      receivedFrom: from,\n      data: message,\n      topicIDs: [topic]\n    }; // ensure that the message follows the signature policy\n\n    const outMsg = await this._buildMessage(msgObject);\n    msgObject = utils.normalizeInRpcMessage(outMsg); // Emit to self if I'm interested and emitSelf enabled\n\n    this.emitSelf && this._emitMessage(msgObject); // send to all the other peers\n\n    await this._publish(msgObject);\n  }\n  /**\n   * Overriding the implementation of publish should handle the appropriate algorithms for the publish/subscriber implementation.\n   * For example, a Floodsub implementation might simply publish each message to each topic for every peer\n   *\n   * @abstract\n   * @param {InMessage} message\n   * @returns {Promise<void>}\n   *\n   */\n\n\n  _publish(message) {\n    throw errcode(new Error('publish must be implemented by the subclass'), 'ERR_NOT_IMPLEMENTED');\n  }\n  /**\n   * Subscribes to a given topic.\n   *\n   * @abstract\n   * @param {string} topic\n   * @returns {void}\n   */\n\n\n  subscribe(topic) {\n    if (!this.started) {\n      throw new Error('Pubsub has not started');\n    }\n\n    if (!this.subscriptions.has(topic)) {\n      this.subscriptions.add(topic);\n      this.peers.forEach((_, id) => this._sendSubscriptions(id, [topic], true));\n    }\n  }\n  /**\n   * Unsubscribe from the given topic.\n   *\n   * @override\n   * @param {string} topic\n   * @returns {void}\n   */\n\n\n  unsubscribe(topic) {\n    if (!this.started) {\n      throw new Error('Pubsub is not started');\n    }\n\n    if (this.subscriptions.has(topic) && this.listenerCount(topic) === 0) {\n      this.subscriptions.delete(topic);\n      this.peers.forEach((_, id) => this._sendSubscriptions(id, [topic], false));\n    }\n  }\n  /**\n   * Get the list of topics which the peer is subscribed to.\n   *\n   * @override\n   * @returns {Array<string>}\n   */\n\n\n  getTopics() {\n    if (!this.started) {\n      throw new Error('Pubsub is not started');\n    }\n\n    return Array.from(this.subscriptions);\n  }\n\n}\n\nPubsubBaseProtocol.message = message;\nPubsubBaseProtocol.utils = utils;\nPubsubBaseProtocol.SignaturePolicy = SignaturePolicy;\nmodule.exports = PubsubBaseProtocol;","map":null,"metadata":{},"sourceType":"script"}