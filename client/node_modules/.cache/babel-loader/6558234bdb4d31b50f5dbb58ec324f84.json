{"ast":null,"code":"'use strict';\n\nconst CID = require('cids');\n\nconst errCode = require('err-code');\n\nconst _require = require('streaming-iterables'),\n      parallelMap = _require.parallelMap,\n      filter = _require.filter;\n\nconst _require2 = require('it-pipe'),\n      pipe = _require2.pipe;\n\nconst _require3 = require('../pin/pin-manager'),\n      PinTypes = _require3.PinTypes;\n\nconst _require4 = require('./utils'),\n      cleanCid = _require4.cleanCid;\n\nconst withTimeoutOption = require('ipfs-core-utils/src/with-timeout-option');\n\nconst BLOCK_RM_CONCURRENCY = 8;\n/**\n * @param {Object} config\n * @param {import('.').BlockService} config.blockService\n * @param {import('.').PinManager} config.pinManager\n * @param {import('.').GCLock} config.gcLock\n */\n\nmodule.exports = ({\n  blockService,\n  gcLock,\n  pinManager\n}) => {\n  /**\n  /**\n   * Remove one or more IPFS block(s).\n   *\n   * @param {CID[]|CID} cids - CID(s) corresponding to the block(s) to be removed.\n   * @param {RmOptions & AbortOptions} [options]\n   * @returns {AsyncIterable<RmResult>}\n   *\n   * @example\n   * ```js\n   * for await (const result of ipfs.block.rm(cid)) {\n   *   if (result.error) {\n   *     console.error(`Failed to remove block ${result.cid} due to ${result.error.message}`)\n   *   } else {\n   *    console.log(`Removed block ${result.cid}`)\n   *   }\n   * }\n   * ```\n   */\n  async function* rm(cids, options = {}) {\n    if (!Array.isArray(cids)) {\n      cids = [cids];\n    } // We need to take a write lock here to ensure that adding and removing\n    // blocks are exclusive operations\n\n\n    const release = await gcLock.writeLock();\n\n    try {\n      yield* pipe(cids, parallelMap(BLOCK_RM_CONCURRENCY, async cid => {\n        cid = cleanCid(cid);\n        const result = {\n          cid\n        };\n\n        try {\n          const pinResult = await pinManager.isPinnedWithType(cid, PinTypes.all);\n\n          if (pinResult.pinned) {\n            if (CID.isCID(pinResult.reason)) {\n              // eslint-disable-line max-depth\n              throw errCode(new Error(\"pinned via \".concat(pinResult.reason)));\n            }\n\n            throw errCode(new Error(\"pinned: \".concat(pinResult.reason)));\n          } // remove has check when https://github.com/ipfs/js-ipfs-block-service/pull/88 is merged\n          // @ts-ignore - this accesses some internals\n\n\n          const has = await blockService._repo.blocks.has(cid);\n\n          if (!has) {\n            throw errCode(new Error('block not found'), 'ERR_BLOCK_NOT_FOUND');\n          }\n\n          await blockService.delete(cid);\n        } catch (err) {\n          if (!options.force) {\n            err.message = \"cannot remove \".concat(cid, \": \").concat(err.message);\n            result.error = err;\n          }\n        }\n\n        return result;\n      }), filter(() => !options.quiet));\n    } finally {\n      release();\n    }\n  }\n\n  return withTimeoutOption(rm);\n};\n/**\n * @typedef {Object} RmOptions\n * @property {boolean} [force=false] - Ignores nonexistent blocks\n * @property {boolean} [quiet=false] - Write minimal output\n *\n * @typedef {import('.').AbortOptions} AbortOptions\n *\n * @typedef {RmSucceess|RmFailure} RmResult\n * Note: If an error is present for a given object, the block with\n * that cid was not removed and the error will contain the reason why,\n * for example if the block was pinned.\n *\n * @typedef {Object} RmSucceess\n * @property {CID} cid\n * @property {void} [error]\n *\n * @typedef {Object} RmFailure\n * @property {CID} cid\n * @property {Error} error\n */","map":null,"metadata":{},"sourceType":"script"}