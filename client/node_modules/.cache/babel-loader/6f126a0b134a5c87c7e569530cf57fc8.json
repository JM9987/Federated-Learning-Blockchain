{"ast":null,"code":"'use strict';\n\nconst _require = require('interface-datastore'),\n      Key = _require.Key,\n      Adapter = _require.Adapter;\n\nconst _require2 = require('./utils'),\n      encodeBase32 = _require2.encodeBase32,\n      keyToTopic = _require2.keyToTopic,\n      topicToKey = _require2.topicToKey;\n\nconst errcode = require('err-code');\n\nconst debug = require('debug');\n\nconst log = debug('datastore-pubsub:publisher');\nlog.error = debug('datastore-pubsub:publisher:error'); // DatastorePubsub is responsible for providing an api for pubsub to be used as a datastore with\n// [TieredDatastore]{@link https://github.com/ipfs/js-datastore-core/blob/master/src/tiered.js}\n\nclass DatastorePubsub extends Adapter {\n  /**\n   * Creates an instance of DatastorePubsub.\n   *\n   * @param {*} pubsub - pubsub implementation.\n   * @param {*} datastore - datastore instance.\n   * @param {*} peerId - peer-id instance.\n   * @param {Object} validator - validator functions.\n   * @param {(record: uint8Array, peerId: PeerId) => boolean} validator.validate - function to validate a record.\n   * @param {(received: uint8Array, current: uint8Array) => boolean} validator.select - function to select the newest between two records.\n   * @param {function(key, callback)} subscriptionKeyFn - optional function to manipulate the key topic received before processing it.\n   * @memberof DatastorePubsub\n   */\n  constructor(pubsub, datastore, peerId, validator, subscriptionKeyFn) {\n    super();\n\n    if (!validator) {\n      throw errcode(new TypeError('missing validator'), 'ERR_INVALID_PARAMETERS');\n    }\n\n    if (typeof validator.validate !== 'function') {\n      throw errcode(new TypeError('missing validate function'), 'ERR_INVALID_PARAMETERS');\n    }\n\n    if (typeof validator.select !== 'function') {\n      throw errcode(new TypeError('missing select function'), 'ERR_INVALID_PARAMETERS');\n    }\n\n    if (subscriptionKeyFn && typeof subscriptionKeyFn !== 'function') {\n      throw errcode(new TypeError('invalid subscriptionKeyFn received'), 'ERR_INVALID_PARAMETERS');\n    }\n\n    this._pubsub = pubsub;\n    this._datastore = datastore;\n    this._peerId = peerId;\n    this._validator = validator;\n    this._handleSubscriptionKeyFn = subscriptionKeyFn; // Bind _onMessage function, which is called by pubsub.\n\n    this._onMessage = this._onMessage.bind(this);\n  }\n  /**\n   * Publishes a value through pubsub.\n   *\n   * @param {Uint8Array} key - identifier of the value to be published.\n   * @param {Uint8Array} val - value to be propagated.\n   * @returns {Promise}\n   */\n\n\n  async put(key, val) {\n    // eslint-disable-line require-await\n    if (!(key instanceof Uint8Array)) {\n      const errMsg = 'datastore key does not have a valid format';\n      log.error(errMsg);\n      throw errcode(new Error(errMsg), 'ERR_INVALID_DATASTORE_KEY');\n    }\n\n    if (!(val instanceof Uint8Array)) {\n      const errMsg = 'received value is not a Uint8Array';\n      log.error(errMsg);\n      throw errcode(new Error(errMsg), 'ERR_INVALID_VALUE_RECEIVED');\n    }\n\n    const stringifiedTopic = keyToTopic(key);\n    log(\"publish value for topic \".concat(stringifiedTopic)); // Publish record to pubsub\n\n    return this._pubsub.publish(stringifiedTopic, val);\n  }\n  /**\n   * Try to subscribe a topic with Pubsub and returns the local value if available.\n   *\n   * @param {Uint8Array} key - identifier of the value to be subscribed.\n   * @returns {Promise<Uint8Array>}\n   */\n\n\n  async get(key) {\n    if (!(key instanceof Uint8Array)) {\n      const errMsg = 'datastore key does not have a valid format';\n      log.error(errMsg);\n      throw errcode(new Error(errMsg), 'ERR_INVALID_DATASTORE_KEY');\n    }\n\n    const stringifiedTopic = keyToTopic(key);\n    const subscriptions = await this._pubsub.getTopics(); // If already subscribed, just try to get it\n\n    if (subscriptions && Array.isArray(subscriptions) && subscriptions.indexOf(stringifiedTopic) > -1) {\n      return this._getLocal(key);\n    } // subscribe\n\n\n    try {\n      await this._pubsub.subscribe(stringifiedTopic, this._onMessage);\n    } catch (err) {\n      const errMsg = \"cannot subscribe topic \".concat(stringifiedTopic);\n      log.error(errMsg);\n      throw errcode(new Error(errMsg), 'ERR_SUBSCRIBING_TOPIC');\n    }\n\n    log(\"subscribed values for key \".concat(stringifiedTopic));\n    return this._getLocal(key);\n  }\n  /**\n   * Unsubscribe topic.\n   *\n   * @param {Uint8Array} key - identifier of the value to unsubscribe.\n   * @returns {void}\n   */\n\n\n  unsubscribe(key) {\n    const stringifiedTopic = keyToTopic(key);\n    return this._pubsub.unsubscribe(stringifiedTopic, this._onMessage);\n  } // Get record from local datastore\n\n\n  async _getLocal(key) {\n    // encode key - base32(/ipns/{cid})\n    const routingKey = new Key('/' + encodeBase32(key), false);\n    let dsVal;\n\n    try {\n      dsVal = await this._datastore.get(routingKey);\n    } catch (err) {\n      if (err.code !== 'ERR_NOT_FOUND') {\n        const errMsg = \"unexpected error getting the ipns record for \".concat(routingKey.toString());\n        log.error(errMsg);\n        throw errcode(new Error(errMsg), 'ERR_UNEXPECTED_ERROR_GETTING_RECORD');\n      }\n\n      const errMsg = \"local record requested was not found for \".concat(routingKey.toString());\n      log.error(errMsg);\n      throw errcode(new Error(errMsg), 'ERR_NOT_FOUND');\n    }\n\n    if (!(dsVal instanceof Uint8Array)) {\n      const errMsg = 'found record that we couldn\\'t convert to a value';\n      log.error(errMsg);\n      throw errcode(new Error(errMsg), 'ERR_INVALID_RECORD_RECEIVED');\n    }\n\n    return dsVal;\n  } // handles pubsub subscription messages\n\n\n  async _onMessage(msg) {\n    const data = msg.data,\n          from = msg.from,\n          topicIDs = msg.topicIDs;\n    let key;\n\n    try {\n      key = topicToKey(topicIDs[0]);\n    } catch (err) {\n      log.error(err);\n      return;\n    }\n\n    log(\"message received for topic \".concat(topicIDs[0])); // Stop if the message is from the peer (it already stored it while publishing to pubsub)\n\n    if (from === this._peerId.toB58String()) {\n      log('message discarded as it is from the same peer');\n      return;\n    }\n\n    if (this._handleSubscriptionKeyFn) {\n      let res;\n\n      try {\n        res = await this._handleSubscriptionKeyFn(key);\n      } catch (err) {\n        log.error('message discarded by the subscriptionKeyFn');\n        return;\n      }\n\n      key = res;\n    }\n\n    try {\n      await this._storeIfSubscriptionIsBetter(key, data);\n    } catch (err) {\n      log.error(err);\n    }\n  } // Store the received record if it is better than the current stored\n\n\n  async _storeIfSubscriptionIsBetter(key, data) {\n    let isBetter = false;\n\n    try {\n      isBetter = await this._isBetter(key, data);\n    } catch (err) {\n      if (err.code !== 'ERR_NOT_VALID_RECORD') {\n        throw err;\n      }\n    }\n\n    if (isBetter) {\n      await this._storeRecord(key, data);\n    }\n  } // Validate record according to the received validation function\n\n\n  async _validateRecord(value, peerId) {\n    // eslint-disable-line require-await\n    return this._validator.validate(value, peerId);\n  } // Select the best record according to the received select function.\n\n\n  async _selectRecord(receivedRecord, currentRecord) {\n    const res = await this._validator.select(receivedRecord, currentRecord); // If the selected was the first (0), it should be stored (true)\n\n    return res === 0;\n  } // Verify if the record received through pubsub is valid and better than the one currently stored\n\n\n  async _isBetter(key, val) {\n    // validate received record\n    let error, valid;\n\n    try {\n      valid = await this._validateRecord(val, key);\n    } catch (err) {\n      error = err;\n    } // If not valid, it is not better than the one currently available\n\n\n    if (error || !valid) {\n      const errMsg = 'record received through pubsub is not valid';\n      log.error(errMsg);\n      throw errcode(new Error(errMsg), 'ERR_NOT_VALID_RECORD');\n    } // Get Local record\n\n\n    const dsKey = new Key(key);\n    let currentRecord;\n\n    try {\n      currentRecord = await this._getLocal(dsKey.uint8Array());\n    } catch (err) {\n      // if the old one is invalid, the new one is *always* better\n      return true;\n    } // if the same record, do not need to store\n\n\n    if (currentRecord.equals(val)) {\n      return false;\n    } // verify if the received record should replace the current one\n\n\n    return this._selectRecord(val, currentRecord);\n  } // add record to datastore\n\n\n  async _storeRecord(key, data) {\n    // encode key - base32(/ipns/{cid})\n    const routingKey = new Key('/' + encodeBase32(key), false);\n    await this._datastore.put(routingKey, data);\n    log(\"record for \".concat(keyToTopic(key), \" was stored in the datastore\"));\n  }\n\n  open() {\n    const errMsg = 'open function was not implemented yet';\n    log.error(errMsg);\n    throw errcode(new Error(errMsg), 'ERR_NOT_IMPLEMENTED_YET');\n  }\n\n  has(key) {\n    const errMsg = 'has function was not implemented yet';\n    log.error(errMsg);\n    throw errcode(new Error(errMsg), 'ERR_NOT_IMPLEMENTED_YET');\n  }\n\n  delete(key) {\n    const errMsg = 'delete function was not implemented yet';\n    log.error(errMsg);\n    throw errcode(new Error(errMsg), 'ERR_NOT_IMPLEMENTED_YET');\n  }\n\n  close() {\n    const errMsg = 'close function was not implemented yet';\n    log.error(errMsg);\n    throw errcode(new Error(errMsg), 'ERR_NOT_IMPLEMENTED_YET');\n  }\n\n  batch() {\n    const errMsg = 'batch function was not implemented yet';\n    log.error(errMsg);\n    throw errcode(new Error(errMsg), 'ERR_NOT_IMPLEMENTED_YET');\n  }\n\n  query() {\n    const errMsg = 'query function was not implemented yet';\n    log.error(errMsg);\n    throw errcode(new Error(errMsg), 'ERR_NOT_IMPLEMENTED_YET');\n  }\n\n}\n\nexports = module.exports = DatastorePubsub;","map":null,"metadata":{},"sourceType":"script"}