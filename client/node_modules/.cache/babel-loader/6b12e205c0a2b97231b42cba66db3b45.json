{"ast":null,"code":"'use strict';\n\nvar _slicedToArray = require(\"/home/ubuntu/TFG_FL/client/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nconst CID = require('cids');\n\nconst errcode = require('err-code');\n\nconst Message = require('../../message');\n\nconst utils = require('../../utils');\n\nmodule.exports = dht => {\n  const log = utils.logger(dht.peerId, 'rpc:get-providers');\n  /**\n   * Process `GetProviders` DHT messages.\n   *\n   * @param {PeerId} peerId\n   * @param {Message} msg\n   * @returns {Promise<Message>}\n   */\n\n  return async function getProviders(peerId, msg) {\n    let cid;\n\n    try {\n      cid = new CID(msg.key);\n    } catch (err) {\n      throw errcode(new Error(\"Invalid CID: \".concat(err.message)), 'ERR_INVALID_CID');\n    }\n\n    log('%s', cid.toBaseEncodedString());\n    const dsKey = utils.bufferToKey(cid.bytes);\n\n    const _ref = await Promise.all([dht.datastore.has(dsKey), dht.providers.getProviders(cid), dht._betterPeersToQuery(msg, peerId)]),\n          _ref2 = _slicedToArray(_ref, 3),\n          has = _ref2[0],\n          peers = _ref2[1],\n          closer = _ref2[2];\n\n    const providerPeers = peers.map(peerId => ({\n      id: peerId\n    }));\n    const closerPeers = closer.map(c => ({\n      id: c.id\n    }));\n\n    if (has) {\n      providerPeers.push({\n        id: dht.peerId\n      });\n    }\n\n    const response = new Message(msg.type, msg.key, msg.clusterLevel);\n\n    if (providerPeers.length > 0) {\n      response.providerPeers = providerPeers;\n    }\n\n    if (closerPeers.length > 0) {\n      response.closerPeers = closerPeers;\n    }\n\n    log('got %s providers %s closerPeers', providerPeers.length, closerPeers.length);\n    return response;\n  };\n};","map":null,"metadata":{},"sourceType":"script"}