{"ast":null,"code":"'use strict';\n\nconst getDefaultConfig = require('../runtime/config-nodejs.js');\n\nconst withTimeoutOption = require('ipfs-core-utils/src/with-timeout-option');\n\nconst log = require('debug')('ipfs:core:config');\n/**\n * @param {Object} config\n * @param {import('.').Repo} config.repo\n */\n\n\nmodule.exports = ({\n  repo\n}) => {\n  return {\n    getAll: withTimeoutOption(getAll),\n    get: withTimeoutOption(get),\n    set: withTimeoutOption(set),\n    replace: withTimeoutOption(replace),\n    profiles: {\n      apply: withTimeoutOption(applyProfile),\n      list: withTimeoutOption(listProfiles)\n    }\n  };\n  /**\n   * @param {AbortOptions} [options]\n   */\n\n  async function getAll(options = {}) {\n    // eslint-disable-line require-await\n    return repo.config.getAll(options);\n  }\n  /**\n   *\n   * @param {string} key\n   * @param {AbortOptions} [options]\n   */\n\n\n  async function get(key, options) {\n    // eslint-disable-line require-await\n    if (!key) {\n      return Promise.reject(new Error('key argument is required'));\n    }\n\n    return repo.config.get(key, options);\n  }\n  /**\n   *\n   * @param {string} key\n   * @param {ToJSON} value\n   * @param {AbortOptions} [options]\n   */\n\n\n  async function set(key, value, options) {\n    // eslint-disable-line require-await\n    return repo.config.set(key, value, options);\n  }\n  /**\n   * @param {IPFSConfig} value\n   * @param {AbortOptions} [options]\n   */\n\n\n  async function replace(value, options) {\n    // eslint-disable-line require-await\n    return repo.config.replace(value, options);\n  }\n  /**\n   * @param {string} profileName\n   * @param {*} options\n   * @returns {Promise<{original: IPFSConfig, updated: IPFSConfig}>}\n   */\n\n\n  async function applyProfile(profileName, options = {}) {\n    const dryRun = options.dryRun;\n    const profile = profiles[profileName];\n\n    if (!profile) {\n      throw new Error(\"No profile with name '\".concat(profileName, \"' exists\"));\n    }\n\n    try {\n      const oldCfg = await repo.config.getAll(options);\n      let newCfg = JSON.parse(JSON.stringify(oldCfg)); // clone\n\n      newCfg = profile.transform(newCfg);\n\n      if (!dryRun) {\n        await repo.config.replace(newCfg, options);\n      } // Scrub private key from output\n      // @ts-ignore `oldCfg.Identity` maybe undefined\n\n\n      delete oldCfg.Identity.PrivKey;\n      delete newCfg.Identity.PrivKey;\n      return {\n        original: oldCfg,\n        updated: newCfg\n      };\n    } catch (err) {\n      log(err);\n      throw new Error(\"Could not apply profile '\".concat(profileName, \"' to config: \").concat(err.message));\n    }\n  }\n};\n/**\n * @param {any} _options\n * @returns {Promise<{name:string, description:string}[]>}\n */\n\n\nasync function listProfiles(_options) {\n  // eslint-disable-line require-await\n  return Object.keys(profiles).map(name => ({\n    name,\n    description: profiles[name].description\n  }));\n}\n\nconst profiles = {\n  server: {\n    description: 'Recommended for nodes with public IPv4 address (servers, VPSes, etc.), disables host and content discovery and UPnP in local networks.',\n\n    /**\n     * @param {IPFSConfig} config\n     * @returns {IPFSConfig}\n     */\n    transform: config => {\n      config.Discovery.MDNS.Enabled = false;\n      config.Discovery.webRTCStar.Enabled = false;\n      config.Swarm = { ...(config.Swarm || {}),\n        DisableNatPortMap: true\n      };\n      return config;\n    }\n  },\n  'local-discovery': {\n    description: 'Sets default values to fields affected by `server` profile, enables discovery and UPnP in local networks.',\n\n    /**\n     * @param {IPFSConfig} config\n     * @returns {IPFSConfig}\n     */\n    transform: config => {\n      config.Discovery.MDNS.Enabled = true;\n      config.Discovery.webRTCStar.Enabled = true;\n      config.Swarm = { ...(config.Swarm || {}),\n        DisableNatPortMap: false\n      };\n      return config;\n    }\n  },\n  test: {\n    description: 'Reduces external interference, useful for running ipfs in test environments. Note that with these settings node won\\'t be able to talk to the rest of the network without manual bootstrap.',\n\n    /**\n     * @param {IPFSConfig} config\n     * @returns {IPFSConfig}\n     */\n    transform: config => {\n      const defaultConfig = getDefaultConfig();\n      config.Addresses.API = defaultConfig.Addresses.API ? '/ip4/127.0.0.1/tcp/0' : '';\n      config.Addresses.Gateway = defaultConfig.Addresses.Gateway ? '/ip4/127.0.0.1/tcp/0' : '';\n      config.Addresses.Swarm = defaultConfig.Addresses.Swarm.length ? ['/ip4/127.0.0.1/tcp/0'] : [];\n      config.Addresses.Delegates = [];\n      config.Bootstrap = [];\n      config.Discovery.MDNS.Enabled = false;\n      config.Discovery.webRTCStar.Enabled = false;\n      config.Swarm = { ...(config.Swarm || {}),\n        DisableNatPortMap: true\n      };\n      return config;\n    }\n  },\n  'default-networking': {\n    description: 'Restores default network settings. Inverse profile of the `test` profile.',\n\n    /**\n     * @param {IPFSConfig} config\n     * @returns {IPFSConfig}\n     */\n    transform: config => {\n      const defaultConfig = getDefaultConfig();\n      config.Addresses.API = defaultConfig.Addresses.API;\n      config.Addresses.Gateway = defaultConfig.Addresses.Gateway;\n      config.Addresses.Swarm = defaultConfig.Addresses.Swarm;\n      config.Addresses.Delegates = defaultConfig.Addresses.Delegates;\n      config.Bootstrap = defaultConfig.Bootstrap;\n      config.Discovery.MDNS.Enabled = defaultConfig.Discovery.MDNS.Enabled;\n      config.Discovery.webRTCStar.Enabled = defaultConfig.Discovery.webRTCStar.Enabled;\n      config.Swarm = { ...(config.Swarm || {}),\n        DisableNatPortMap: false\n      };\n      return config;\n    }\n  },\n  lowpower: {\n    description: 'Reduces daemon overhead on the system. May affect node functionality,performance of content discovery and data fetching may be degraded. Recommended for low power systems.',\n\n    /**\n     * @param {IPFSConfig} config\n     * @returns {IPFSConfig}\n     */\n    transform: config => {\n      const Swarm = config.Swarm || {};\n      const ConnMgr = Swarm.ConnMgr || {};\n      ConnMgr.LowWater = 20;\n      ConnMgr.HighWater = 40;\n      Swarm.ConnMgr = ConnMgr;\n      config.Swarm = Swarm;\n      return config;\n    }\n  },\n  'default-power': {\n    description: 'Inverse of \"lowpower\" profile.',\n\n    /**\n     * @param {IPFSConfig} config\n     * @returns {IPFSConfig}\n     */\n    transform: config => {\n      const defaultConfig = getDefaultConfig();\n      config.Swarm = defaultConfig.Swarm;\n      return config;\n    }\n  }\n};\nmodule.exports.profiles = profiles;\n/**\n * @typedef {Object} Config\n * @property {Get} get\n * @property {GetAll} getAll\n * @property {Set} set\n * @property {Replace} replace\n * @property {Profiles} profiles\n *\n * @callback Get\n * Returns the currently being used config. If the daemon is off, it returns\n * the stored config.\n *\n * @param {string} key - The key of the value that should be fetched from the\n * config file. If no key is passed, then the whole config will be returned.\n * @param {AbortOptions} [options]\n * @returns {Promise<ToJSON>} - An object containing the configuration of the IPFS node\n * @example\n * const config = await ipfs.config.get('Addresses.Swarm')\n * console.log(config)\n *\n *\n * @callback GetAll\n * Returns the full config been used. If the daemon is off, it returns the\n * stored config.\n *\n * @param {AbortOptions} [options]\n * @returns {Promise<IPFSConfig>}\n * @example\n * const config = await ipfs.config.getAll()\n * console.log(config)\n *\n * @callback Set\n * Adds or replaces a config value. Note that this operation will not spark the\n * restart of any service, i.e: if a config.replace changes the multiaddrs of\n * the Swarm, Swarm will have to be restarted manually for the changes to take\n * an effect.\n *\n * @param {string} key - The key of the value that should be added or replaced.\n * @param {ToJSON} value - The value to be set.\n * @param {AbortOptions} [options]\n * @returns {Promise<void>} - Promise succeeds if config change succeeded,\n * otherwise fails with error.\n * @example\n * // Disable MDNS Discovery\n * await ipfs.config.set('Discovery.MDNS.Enabled', false)\n *\n * @callback Replace\n * Adds or replaces a config file.\n *\n * Note that this operation will not spark the restart of any service,\n * i.e: if a config.replace changes the multiaddrs of the Swarm, Swarm will\n * have to be restarted manually for the changes to take an effect.\n *\n * @param {IPFSConfig} value - A new configuration.\n * @param {AbortOptions} [options]\n * @returns {Promise<void>}\n * @example\n * const newConfig = {\n *   Bootstrap: []\n * }\n * await ipfs.config.replace(newConfig)\n *\n * @typedef {Object} Profiles\n * @property {ListProfiles} list\n * @property {ApplyProfile} apply\n *\n * @callback ListProfiles\n * List available config profiles\n * @param {AbortOptions} [options]\n * @returns {Promise<Profile[]>} - An array with all the available config profiles\n * @example\n * const profiles = await ipfs.config.profiles.list()\n * profiles.forEach(profile => {\n *   console.info(profile.name, profile.description)\n * })\n *\n * @typedef {Object} Profile\n * @property {string} description\n * @property {string} name\n *\n *\n * @callback ApplyProfile\n * List available config profiles\n * @param {string} name\n * @param {ApplyOptions & AbortOptions} [options]\n * @returns {Promise<{original: IPFSConfig, updated: IPFSConfig}>}\n *\n * @typedef {Object} ApplyOptions\n * @property {boolean} [dryRun=false] - If true does not apply the profile\n *\n *\n * @typedef {Object} IPFSConfig\n * @property {AddressConfig} Addresses\n * @property {string} [Profiles]\n * @property {string[]} [Bootstrap]\n * @property {DiscoveryConfig} Discovery\n * @property {DatastoreConfig} [Datastore]\n * @property {IdentityConfig} [Identity]\n * @property {KeychainConfig} [Keychain]\n * @property {PubsubConfig} [Pubsub]\n * @property {SwarmConfig} [Swarm]\n * @property {RoutingConfig} [Routing]\n *\n * @typedef {Object} AddressConfig\n * Contains information about various listener addresses to be used by this node.\n * @property {APIAddress} [API='/ip4/127.0.0.1/tcp/5002']\n * @property {DelegateAddress} [Delegates=[]]\n * @property {GatewayAddress} [Gateway='/ip4/127.0.0.1/tcp/9090']\n * @property {SwarmAddress} [Swarm=['/ip4/0.0.0.0/tcp/4002', '/ip4/127.0.0.1/tcp/4003/ws']]\n * *\n * @typedef {string} Multiaddr\n * Composable and future-proof network address following [Multiaddr][]\n * specification.\n *\n * [Multiaddr]:https://github.com/multiformats/multiaddr/\n *\n * @typedef {Multiaddr|Multiaddr[]} APIAddress\n * The IPFS daemon exposes an [HTTP API][] that allows to control the node and\n * run the same commands as you can do from the command line. It is defined on\n * the [HTTP API][] Spec.\n *\n * [Multiaddr][] or array of [Multiaddr][] describing the address(es) to serve the\n * [HTTP API][] on.\n *\n * [Multiaddr]:https://github.com/multiformats/multiaddr/\n * [HTTP API]:https://docs.ipfs.io/reference/api/http\n *\n * @typedef {Multiaddr[]} DelegateAddress\n * Delegate peers are used to find peers and retrieve content from the network\n * on your behalf.\n *\n * Array of [Multiaddr][] describing which addresses to use as delegate nodes.\n *\n * [Multiaddr]:https://github.com/multiformats/multiaddr/\n *\n * @typedef {Multiaddr|Multiaddr[]} GatewayAddress\n * A gateway is exposed by the IPFS daemon, which allows an easy way to access\n * content from IPFS, using an IPFS path.\n *\n * [Multiaddr][] or array of [Multiaddr][] describing the address(es) to serve\n * the gateway on.\n *\n * [Multiaddr]:https://github.com/multiformats/multiaddr/\n *\n * @typedef {Multiaddr[]} SwarmAddress\n * Array of [Multiaddr][] describing which addresses to listen on for p2p swarm\n * connections.\n *\n * [Multiaddr]:https://github.com/multiformats/multiaddr/\n *\n *\n * @typedef {Multiaddr[]} BootstrapConfig\n * Bootstrap is an array of [Multiaddr][] of trusted nodes to connect to in order\n * to initiate a connection to the network.\n *\n * [Multiaddr]:https://github.com/multiformats/multiaddr/\n *\n * @typedef {Object} DatastoreConfig\n * Contains information related to the construction and operation of the on-disk\n * storage system.\n * @property {DatastoreSpec} [Spec]\n *\n * @typedef {Object} DatastoreSpec\n * Spec defines the structure of the IPFS datastore. It is a composable\n * structure, where each datastore is represented by a JSON object. Datastores\n * can wrap other datastores to provide extra functionality (e.g. metrics,\n * logging, or caching).\n *\n * This can be changed manually, however, if you make any changes that require\n * a different on-disk structure, you will need to run the [ipfs-ds-convert][]\n * tool to migrate data into the new structures.\n *\n * [ipfs-ds-convert]:https://github.com/ipfs/ipfs-ds-convert\n *\n * Default:\n * ```json\n * {\n *   \"mounts\": [\n *     {\n *       \"child\": {\n *         \"path\": \"blocks\",\n *        \"shardFunc\": \"/repo/flatfs/shard/v1/next-to-last/2\",\n *        \"sync\": true,\n *        \"type\": \"flatfs\"\n *      },\n *      \"mountpoint\": \"/blocks\",\n *      \"prefix\": \"flatfs.datastore\",\n *      \"type\": \"measure\"\n *    },\n *    {\n *      \"child\": {\n *        \"compression\": \"none\",\n *        \"path\": \"datastore\",\n *        \"type\": \"levelds\"\n *      },\n *      \"mountpoint\": \"/\",\n *      \"prefix\": \"leveldb.datastore\",\n *      \"type\": \"measure\"\n *    }\n *  ],\n *  \"type\": \"mount\"\n * }\n * ```\n *\n * @typedef {Object} DiscoveryConfig\n * Contains options for configuring IPFS node discovery mechanisms.\n * @property {MDNSDiscovery} MDNS\n * @property {WebRTCStarDiscovery} webRTCStar\n *\n * @typedef {Object} MDNSDiscovery\n * Multicast DNS is a discovery protocol that is able to find other peers on the local network.\n * @property {boolean} [Enabled=true] - A boolean value for whether or not MDNS\n * should be active.\n * @property {number} [Interval=10] - A number of seconds to wait between\n * discovery checks.\n *\n * @typedef {Object} WebRTCStarDiscovery\n * WebRTCStar is a discovery mechanism prvided by a signalling-star that allows\n * peer-to-peer communications in the browser.\n * @property {boolean} [Enabled=true] - A boolean value for whether or not\n * webRTCStar should be active.\n *\n * @typedef {Object} IdentityConfig\n * @property {PeerID} [PeerID]\n * @property {PrivateKey} [PrivKey]\n *\n * @typedef {string} PeerID\n * The unique PKI identity label for this configs peer. Set on init and never\n * read, its merely here for convenience. IPFS will always generate the peerID\n * from its keypair at runtime.\n *\n * @typedef {string} PrivateKey\n * The base64 encoded protobuf describing (and containing) the nodes private key.\n *\n * @typedef {Object} KeychainConfig\n * We can customize the key management and criptographically protected messages\n * by changing the Keychain options. Those options are used for generating the\n * derived encryption key (DEK).\n *\n * The DEK object, along with the passPhrase, is the input to a PBKDF2 function.\n *\n * You can check the [parameter choice for pbkdf2](https://cryptosense.com/parameter-choice-for-pbkdf2/)\n * for more information.\n * @property {DEK} DEK\n *\n * @typedef {Object} DEK\n * @property {number} keyLength\n * @property {number} iterationCount\n * @property {string} salt\n * @property {string} hash\n *\n * @typedef {Object} PubsubConfig\n * Options for configuring the pubsub subsystem. It is important pointing out\n * that this is not supported in the browser. If you want to configure a\n * different pubsub router in the browser you must configure\n * `libp2p.modules.pubsub` options instead.\n *\n * @property {PubSubRouter} [Router='gossipsub']\n * @property {boolean} [Enabled=true]\n *\n * @typedef {'gossipsub'|'floodsub'} PubSubRouter\n * A string value for specifying which pubsub routing protocol to use. You can\n * either use `'gossipsub'` in order to use the [ChainSafe/gossipsub-js]\n * (https://github.com/ChainSafe/gossipsub-js) implementation, or `'floodsub'`\n * to use the [libp2p/js-libp2p-floodsub](https://github.com/libp2p/js-libp2p-floodsub)\n * implementation.\n *\n * You can read more about these implementations on the [libp2p/specs/pubsub]\n * (https://github.com/libp2p/specs/tree/master/pubsub) document.\n *\n * @typedef {Object} SwarmConfig\n * Options for configuring the swarm.\n * @property {ConnMgrConfig} [ConnMgr]\n * @property {boolean} [DisableNatPortMap]\n *\n * @typedef {Object} ConnMgrConfig\n * The connection manager determines which and how many connections to keep and\n * can be configured to keep.\n *\n * The \"basic\" connection manager tries to keep between `LowWater` and\n * `HighWater` connections. It works by:\n *\n * 1. Keeping all connections until `HighWater` connections is reached.\n * 2. Once `HighWater` is reached, it closes connections until `LowWater` is\n * reached.\n *\n * @property {number} [LowWater=200] - The minimum number of connections to\n * maintain.\n * @property {number} [HighWater=500] - The number of connections that, when\n * exceeded, will trigger a connection GC operation.\n *\n * {{LowWater?:number, HighWater?:number}} ConnMgr\n *\n * @typedef {Object} RoutingConfig\n * @property {string} [Type]\n *\n * @typedef {import('ipfs-core-types/src/basic').ToJSON} ToJSON\n * @typedef {import('.').AbortOptions} AbortOptions\n */","map":null,"metadata":{},"sourceType":"script"}