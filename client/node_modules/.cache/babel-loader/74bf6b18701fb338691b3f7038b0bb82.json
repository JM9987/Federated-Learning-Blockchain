{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.IKHandshake = void 0;\n\nconst ik_1 = require(\"./handshakes/ik\");\n\nconst buffer_1 = require(\"buffer\");\n\nconst encoder_1 = require(\"./encoder\");\n\nconst utils_1 = require(\"./utils\");\n\nconst errors_1 = require(\"./errors\");\n\nconst logger_1 = require(\"./logger\");\n\nclass IKHandshake {\n  constructor(isInitiator, payload, prologue, staticKeypair, connection, remoteStaticKey, remotePeer, handshake) {\n    this.isInitiator = isInitiator;\n    this.payload = buffer_1.Buffer.from(payload);\n    this.prologue = prologue;\n    this.staticKeypair = staticKeypair;\n    this.connection = connection;\n\n    if (remotePeer) {\n      this.remotePeer = remotePeer;\n    }\n\n    this.ik = handshake !== null && handshake !== void 0 ? handshake : new ik_1.IK();\n    this.session = this.ik.initSession(this.isInitiator, this.prologue, this.staticKeypair, remoteStaticKey);\n    this.remoteEarlyData = buffer_1.Buffer.alloc(0);\n  }\n\n  async stage0() {\n    logger_1.logLocalStaticKeys(this.session.hs.s);\n    logger_1.logRemoteStaticKey(this.session.hs.rs);\n\n    if (this.isInitiator) {\n      logger_1.logger('IK Stage 0 - Initiator sending message...');\n      const messageBuffer = this.ik.sendMessage(this.session, this.payload);\n      this.connection.writeLP(encoder_1.encode1(messageBuffer));\n      logger_1.logger('IK Stage 0 - Initiator sent message.');\n      logger_1.logLocalEphemeralKeys(this.session.hs.e);\n    } else {\n      logger_1.logger('IK Stage 0 - Responder receiving message...');\n      const receivedMsg = await this.connection.readLP();\n\n      try {\n        const receivedMessageBuffer = encoder_1.decode1(receivedMsg.slice());\n\n        const _this$ik$recvMessage = this.ik.recvMessage(this.session, receivedMessageBuffer),\n              plaintext = _this$ik$recvMessage.plaintext,\n              valid = _this$ik$recvMessage.valid;\n\n        if (!valid) {\n          throw new Error('ik handshake stage 0 decryption validation fail');\n        }\n\n        logger_1.logger('IK Stage 0 - Responder got message, going to verify payload.');\n        const decodedPayload = await utils_1.decodePayload(plaintext);\n        this.remotePeer = this.remotePeer || (await utils_1.getPeerIdFromPayload(decodedPayload));\n        await utils_1.verifySignedPayload(this.session.hs.rs, decodedPayload, this.remotePeer);\n        this.setRemoteEarlyData(decodedPayload.data);\n        logger_1.logger('IK Stage 0 - Responder successfully verified payload!');\n        logger_1.logRemoteEphemeralKey(this.session.hs.re);\n      } catch (e) {\n        const err = e;\n        logger_1.logger('Responder breaking up with IK handshake in stage 0.');\n        throw new errors_1.FailedIKError(receivedMsg, \"Error occurred while verifying initiator's signed payload: \".concat(err.message));\n      }\n    }\n  }\n\n  async stage1() {\n    if (this.isInitiator) {\n      logger_1.logger('IK Stage 1 - Initiator receiving message...');\n      const receivedMsg = (await this.connection.readLP()).slice();\n      const receivedMessageBuffer = encoder_1.decode0(buffer_1.Buffer.from(receivedMsg));\n\n      const _this$ik$recvMessage2 = this.ik.recvMessage(this.session, receivedMessageBuffer),\n            plaintext = _this$ik$recvMessage2.plaintext,\n            valid = _this$ik$recvMessage2.valid;\n\n      logger_1.logger('IK Stage 1 - Initiator got message, going to verify payload.');\n\n      try {\n        if (!valid) {\n          throw new Error('ik stage 1 decryption validation fail');\n        }\n\n        const decodedPayload = await utils_1.decodePayload(plaintext);\n        this.remotePeer = this.remotePeer || (await utils_1.getPeerIdFromPayload(decodedPayload));\n        await utils_1.verifySignedPayload(receivedMessageBuffer.ns.slice(0, 32), decodedPayload, this.remotePeer);\n        this.setRemoteEarlyData(decodedPayload.data);\n        logger_1.logger('IK Stage 1 - Initiator successfully verified payload!');\n        logger_1.logRemoteEphemeralKey(this.session.hs.re);\n      } catch (e) {\n        const err = e;\n        logger_1.logger('Initiator breaking up with IK handshake in stage 1.');\n        throw new errors_1.FailedIKError(receivedMsg, \"Error occurred while verifying responder's signed payload: \".concat(err.message));\n      }\n    } else {\n      logger_1.logger('IK Stage 1 - Responder sending message...');\n      const messageBuffer = this.ik.sendMessage(this.session, this.payload);\n      this.connection.writeLP(encoder_1.encode0(messageBuffer));\n      logger_1.logger('IK Stage 1 - Responder sent message...');\n      logger_1.logLocalEphemeralKeys(this.session.hs.e);\n    }\n\n    logger_1.logCipherState(this.session);\n  }\n\n  decrypt(ciphertext, session) {\n    const cs = this.getCS(session, false);\n    return this.ik.decryptWithAd(cs, buffer_1.Buffer.alloc(0), ciphertext);\n  }\n\n  encrypt(plaintext, session) {\n    const cs = this.getCS(session);\n    return this.ik.encryptWithAd(cs, buffer_1.Buffer.alloc(0), plaintext);\n  }\n\n  getLocalEphemeralKeys() {\n    if (!this.session.hs.e) {\n      throw new Error('Ephemeral keys do not exist.');\n    }\n\n    return this.session.hs.e;\n  }\n\n  getCS(session, encryption = true) {\n    if (!session.cs1 || !session.cs2) {\n      throw new Error('Handshake not completed properly, cipher state does not exist.');\n    }\n\n    if (this.isInitiator) {\n      return encryption ? session.cs1 : session.cs2;\n    } else {\n      return encryption ? session.cs2 : session.cs1;\n    }\n  }\n\n  setRemoteEarlyData(data) {\n    if (data) {\n      this.remoteEarlyData = buffer_1.Buffer.from(data.buffer, data.byteOffset, data.length);\n    }\n  }\n\n}\n\nexports.IKHandshake = IKHandshake;","map":null,"metadata":{},"sourceType":"script"}