{"ast":null,"code":"/* eslint max-nested-callbacks: [\"error\", 8] */\n'use strict';\n\nconst PinManager = require('./pin-manager');\n\nconst PinTypes = PinManager.PinTypes;\n\nconst normaliseInput = require('ipfs-core-utils/src/pins/normalise-input');\n\nconst _require = require('../../utils'),\n      resolvePath = _require.resolvePath;\n\nconst withTimeoutOption = require('ipfs-core-utils/src/with-timeout-option');\n\nfunction toPin(type, cid, metadata) {\n  const output = {\n    type,\n    cid\n  };\n\n  if (metadata) {\n    output.metadata = metadata;\n  }\n\n  return output;\n}\n/**\n * @param {Object} config\n * @param {import('.').PinManager} config.pinManager\n * @param {import('.').DagReader} config.dagReader\n */\n\n\nmodule.exports = ({\n  pinManager,\n  dagReader\n}) => {\n  /**\n   * List all the objects pinned to local storage\n   *\n   * @param {LsOptions} [options]\n   * @returns {AsyncIterable<LsEntry>}\n   * @example\n   * ```js\n   * for await (const { cid, type } of ipfs.pin.ls()) {\n   *   console.log({ cid, type })\n   * }\n   * // { cid: CID(Qmc5XkteJdb337s7VwFBAGtiaoj2QCEzyxtNRy3iMudc3E), type: 'recursive' }\n   * // { cid: CID(QmZbj5ruYneZb8FuR9wnLqJCpCXMQudhSdWhdhp5U1oPWJ), type: 'indirect' }\n   * // { cid: CID(QmSo73bmN47gBxMNqbdV6rZ4KJiqaArqJ1nu5TvFhqqj1R), type: 'indirect' }\n   *\n   * const paths = [\n   *   CID.from('Qmc5..'),\n   *   CID.from('QmZb..'),\n   *   CID.from('QmSo..')\n   * ]\n   * for await (const { cid, type } of ipfs.pin.ls({ paths })) {\n   *   console.log({ cid, type })\n   * }\n   * // { cid: CID(Qmc5XkteJdb337s7VwFBAGtiaoj2QCEzyxtNRy3iMudc3E), type: 'recursive' }\n   * // { cid: CID(QmZbj5ruYneZb8FuR9wnLqJCpCXMQudhSdWhdhp5U1oPWJ), type: 'indirect' }\n   * // { cid: CID(QmSo73bmN47gBxMNqbdV6rZ4KJiqaArqJ1nu5TvFhqqj1R), type: 'indirect' }\n   * ```\n   */\n  async function* ls(options = {}) {\n    /** @type {PinQueryType} */\n    let type = PinTypes.all;\n\n    if (options.type) {\n      type = options.type;\n\n      if (typeof options.type === 'string') {\n        // @ts-ignore - Can't infer that string returned by toLowerCase() is PinQueryType\n        type = options.type.toLowerCase();\n      }\n\n      PinManager.checkPinType(type);\n    } else {\n      options.type = PinTypes.all;\n    }\n\n    if (options.paths) {\n      // check the pinned state of specific hashes\n      let matched = false;\n\n      for await (const _ref of normaliseInput(options.paths)) {\n        const path = _ref.path;\n        const cid = await resolvePath(dagReader, path);\n\n        const _ref2 = await pinManager.isPinnedWithType(cid, type),\n              reason = _ref2.reason,\n              pinned = _ref2.pinned,\n              parent = _ref2.parent,\n              metadata = _ref2.metadata;\n\n        if (!pinned) {\n          throw new Error(\"path '\".concat(path, \"' is not pinned\"));\n        }\n\n        switch (reason) {\n          case PinTypes.direct:\n          case PinTypes.recursive:\n            matched = true;\n            yield toPin(reason, cid, metadata);\n            break;\n\n          default:\n            matched = true;\n            yield toPin(\"\".concat(PinTypes.indirect, \" through \").concat(parent), cid, metadata);\n        }\n      }\n\n      if (!matched) {\n        throw new Error('No match found');\n      }\n\n      return;\n    }\n\n    if (type === PinTypes.recursive || type === PinTypes.all) {\n      for await (const _ref3 of pinManager.recursiveKeys()) {\n        const cid = _ref3.cid;\n        const metadata = _ref3.metadata;\n        yield toPin(PinTypes.recursive, cid, metadata);\n      }\n    }\n\n    if (type === PinTypes.indirect || type === PinTypes.all) {\n      // @ts-ignore - LsSettings & AbortOptions have no properties in common\n      // with type { preload?: boolean }\n      for await (const cid of pinManager.indirectKeys(options)) {\n        yield toPin(PinTypes.indirect, cid);\n      }\n    }\n\n    if (type === PinTypes.direct || type === PinTypes.all) {\n      for await (const _ref4 of pinManager.directKeys()) {\n        const cid = _ref4.cid;\n        const metadata = _ref4.metadata;\n        yield toPin(PinTypes.direct, cid, metadata);\n      }\n    }\n  }\n\n  return withTimeoutOption(ls);\n};\n/**\n * @typedef {LsSettings & AbortOptions} LsOptions\n *\n * @typedef {Object} LsSettings\n * @property {string[]|CID[]} [paths] - CIDs or IPFS paths to search for in the pinset.\n * @property {PinQueryType} [type] - Filter by this type of pin (\"recursive\", \"direct\" or \"indirect\")\n *\n * @typedef {Object} LsEntry\n * @property {CID} cid -  CID of the pinned node\n * @property {PinType} type -  Pin type (\"recursive\", \"direct\" or \"indirect\")\n *\n * @typedef {import('./pin-manager').PinType} PinType\n * @typedef {import('./pin-manager').PinQueryType} PinQueryType\n *\n * @typedef {import('.').AbortOptions} AbortOptions\n * @typedef {import('.').CID} CID\n */","map":null,"metadata":{},"sourceType":"script"}