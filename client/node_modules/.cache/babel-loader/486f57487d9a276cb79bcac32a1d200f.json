{"ast":null,"code":"'use strict';\n\nconst core = require('datastore-core');\n\nconst ShardingStore = core.ShardingDatastore;\n\nconst Block = require('ipld-block');\n\nconst _require = require('./blockstore-utils'),\n      cidToKey = _require.cidToKey,\n      keyToCid = _require.keyToCid;\n\nconst map = require('it-map');\n\nconst drain = require('it-drain');\n\nconst pushable = require('it-pushable');\n\nmodule.exports = async (filestore, options) => {\n  const store = await maybeWithSharding(filestore, options);\n  return createBaseStore(store);\n};\n\nfunction maybeWithSharding(filestore, options) {\n  if (options.sharding) {\n    const shard = new core.shard.NextToLast(2);\n    return ShardingStore.createOrOpen(filestore, shard);\n  }\n\n  return filestore;\n}\n\nfunction createBaseStore(store) {\n  return {\n    /**\n     * Query the store\n     *\n     * @param {Object} query\n     * @param {Object} options\n     * @returns {AsyncIterator<Block|CID>}\n     */\n    async *query(query, options) {\n      for await (const _ref of store.query(query, options)) {\n        const key = _ref.key;\n        const value = _ref.value;\n\n        if (query.keysOnly) {\n          yield keyToCid(key);\n          continue;\n        }\n\n        yield new Block(value, keyToCid(key));\n      }\n    },\n\n    /**\n     * Get a single block by CID\n     *\n     * @param {CID} cid\n     * @param {Object} options\n     * @returns {Promise<Block>}\n     */\n    async get(cid, options) {\n      const key = cidToKey(cid);\n      const blockData = await store.get(key, options);\n      return new Block(blockData, cid);\n    },\n\n    /**\n     * Like get, but for more\n     *\n     * @param {AsyncIterator<CID>} cids\n     * @param {Object} options\n     * @returns {AsyncIterator<Block>}\n     */\n    async *getMany(cids, options) {\n      for await (const cid of cids) {\n        yield this.get(cid, options);\n      }\n    },\n\n    /**\n     * Write a single block to the store\n     *\n     * @param {Block} block\n     * @param {Object} options\n     * @returns {Promise<Block>}\n     */\n    async put(block, options) {\n      if (!Block.isBlock(block)) {\n        throw new Error('invalid block');\n      }\n\n      const key = cidToKey(block.cid);\n      const exists = await store.has(key, options);\n\n      if (!exists) {\n        await store.put(key, block.data, options);\n      }\n\n      return block;\n    },\n\n    /**\n     * Like put, but for more\n     *\n     * @param {AsyncIterable<Block>|Iterable<Block>} blocks\n     * @param {Object} options\n     * @returns {AsyncIterable<Block>}\n     */\n    async *putMany(blocks, options) {\n      // eslint-disable-line require-await\n      // we cannot simply chain to `store.putMany` because we convert a CID into\n      // a key based on the multihash only, so we lose the version & codec and\n      // cannot give the user back the CID they used to create the block, so yield\n      // to `store.putMany` but return the actual block the user passed in.\n      //\n      // nb. we want to use `store.putMany` here so bitswap can control batching\n      // up block HAVEs to send to the network - if we use multiple `store.put`s\n      // it will not be able to guess we are about to `store.put` more blocks\n      const output = pushable(); // process.nextTick runs on the microtask queue, setImmediate runs on the next\n      // event loop iteration so is slower. Use process.nextTick if it is available.\n\n      const runner = process && process.nextTick ? process.nextTick : setImmediate;\n      runner(async () => {\n        try {\n          await drain(store.putMany(async function* () {\n            for await (const block of blocks) {\n              const key = cidToKey(block.cid);\n              const exists = await store.has(key, options);\n\n              if (!exists) {\n                yield {\n                  key,\n                  value: block.data\n                };\n              } // there is an assumption here that after the yield has completed\n              // the underlying datastore has finished writing the block\n\n\n              output.push(block);\n            }\n          }()));\n          output.end();\n        } catch (err) {\n          output.end(err);\n        }\n      });\n      yield* output;\n    },\n\n    /**\n     * Does the store contain block with this CID?\n     *\n     * @param {CID} cid\n     * @param {Object} options\n     * @returns {Promise<bool>}\n     */\n    async has(cid, options) {\n      // eslint-disable-line require-await\n      return store.has(cidToKey(cid), options);\n    },\n\n    /**\n     * Delete a block from the store\n     *\n     * @param {CID} cid\n     * @param {Object} options\n     * @returns {Promise<void>}\n     */\n    async delete(cid, options) {\n      // eslint-disable-line require-await\n      return store.delete(cidToKey(cid), options);\n    },\n\n    /**\n     * Delete a block from the store\n     *\n     * @param {AsyncIterable<CID>} cids\n     * @param {Object} options\n     * @returns {Promise<void>}\n     */\n    async *deleteMany(cids, options) {\n      // eslint-disable-line require-await\n      yield* store.deleteMany(map(cids, cid => cidToKey(cid)), options);\n    },\n\n    /**\n     * Close the store\n     *\n     * @returns {Promise<void>}\n     */\n    async close() {\n      // eslint-disable-line require-await\n      return store.close();\n    }\n\n  };\n}","map":null,"metadata":{},"sourceType":"script"}