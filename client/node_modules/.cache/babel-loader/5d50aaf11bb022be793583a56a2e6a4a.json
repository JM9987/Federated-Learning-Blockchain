{"ast":null,"code":"'use strict';\n\nconst ipns = require('ipns');\n\nconst PeerId = require('peer-id');\n\nconst errcode = require('err-code');\n\nconst debug = require('debug');\n\nconst log = Object.assign(debug('ipfs:ipns:resolver'), {\n  error: debug('ipfs:ipns:resolver:error')\n});\n\nconst uint8ArrayToString = require('uint8arrays/to-string');\n\nconst _require = require('interface-datastore'),\n      Errors = _require.Errors;\n\nconst ERR_NOT_FOUND = Errors.notFoundError().code;\nconst defaultMaximumRecursiveDepth = 32;\n\nclass IpnsResolver {\n  constructor(routing) {\n    this._routing = routing;\n  }\n\n  async resolve(name, options = {}) {\n    if (typeof name !== 'string') {\n      throw errcode(new Error('invalid name'), 'ERR_INVALID_NAME');\n    }\n\n    const recursive = options.recursive && options.recursive.toString() === 'true';\n    const nameSegments = name.split('/');\n\n    if (nameSegments.length !== 3 || nameSegments[0] !== '') {\n      throw errcode(new Error('invalid name'), 'ERR_INVALID_NAME');\n    }\n\n    const key = nameSegments[2]; // Define a maximum depth if recursive option enabled\n\n    let depth;\n\n    if (recursive) {\n      depth = defaultMaximumRecursiveDepth;\n    }\n\n    const res = await this.resolver(key, depth);\n    log(\"\".concat(name, \" was locally resolved correctly\"));\n    return res;\n  } // Recursive resolver according to the specified depth\n\n\n  async resolver(name, depth) {\n    // Exceeded recursive maximum depth\n    if (depth === 0) {\n      const errMsg = \"could not resolve name (recursion limit of \".concat(defaultMaximumRecursiveDepth, \" exceeded)\");\n      log.error(errMsg);\n      throw errcode(new Error(errMsg), 'ERR_RESOLVE_RECURSION_LIMIT');\n    }\n\n    const res = await this._resolveName(name);\n    const nameSegments = res.split('/'); // If obtained a ipfs cid or recursive option is disabled\n\n    if (nameSegments[1] === 'ipfs' || !depth) {\n      return res;\n    } // continue recursively until depth equals 0\n\n\n    return this.resolver(nameSegments[2], depth - 1);\n  } // resolve ipns entries from the provided routing\n\n\n  async _resolveName(name) {\n    const peerId = PeerId.createFromCID(name);\n\n    const _ipns$getIdKeys = ipns.getIdKeys(peerId.toBytes()),\n          routingKey = _ipns$getIdKeys.routingKey;\n\n    let record;\n\n    try {\n      record = await this._routing.get(routingKey.uint8Array());\n    } catch (err) {\n      log.error('could not get record from routing', err);\n\n      if (err.code === ERR_NOT_FOUND) {\n        throw errcode(new Error(\"record requested for \".concat(name, \" was not found in the network\")), 'ERR_NO_RECORD_FOUND');\n      }\n\n      throw errcode(new Error(\"unexpected error getting the ipns record \".concat(peerId.toString())), 'ERR_UNEXPECTED_ERROR_GETTING_RECORD');\n    } // IPNS entry\n\n\n    let ipnsEntry;\n\n    try {\n      ipnsEntry = ipns.unmarshal(record);\n    } catch (err) {\n      log.error('could not unmarshal record', err);\n      throw errcode(new Error('found ipns record that we couldn\\'t convert to a value'), 'ERR_INVALID_RECORD_RECEIVED');\n    } // We should have the public key by now (inline, or in the entry)\n\n\n    return this._validateRecord(peerId, ipnsEntry);\n  } // validate a resolved record\n\n\n  async _validateRecord(peerId, ipnsEntry) {\n    const pubKey = await ipns.extractPublicKey(peerId, ipnsEntry); // IPNS entry validation\n\n    await ipns.validate(pubKey, ipnsEntry);\n    return uint8ArrayToString(ipnsEntry.value);\n  }\n\n}\n\nexports = module.exports = IpnsResolver;","map":null,"metadata":{},"sourceType":"script"}