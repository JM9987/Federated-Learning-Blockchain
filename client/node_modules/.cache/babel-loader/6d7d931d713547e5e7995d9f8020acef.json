{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Heartbeat = void 0;\n\nconst constants = __importStar(require(\"./constants\"));\n\nconst get_gossip_peers_1 = require(\"./get-gossip-peers\");\n\nconst utils_1 = require(\"./utils\"); // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n\n\nclass Heartbeat {\n  /**\n   * @param {Object} gossipsub\n   * @constructor\n   */\n  constructor(gossipsub) {\n    this.gossipsub = gossipsub;\n  }\n\n  start() {\n    if (this._heartbeatTimer) {\n      return;\n    }\n\n    const heartbeat = this._heartbeat.bind(this);\n\n    const timeout = setTimeout(() => {\n      heartbeat();\n\n      this._heartbeatTimer.runPeriodically(heartbeat, constants.GossipsubHeartbeatInterval);\n    }, constants.GossipsubHeartbeatInitialDelay);\n    this._heartbeatTimer = {\n      _intervalId: undefined,\n      runPeriodically: (fn, period) => {\n        this._heartbeatTimer._intervalId = setInterval(fn, period);\n      },\n      cancel: () => {\n        clearTimeout(timeout);\n        clearInterval(this._heartbeatTimer._intervalId);\n      }\n    };\n  }\n  /**\n   * Unmounts the gossipsub protocol and shuts down every connection\n   * @override\n   * @returns {void}\n   */\n\n\n  stop() {\n    if (!this._heartbeatTimer) {\n      return;\n    }\n\n    this._heartbeatTimer.cancel();\n\n    this._heartbeatTimer = null;\n  }\n  /**\n   * Maintains the mesh and fanout maps in gossipsub.\n   *\n   * @returns {void}\n   */\n\n\n  _heartbeat() {\n    const _this$gossipsub$_opti = this.gossipsub._options,\n          D = _this$gossipsub$_opti.D,\n          Dlo = _this$gossipsub$_opti.Dlo,\n          Dhi = _this$gossipsub$_opti.Dhi,\n          Dscore = _this$gossipsub$_opti.Dscore,\n          Dout = _this$gossipsub$_opti.Dout;\n    this.gossipsub.heartbeatTicks++; // cache scores throught the heartbeat\n\n    const scores = new Map();\n\n    const getScore = id => {\n      let s = scores.get(id);\n\n      if (s === undefined) {\n        s = this.gossipsub.score.score(id);\n        scores.set(id, s);\n      }\n\n      return s;\n    }; // peer id => topic[]\n\n\n    const tograft = new Map(); // peer id => topic[]\n\n    const toprune = new Map(); // peer id => don't px\n\n    const noPX = new Map(); // clean up expired backoffs\n\n    this.gossipsub._clearBackoff(); // clean up peerhave/iasked counters\n\n\n    this.gossipsub.peerhave.clear();\n    this.gossipsub.iasked.clear(); // apply IWANT request penalties\n\n    this.gossipsub._applyIwantPenalties(); // ensure direct peers are connected\n\n\n    this.gossipsub._directConnect(); // maintain the mesh for topics we have joined\n\n\n    this.gossipsub.mesh.forEach((peers, topic) => {\n      // prune/graft helper functions (defined per topic)\n      const prunePeer = id => {\n        this.gossipsub.log('HEARTBEAT: Remove mesh link to %s in %s', id, topic); // update peer score\n\n        this.gossipsub.score.prune(id, topic); // add prune backoff record\n\n        this.gossipsub._addBackoff(id, topic); // remove peer from mesh\n\n\n        peers.delete(id); // add to toprune\n\n        const topics = toprune.get(id);\n\n        if (!topics) {\n          toprune.set(id, [topic]);\n        } else {\n          topics.push(topic);\n        }\n      };\n\n      const graftPeer = id => {\n        this.gossipsub.log('HEARTBEAT: Add mesh link to %s in %s', id, topic); // update peer score\n\n        this.gossipsub.score.graft(id, topic); // add peer to mesh\n\n        peers.add(id); // add to tograft\n\n        const topics = tograft.get(id);\n\n        if (!topics) {\n          tograft.set(id, [topic]);\n        } else {\n          topics.push(topic);\n        }\n      }; // drop all peers with negative score, without PX\n\n\n      peers.forEach(id => {\n        const score = getScore(id);\n\n        if (score < 0) {\n          this.gossipsub.log('HEARTBEAT: Prune peer %s with negative score: score=%d, topic=%s', id, score, topic);\n          prunePeer(id);\n          noPX.set(id, true);\n        }\n      }); // do we have enough peers?\n\n      if (peers.size < Dlo) {\n        const backoff = this.gossipsub.backoff.get(topic);\n        const ineed = D - peers.size;\n        const peersSet = get_gossip_peers_1.getGossipPeers(this.gossipsub, topic, ineed, id => {\n          // filter out mesh peers, direct peers, peers we are backing off, peers with negative score\n          return !peers.has(id) && !this.gossipsub.direct.has(id) && (!backoff || !backoff.has(id)) && getScore(id) >= 0;\n        });\n        peersSet.forEach(graftPeer);\n      } // do we have to many peers?\n\n\n      if (peers.size > Dhi) {\n        let peersArray = Array.from(peers); // sort by score\n\n        peersArray.sort((a, b) => getScore(b) - getScore(a)); // We keep the first D_score peers by score and the remaining up to D randomly\n        // under the constraint that we keep D_out peers in the mesh (if we have that many)\n\n        peersArray = peersArray.slice(0, Dscore).concat(utils_1.shuffle(peersArray.slice(Dscore))); // count the outbound peers we are keeping\n\n        let outbound = 0;\n        peersArray.slice(0, D).forEach(p => {\n          if (this.gossipsub.outbound.get(p)) {\n            outbound++;\n          }\n        }); // if it's less than D_out, bubble up some outbound peers from the random selection\n\n        if (outbound < Dout) {\n          const rotate = i => {\n            // rotate the peersArray to the right and put the ith peer in the front\n            const p = peersArray[i];\n\n            for (let j = i; j > 0; j--) {\n              peersArray[j] = peersArray[j - 1];\n            }\n\n            peersArray[0] = p;\n          }; // first bubble up all outbound peers already in the selection to the front\n\n\n          if (outbound > 0) {\n            let ihave = outbound;\n\n            for (let i = 1; i < D && ihave > 0; i++) {\n              if (this.gossipsub.outbound.get(peersArray[i])) {\n                rotate(i);\n                ihave--;\n              }\n            }\n          } // now bubble up enough outbound peers outside the selection to the front\n\n\n          let ineed = D - outbound;\n\n          for (let i = D; i < peersArray.length && ineed > 0; i++) {\n            if (this.gossipsub.outbound.get(peersArray[i])) {\n              rotate(i);\n              ineed--;\n            }\n          }\n        } // prune the excess peers\n\n\n        peersArray.slice(D).forEach(prunePeer);\n      } // do we have enough outbound peers?\n\n\n      if (peers.size >= Dlo) {\n        // count the outbound peers we have\n        let outbound = 0;\n        peers.forEach(p => {\n          if (this.gossipsub.outbound.get(p)) {\n            outbound++;\n          }\n        }); // if it's less than D_out, select some peers with outbound connections and graft them\n\n        if (outbound < Dout) {\n          const ineed = Dout - outbound;\n          const backoff = this.gossipsub.backoff.get(topic);\n          get_gossip_peers_1.getGossipPeers(this.gossipsub, topic, ineed, id => {\n            // filter our current mesh peers, direct peers, peers we are backing off, peers with negative score\n            return !peers.has(id) && !this.gossipsub.direct.has(id) && (!backoff || !backoff.has(id)) && getScore(id) >= 0;\n          }).forEach(graftPeer);\n        }\n      } // should we try to improve the mesh with opportunistic grafting?\n\n\n      if (this.gossipsub.heartbeatTicks % constants.GossipsubOpportunisticGraftTicks === 0 && peers.size > 1) {\n        // Opportunistic grafting works as follows: we check the median score of peers in the\n        // mesh; if this score is below the opportunisticGraftThreshold, we select a few peers at\n        // random with score over the median.\n        // The intention is to (slowly) improve an underperforming mesh by introducing good\n        // scoring peers that may have been gossiping at us. This allows us to get out of sticky\n        // situations where we are stuck with poor peers and also recover from churn of good peers.\n        // now compute the median peer score in the mesh\n        const peersList = Array.from(peers).sort((a, b) => getScore(a) - getScore(b));\n        const medianIndex = peers.size / 2;\n        const medianScore = getScore(peersList[medianIndex]); // if the median score is below the threshold, select a better peer (if any) and GRAFT\n\n        if (medianScore < this.gossipsub._options.scoreThresholds.opportunisticGraftThreshold) {\n          const backoff = this.gossipsub.backoff.get(topic);\n          const peersToGraft = get_gossip_peers_1.getGossipPeers(this.gossipsub, topic, constants.GossipsubOpportunisticGraftPeers, id => {\n            // filter out current mesh peers, direct peers, peers we are backing off, peers below or at threshold\n            return peers.has(id) && !this.gossipsub.direct.has(id) && (!backoff || !backoff.has(id)) && getScore(id) > medianScore;\n          });\n          peersToGraft.forEach(id => {\n            this.gossipsub.log('HEARTBEAT: Opportunistically graft peer %s on topic %s', id, topic);\n            graftPeer(id);\n          });\n        }\n      } // 2nd arg are mesh peers excluded from gossip. We have already pushed\n      // messages to them, so its redundant to gossip IHAVEs.\n\n\n      this.gossipsub._emitGossip(topic, peers);\n    }); // expire fanout for topics we haven't published to in a while\n\n    const now = this.gossipsub._now();\n\n    this.gossipsub.lastpub.forEach((lastpb, topic) => {\n      if (lastpb + constants.GossipsubFanoutTTL < now) {\n        this.gossipsub.fanout.delete(topic);\n        this.gossipsub.lastpub.delete(topic);\n      }\n    }); // maintain our fanout for topics we are publishing but we have not joined\n\n    this.gossipsub.fanout.forEach((fanoutPeers, topic) => {\n      // checks whether our peers are still in the topic and have a score above the publish threshold\n      const topicPeers = this.gossipsub.topics.get(topic);\n      fanoutPeers.forEach(id => {\n        if (!topicPeers.has(id) || getScore(id) < this.gossipsub._options.scoreThresholds.publishThreshold) {\n          fanoutPeers.delete(id);\n        }\n      }); // do we need more peers?\n\n      if (fanoutPeers.size < D) {\n        const ineed = D - fanoutPeers.size;\n        const peersSet = get_gossip_peers_1.getGossipPeers(this.gossipsub, topic, ineed, id => {\n          // filter out existing fanout peers, direct peers, and peers with score above the publish threshold\n          return !fanoutPeers.has(id) && !this.gossipsub.direct.has(id) && getScore(id) >= this.gossipsub._options.scoreThresholds.publishThreshold;\n        });\n        peersSet.forEach(id => {\n          fanoutPeers.add(id);\n        });\n      } // 2nd arg are fanout peers excluded from gossip.\n      // We have already pushed messages to them, so its redundant to gossip IHAVEs\n\n\n      this.gossipsub._emitGossip(topic, fanoutPeers);\n    }); // send coalesced GRAFT/PRUNE messages (will piggyback gossip)\n\n    this.gossipsub._sendGraftPrune(tograft, toprune, noPX); // flush pending gossip that wasn't piggybacked above\n\n\n    this.gossipsub._flush(); // advance the message history window\n\n\n    this.gossipsub.messageCache.shift();\n    this.gossipsub.emit('gossipsub:heartbeat');\n  }\n\n}\n\nexports.Heartbeat = Heartbeat;","map":null,"metadata":{},"sourceType":"script"}