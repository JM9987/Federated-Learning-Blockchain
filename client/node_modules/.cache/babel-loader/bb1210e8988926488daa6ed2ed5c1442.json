{"ast":null,"code":"'use strict';\n\nconst NatAPI = require('@motrix/nat-api');\n\nconst debug = require('debug');\n\nconst _require = require('es6-promisify'),\n      promisify = _require.promisify;\n\nconst Multiaddr = require('multiaddr');\n\nconst log = Object.assign(debug('libp2p:nat'), {\n  error: debug('libp2p:nat:err')\n});\n\nconst _require2 = require('ipfs-utils/src/env'),\n      isBrowser = _require2.isBrowser;\n\nconst retry = require('p-retry');\n\nconst isPrivateIp = require('private-ip');\n\nconst pkg = require('../package.json');\n\nconst errcode = require('err-code');\n\nconst _require3 = require('./errors'),\n      ERR_INVALID_PARAMETERS = _require3.codes.ERR_INVALID_PARAMETERS;\n\nconst isLoopback = require('libp2p-utils/src/multiaddr/is-loopback');\n/**\n * @typedef {import('peer-id')} PeerId\n * @typedef {import('./transport-manager')} TransportManager\n * @typedef {import('./address-manager')} AddressManager\n */\n\n\nfunction highPort(min = 1024, max = 65535) {\n  return Math.floor(Math.random() * (max - min + 1) + min);\n}\n\nconst DEFAULT_TTL = 7200;\n\nclass NatManager {\n  /**\n   * @class\n   * @param {object} options\n   * @param {PeerId} options.peerId - The peer ID of the current node\n   * @param {TransportManager} options.transportManager - A transport manager\n   * @param {AddressManager} options.addressManager - An address manager\n   * @param {boolean} options.enabled - Whether to enable the NAT manager\n   * @param {string} [options.externalIp] - Pass a value to use instead of auto-detection\n   * @param {string} [options.description] - A string value to use for the port mapping description on the gateway\n   * @param {number} [options.ttl] - How long UPnP port mappings should last for in seconds (minimum 1200)\n   * @param {boolean} [options.keepAlive] - Whether to automatically refresh UPnP port mappings when their TTL is reached\n   * @param {string} [options.gateway] - Pass a value to use instead of auto-detection\n   * @param {object} [options.pmp] - PMP options\n   * @param {boolean} [options.pmp.enabled] - Whether to enable PMP as well as UPnP\n   */\n  constructor({\n    peerId,\n    addressManager,\n    transportManager,\n    ...options\n  }) {\n    this._peerId = peerId;\n    this._addressManager = addressManager;\n    this._transportManager = transportManager;\n    this._enabled = options.enabled;\n    this._externalIp = options.externalIp;\n    this._options = {\n      description: options.description || \"\".concat(pkg.name, \"@\").concat(pkg.version, \" \").concat(this._peerId),\n      ttl: options.ttl || DEFAULT_TTL,\n      autoUpdate: options.keepAlive || true,\n      gateway: options.gateway,\n      enablePMP: Boolean(options.pmp && options.pmp.enabled)\n    };\n\n    if (this._options.ttl < DEFAULT_TTL) {\n      throw errcode(new Error(\"NatManager ttl should be at least \".concat(DEFAULT_TTL, \" seconds\")), ERR_INVALID_PARAMETERS);\n    }\n  }\n  /**\n   * Starts the NAT manager\n   */\n\n\n  start() {\n    if (isBrowser || !this._enabled) {\n      return;\n    } // done async to not slow down startup\n\n\n    this._start().catch(err => {\n      // hole punching errors are non-fatal\n      log.error(err);\n    });\n  }\n\n  async _start() {\n    const addrs = this._transportManager.getAddrs();\n\n    for (const addr of addrs) {\n      // try to open uPnP ports for each thin waist address\n      const _addr$toOptions = addr.toOptions(),\n            family = _addr$toOptions.family,\n            host = _addr$toOptions.host,\n            port = _addr$toOptions.port,\n            transport = _addr$toOptions.transport;\n\n      if (!addr.isThinWaistAddress() || transport !== 'tcp') {\n        // only bare tcp addresses\n        continue;\n      }\n\n      if (isLoopback(addr)) {\n        continue;\n      }\n\n      if (family !== 'ipv4') {\n        // ignore ipv6\n        continue;\n      }\n\n      const client = this._getClient();\n\n      const publicIp = this._externalIp || (await client.externalIp());\n\n      if (isPrivateIp(publicIp)) {\n        throw new Error(\"\".concat(publicIp, \" is private - please set config.nat.externalIp to an externally routable IP or ensure you are not behind a double NAT\"));\n      }\n\n      const publicPort = highPort();\n      log(\"opening uPnP connection from \".concat(publicIp, \":\").concat(publicPort, \" to \").concat(host, \":\").concat(port));\n      await client.map({\n        publicPort,\n        privatePort: port,\n        protocol: transport.toUpperCase()\n      });\n\n      this._addressManager.addObservedAddr(Multiaddr.fromNodeAddress({\n        family: 'IPv4',\n        address: publicIp,\n        port: \"\".concat(publicPort)\n      }, transport));\n    }\n  }\n\n  _getClient() {\n    if (this._client) {\n      return this._client;\n    }\n\n    const client = new NatAPI(this._options);\n    /** @type {(...any) => any} */\n\n    const map = promisify(client.map.bind(client));\n    /** @type {(...any) => any} */\n\n    const destroy = promisify(client.destroy.bind(client));\n    /** @type {(...any) => any} */\n\n    const externalIp = promisify(client.externalIp.bind(client)); // these are all network operations so add a retry\n\n    this._client = {\n      /**\n       * @param  {...any} args\n       * @returns {Promise<void>}\n       */\n      map: (...args) => retry(() => map(...args), {\n        onFailedAttempt: log.error,\n        unref: true\n      }),\n\n      /**\n       * @param  {...any} args\n       * @returns {Promise<void>}\n       */\n      destroy: (...args) => retry(() => destroy(...args), {\n        onFailedAttempt: log.error,\n        unref: true\n      }),\n\n      /**\n       * @param  {...any} args\n       * @returns {Promise<string>}\n       */\n      externalIp: (...args) => retry(() => externalIp(...args), {\n        onFailedAttempt: log.error,\n        unref: true\n      })\n    };\n    return this._client;\n  }\n  /**\n   * Stops the NAT manager\n   *\n   * @async\n   */\n\n\n  async stop() {\n    if (isBrowser || !this._client) {\n      return;\n    }\n\n    try {\n      await this._client.destroy();\n      this._client = null;\n    } catch (err) {\n      log.error(err);\n    }\n  }\n\n}\n\nmodule.exports = NatManager;","map":null,"metadata":{},"sourceType":"script"}