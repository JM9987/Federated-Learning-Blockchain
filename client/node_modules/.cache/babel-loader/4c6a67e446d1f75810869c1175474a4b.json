{"ast":null,"code":"'use strict';\n\nconst IPFSBitswap = require('ipfs-bitswap');\n\nconst createLibP2P = require('./libp2p');\n\nconst Multiaddr = require('multiaddr');\n\nconst errCode = require('err-code');\n\nclass Network {\n  /**\n   * @param {PeerId} peerId\n   * @param {LibP2P} libp2p\n   * @param {BitSwap} bitswap\n   */\n  constructor(peerId, libp2p, bitswap) {\n    this.peerId = peerId;\n    this.libp2p = libp2p;\n    this.bitswap = bitswap;\n  }\n  /**\n   * @param {Options} options\n   */\n\n\n  static async start({\n    peerId,\n    repo,\n    print,\n    options\n  }) {\n    // Need to ensure that repo is open as it could have been closed between\n    // `init` and `start`.\n    if (repo.closed) {\n      await repo.open();\n    }\n\n    const config = await repo.config.getAll();\n    const libp2p = createLibP2P({\n      options,\n      repo,\n      peerId,\n      multiaddrs: readAddrs(peerId, config),\n      config,\n      keychainConfig: undefined\n    });\n\n    if (libp2p.keychain) {\n      await libp2p.loadKeychain();\n    }\n\n    await libp2p.start();\n\n    for (const ma of libp2p.multiaddrs) {\n      print(\"Swarm listening on \".concat(ma, \"/p2p/\").concat(peerId.toB58String()));\n    }\n\n    const bitswap = new IPFSBitswap(libp2p, repo.blocks, {\n      statsEnabled: true\n    });\n    await bitswap.start();\n    return new Network(peerId, libp2p, bitswap);\n  }\n  /**\n   * @param {Network} network\n   */\n\n\n  static async stop(network) {\n    await Promise.all([network.bitswap.stop(), network.libp2p.stop()]);\n  }\n\n}\n\nmodule.exports = Network;\n/**\n *\n * @param {PeerId} peerId\n * @param {IPFSConfig} config\n * @returns {Multiaddr[]}\n */\n\nconst readAddrs = (peerId, config) => {\n  const peerIdStr = peerId.toB58String();\n  /** @type {Multiaddr[]} */\n\n  const addrs = [];\n  const swarm = config.Addresses && config.Addresses.Swarm || [];\n\n  for (const addr of swarm) {\n    let ma = Multiaddr(addr); // Temporary error for users migrating using websocket-star multiaddrs for listenning on libp2p\n    // websocket-star support was removed from ipfs and libp2p\n\n    if (ma.protoCodes().includes(WEBSOCKET_STAR_PROTO_CODE)) {\n      throw errCode(new Error('websocket-star swarm addresses are not supported. See https://github.com/ipfs/js-ipfs/issues/2779'), 'ERR_WEBSOCKET_STAR_SWARM_ADDR_NOT_SUPPORTED');\n    } // multiaddrs that go via a signalling server or other intermediary (e.g. stardust,\n    // webrtc-star) can have the intermediary's peer ID in the address, so append our\n    // peer ID to the end of it\n\n\n    const maId = ma.getPeerId();\n\n    if (maId && maId !== peerIdStr) {\n      ma = ma.encapsulate(\"/p2p/\".concat(peerIdStr));\n    }\n\n    addrs.push(ma);\n  }\n\n  return addrs;\n};\n\nconst WEBSOCKET_STAR_PROTO_CODE = 479;\n/**\n * @typedef {Object} Online\n * @property {LibP2P} libp2p\n * @property {BitSwap} bitswap\n *\n * @typedef {Object} Options\n * @property {PeerId} options.peerId\n * @property {Repo} options.repo\n * @property {Print} options.print\n * @property {IPFSOptions} options.options\n *\n * @typedef {import('.').IPFSConfig} IPFSConfig\n * @typedef {import('.').Options} IPFSOptions\n * @typedef {import('.').Repo} Repo\n * @typedef {import('.').Print} Print\n * @typedef {import('.').LibP2P} LibP2P\n * @typedef {import('ipfs-core-types/src/bitswap').Bitswap} BitSwap\n * @typedef {import('.').PeerId} PeerId\n * @typedef {import('.').AbortOptions} AbortOptions\n */","map":null,"metadata":{},"sourceType":"script"}