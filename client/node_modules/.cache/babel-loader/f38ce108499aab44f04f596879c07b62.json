{"ast":null,"code":"\"use strict\";\n\nvar _slicedToArray = require(\"/home/ubuntu/TFG_FL/client/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nconst pubsub_1 = __importStar(require(\"libp2p-interfaces/src/pubsub\"));\n\nconst message_cache_1 = require(\"./message-cache\");\n\nconst message_1 = require(\"./message\");\n\nconst constants = __importStar(require(\"./constants\"));\n\nconst heartbeat_1 = require(\"./heartbeat\");\n\nconst get_gossip_peers_1 = require(\"./get-gossip-peers\");\n\nconst utils_1 = require(\"./utils\");\n\nconst score_1 = require(\"./score\");\n\nconst tracer_1 = require(\"./tracer\"); // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n// @ts-ignore\n\n\nconst TimeCache = require(\"time-cache\");\n\nconst PeerId = require(\"peer-id\"); // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n// @ts-ignore\n\n\nconst Envelope = require(\"libp2p/src/record/envelope\");\n\nclass Gossipsub extends pubsub_1.default {\n  // TODO: add remaining props\n\n  /**\n   * @param {Libp2p} libp2p\n   * @param {Object} [options]\n   * @param {boolean} [options.emitSelf = false] if publish should emit to self, if subscribed\n   * @param {boolean} [options.canRelayMessage = false] - if can relay messages not subscribed\n   * @param {boolean} [options.gossipIncoming = true] if incoming messages on a subscribed topic should be automatically gossiped\n   * @param {boolean} [options.fallbackToFloodsub = true] if dial should fallback to floodsub\n   * @param {boolean} [options.floodPublish = true] if self-published messages should be sent to all peers\n   * @param {boolean} [options.doPX = false] whether PX is enabled; this should be enabled in bootstrappers and other well connected/trusted nodes.\n   * @param {Object} [options.messageCache] override the default MessageCache\n   * @param {string} [options.globalSignaturePolicy = \"StrictSign\"] signing policy to apply across all messages\n   * @param {Object} [options.scoreParams] peer score parameters\n   * @param {Object} [options.scoreThresholds] peer score thresholds\n   * @param {AddrInfo[]} [options.directPeers] peers with which we will maintain direct connections\n   * @constructor\n   */\n  constructor(libp2p, options = {}) {\n    const multicodecs = [constants.GossipsubIDv11, constants.GossipsubIDv10];\n    const opts = Object.assign(Object.assign({\n      gossipIncoming: true,\n      fallbackToFloodsub: true,\n      floodPublish: true,\n      doPX: false,\n      directPeers: [],\n      D: constants.GossipsubD,\n      Dlo: constants.GossipsubDlo,\n      Dhi: constants.GossipsubDhi,\n      Dscore: constants.GossipsubDscore,\n      Dout: constants.GossipsubDout,\n      Dlazy: constants.GossipsubDlazy\n    }, options), {\n      scoreParams: score_1.createPeerScoreParams(options.scoreParams),\n      scoreThresholds: score_1.createPeerScoreThresholds(options.scoreThresholds)\n    }); // Also wants to get notified of peers connected using floodsub\n\n    if (opts.fallbackToFloodsub) {\n      multicodecs.push(constants.FloodsubID);\n    }\n\n    super(Object.assign({\n      debugName: 'libp2p:gossipsub',\n      multicodecs,\n      libp2p\n    }, opts));\n    this._options = opts;\n    /**\n     * Direct peers\n     * @type {Set<string>}\n     */\n\n    this.direct = new Set(opts.directPeers.map(p => p.id.toB58String())); // set direct peer addresses in the address book\n\n    opts.directPeers.forEach(p => {\n      libp2p.peerStore.addressBook.add(p.id, p.addrs);\n    });\n    /**\n     * Cache of seen messages\n     *\n     * @type {TimeCache}\n     */\n\n    this.seenCache = new TimeCache();\n    /**\n     * Map of topic meshes\n     * topic => peer id set\n     *\n     * @type {Map<string, Set<string>>}\n     */\n\n    this.mesh = new Map();\n    /**\n     * Map of topics to set of peers. These mesh peers are the ones to which we are publishing without a topic membership\n     * topic => peer id set\n     *\n     * @type {Map<string, Set<string>>}\n     */\n\n    this.fanout = new Map();\n    /**\n     * Map of last publish time for fanout topics\n     * topic => last publish time\n     *\n     * @type {Map<string, number>}\n     */\n\n    this.lastpub = new Map();\n    /**\n     * Map of pending messages to gossip\n     * peer id => control messages\n     *\n     * @type {Map<string, Array<ControlIHave object>> }\n     */\n\n    this.gossip = new Map();\n    /**\n     * Map of control messages\n     * peer id => control message\n     *\n     * @type {Map<string, ControlMessage object>}\n     */\n\n    this.control = new Map();\n    /**\n     * Number of IHAVEs received from peer in the last heartbeat\n     * @type {Map<string, number>}\n     */\n\n    this.peerhave = new Map();\n    /**\n     * Number of messages we have asked from peer in the last heartbeat\n     * @type {Map<string, number>}\n     */\n\n    this.iasked = new Map();\n    /**\n     * Prune backoff map\n     */\n\n    this.backoff = new Map();\n    /**\n     * Connection direction cache, marks peers with outbound connections\n     * peer id => direction\n     *\n     * @type {Map<string, boolean>}\n     */\n\n    this.outbound = new Map();\n    /**\n     * A message cache that contains the messages for last few hearbeat ticks\n     *\n     */\n\n    this.messageCache = options.messageCache || new message_cache_1.MessageCache(constants.GossipsubHistoryGossip, constants.GossipsubHistoryLength, this.getMsgId.bind(this));\n    /**\n     * A heartbeat timer that maintains the mesh\n     */\n\n    this.heartbeat = new heartbeat_1.Heartbeat(this);\n    /**\n     * Number of heartbeats since the beginning of time\n     * This allows us to amortize some resource cleanup -- eg: backoff cleanup\n     */\n\n    this.heartbeatTicks = 0;\n    /**\n     * Tracks IHAVE/IWANT promises broken by peers\n     */\n\n    this.gossipTracer = new tracer_1.IWantTracer(this.getMsgId.bind(this));\n    /**\n     * libp2p\n     */\n\n    this._libp2p = libp2p;\n    /**\n     * Peer score tracking\n     */\n\n    this.score = new score_1.PeerScore(this._options.scoreParams, libp2p.connectionManager, this.getMsgId.bind(this));\n  }\n  /**\n   * Decode a Uint8Array into an RPC object\n   * Overrided to use an extended protocol-specific protobuf decoder\n   * @override\n   * @param {Uint8Array} bytes\n   * @returns {RPC}\n   */\n\n\n  _decodeRpc(bytes) {\n    return message_1.RPCCodec.decode(bytes);\n  }\n  /**\n   * Encode an RPC object into a Uint8Array\n   * Overrided to use an extended protocol-specific protobuf encoder\n   * @override\n   * @param {RPC} rpc\n   * @returns {Uint8Array}\n   */\n\n\n  _encodeRpc(rpc) {\n    return message_1.RPCCodec.encode(rpc);\n  }\n  /**\n   * Add a peer to the router\n   * @override\n   * @param {PeerId} peerId\n   * @param {string} protocol\n   * @returns {PeerStreams}\n   */\n\n\n  _addPeer(peerId, protocol) {\n    const p = super._addPeer(peerId, protocol); // Add to peer scoring\n\n\n    this.score.addPeer(peerId.toB58String()); // track the connection direction\n\n    let outbound = false;\n\n    for (const c of this._libp2p.connectionManager.getAll(peerId)) {\n      if (c.stat.direction === 'outbound') {\n        if (Array.from(c.registry.values()).some(rvalue => protocol === rvalue.protocol)) {\n          outbound = true;\n          break;\n        }\n      }\n    }\n\n    this.outbound.set(p.id.toB58String(), outbound);\n    return p;\n  }\n  /**\n   * Removes a peer from the router\n   * @override\n   * @param {PeerId} peer\n   * @returns {PeerStreams | undefined}\n   */\n\n\n  _removePeer(peerId) {\n    const peerStreams = super._removePeer(peerId);\n\n    const id = peerId.toB58String(); // Remove this peer from the mesh\n    // eslint-disable-next-line no-unused-vars\n\n    for (const peers of this.mesh.values()) {\n      peers.delete(id);\n    } // Remove this peer from the fanout\n    // eslint-disable-next-line no-unused-vars\n\n\n    for (const peers of this.fanout.values()) {\n      peers.delete(id);\n    } // Remove from gossip mapping\n\n\n    this.gossip.delete(id); // Remove from control mapping\n\n    this.control.delete(id); // Remove from backoff mapping\n\n    this.outbound.delete(id); // Remove from peer scoring\n\n    this.score.removePeer(id);\n    return peerStreams;\n  }\n  /**\n   * Handles an rpc request from a peer\n   *\n   * @override\n   * @param {String} idB58Str\n   * @param {PeerStreams} peerStreams\n   * @param {RPC} rpc\n   * @returns {boolean}\n   */\n\n\n  _processRpc(id, peerStreams, rpc) {\n    if (super._processRpc(id, peerStreams, rpc)) {\n      if (rpc.control) {\n        this._processRpcControlMessage(id, rpc.control);\n      }\n\n      return true;\n    }\n\n    return false;\n  }\n  /**\n   * Handles an rpc control message from a peer\n   * @param {string} id peer id\n   * @param {ControlMessage} controlMsg\n   * @returns {void}\n   */\n\n\n  _processRpcControlMessage(id, controlMsg) {\n    if (!controlMsg) {\n      return;\n    }\n\n    const iwant = this._handleIHave(id, controlMsg.ihave);\n\n    const ihave = this._handleIWant(id, controlMsg.iwant);\n\n    const prune = this._handleGraft(id, controlMsg.graft);\n\n    this._handlePrune(id, controlMsg.prune);\n\n    if (!iwant.length && !ihave.length && !prune.length) {\n      return;\n    }\n\n    const outRpc = utils_1.createGossipRpc(ihave, {\n      iwant,\n      prune\n    });\n\n    this._sendRpc(id, outRpc);\n  }\n  /**\n   * Process incoming message,\n   * emitting locally and forwarding on to relevant floodsub and gossipsub peers\n   * @override\n   * @param {InMessage} msg\n   * @returns {Promise<void>}\n   */\n\n\n  _processRpcMessage(msg) {\n    const _super = Object.create(null, {\n      _processRpcMessage: {\n        get: () => super._processRpcMessage\n      }\n    });\n\n    return __awaiter(this, void 0, void 0, function* () {\n      const msgID = this.getMsgId(msg);\n      const msgIdStr = utils_1.messageIdToString(msgID); // Ignore if we've already seen the message\n\n      if (this.seenCache.has(msgIdStr)) {\n        this.score.duplicateMessage(msg);\n        return;\n      }\n\n      this.seenCache.put(msgIdStr);\n      this.score.validateMessage(msg);\n      yield _super._processRpcMessage.call(this, msg);\n    });\n  }\n  /**\n   * Whether to accept a message from a peer\n   * @override\n   * @param {string} id\n   * @returns {boolean}\n   */\n\n\n  _acceptFrom(id) {\n    return this.direct.has(id) || this.score.score(id) >= this._options.scoreThresholds.graylistThreshold;\n  }\n  /**\n   * Validate incoming message\n   * @override\n   * @param {InMessage} message\n   * @returns {Promise<void>}\n   */\n\n\n  validate(message) {\n    const _super = Object.create(null, {\n      validate: {\n        get: () => super.validate\n      }\n    });\n\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        yield _super.validate.call(this, message);\n      } catch (e) {\n        this.score.rejectMessage(message, e.code);\n        this.gossipTracer.rejectMessage(message, e.code);\n        throw e;\n      }\n    });\n  }\n  /**\n   * Handles IHAVE messages\n   * @param {string} id peer id\n   * @param {Array<ControlIHave>} ihave\n   * @returns {ControlIWant}\n   */\n\n\n  _handleIHave(id, ihave) {\n    if (!ihave.length) {\n      return [];\n    } // we ignore IHAVE gossip from any peer whose score is below the gossips threshold\n\n\n    const score = this.score.score(id);\n\n    if (score < this._options.scoreThresholds.gossipThreshold) {\n      this.log('IHAVE: ignoring peer %s with score below threshold [ score = %d ]', id, score);\n      return [];\n    } // IHAVE flood protection\n\n\n    const peerhave = (this.peerhave.get(id) || 0) + 1;\n    this.peerhave.set(id, peerhave);\n\n    if (peerhave > constants.GossipsubMaxIHaveMessages) {\n      this.log('IHAVE: peer %s has advertised too many times (%d) within this heartbeat interval; ignoring', id, peerhave);\n      return [];\n    }\n\n    const iasked = this.iasked.get(id) || 0;\n\n    if (iasked >= constants.GossipsubMaxIHaveLength) {\n      this.log('IHAVE: peer %s has already advertised too many messages (%d); ignoring', id, iasked);\n      return [];\n    } // string msgId => msgId\n\n\n    const iwant = new Map();\n    ihave.forEach(({\n      topicID,\n      messageIDs\n    }) => {\n      if (!topicID || !this.mesh.has(topicID)) {\n        return;\n      }\n\n      messageIDs.forEach(msgID => {\n        const msgIdStr = utils_1.messageIdToString(msgID);\n\n        if (this.seenCache.has(msgIdStr)) {\n          return;\n        }\n\n        iwant.set(msgIdStr, msgID);\n      });\n    });\n\n    if (!iwant.size) {\n      return [];\n    }\n\n    let iask = iwant.size;\n\n    if (iask + iasked > constants.GossipsubMaxIHaveLength) {\n      iask = constants.GossipsubMaxIHaveLength - iasked;\n    }\n\n    this.log('IHAVE: Asking for %d out of %d messages from %s', iask, iwant.size, id);\n    let iwantList = Array.from(iwant.values()); // ask in random order\n\n    utils_1.shuffle(iwantList); // truncate to the messages we are actually asking for and update the iasked counter\n\n    iwantList = iwantList.slice(0, iask);\n    this.iasked.set(id, iasked + iask);\n    this.gossipTracer.addPromise(id, iwantList);\n    return [{\n      messageIDs: iwantList\n    }];\n  }\n  /**\n   * Handles IWANT messages\n   * Returns messages to send back to peer\n   * @param {string} id peer id\n   * @param {Array<ControlIWant>} iwant\n   * @returns {Array<Message>}\n   */\n\n\n  _handleIWant(id, iwant) {\n    if (!iwant.length) {\n      return [];\n    } // we don't respond to IWANT requests from any per whose score is below the gossip threshold\n\n\n    const score = this.score.score(id);\n\n    if (score < this._options.scoreThresholds.gossipThreshold) {\n      this.log('IWANT: ignoring peer %s with score below threshold [score = %d]', id, score);\n      return [];\n    } // @type {Map<string, Message>}\n\n\n    const ihave = new Map();\n    iwant.forEach(({\n      messageIDs\n    }) => {\n      messageIDs.forEach(msgID => {\n        const _this$messageCache$ge = this.messageCache.getForPeer(msgID, id),\n              _this$messageCache$ge2 = _slicedToArray(_this$messageCache$ge, 2),\n              msg = _this$messageCache$ge2[0],\n              count = _this$messageCache$ge2[1];\n\n        if (!msg) {\n          return;\n        }\n\n        if (count > constants.GossipsubGossipRetransmission) {\n          this.log('IWANT: Peer %s has asked for message %s too many times: ignoring request', id, msgID);\n          return;\n        }\n\n        ihave.set(utils_1.messageIdToString(msgID), msg);\n      });\n    });\n\n    if (!ihave.size) {\n      return [];\n    }\n\n    this.log('IWANT: Sending %d messages to %s', ihave.size, id);\n    return Array.from(ihave.values()).map(pubsub_1.utils.normalizeOutRpcMessage);\n  }\n  /**\n   * Handles Graft messages\n   * @param {string} id peer id\n   * @param {Array<ControlGraft>} graft\n   * @return {Array<ControlPrune>}\n   */\n\n\n  _handleGraft(id, graft) {\n    const prune = [];\n    const score = this.score.score(id);\n\n    const now = this._now();\n\n    let doPX = this._options.doPX;\n    graft.forEach(({\n      topicID\n    }) => {\n      var _a;\n\n      if (!topicID) {\n        return;\n      }\n\n      const peersInMesh = this.mesh.get(topicID);\n\n      if (!peersInMesh) {\n        // don't do PX when there is an unknown topic to avoid leaking our peers\n        doPX = false; // spam hardening: ignore GRAFTs for unknown topics\n\n        return;\n      } // check if peer is already in the mesh; if so do nothing\n\n\n      if (peersInMesh.has(id)) {\n        return;\n      } // we don't GRAFT to/from direct peers; complain loudly if this happens\n\n\n      if (this.direct.has(id)) {\n        this.log('GRAFT: ignoring request from direct peer %s', id); // this is possibly a bug from a non-reciprical configuration; send a PRUNE\n\n        prune.push(topicID); // but don't px\n\n        doPX = false;\n        return;\n      } // make sure we are not backing off that peer\n\n\n      const expire = (_a = this.backoff.get(topicID)) === null || _a === void 0 ? void 0 : _a.get(id);\n\n      if (typeof expire === 'number' && now < expire) {\n        this.log('GRAFT: ignoring backed off peer %s', id); // add behavioral penalty\n\n        this.score.addPenalty(id, 1); // no PX\n\n        doPX = false; // check the flood cutoff -- is the GRAFT coming too fast?\n\n        const floodCutoff = expire + constants.GossipsubGraftFloodThreshold - constants.GossipsubPruneBackoff;\n\n        if (now < floodCutoff) {\n          // extra penalty\n          this.score.addPenalty(id, 1);\n        } // refresh the backoff\n\n\n        this._addBackoff(id, topicID);\n\n        prune.push(topicID);\n        return;\n      } // check the score\n\n\n      if (score < 0) {\n        // we don't GRAFT peers with negative score\n        this.log('GRAFT: ignoring peer %s with negative score: score=%d, topic=%s', id, score, topicID); // we do send them PRUNE however, because it's a matter of protocol correctness\n\n        prune.push(topicID); // but we won't PX to them\n\n        doPX = false; // add/refresh backoff so that we don't reGRAFT too early even if the score decays\n\n        this._addBackoff(id, topicID);\n\n        return;\n      } // check the number of mesh peers; if it is at (or over) Dhi, we only accept grafts\n      // from peers with outbound connections; this is a defensive check to restrict potential\n      // mesh takeover attacks combined with love bombing\n\n\n      if (peersInMesh.size >= this._options.Dhi && !this.outbound.get(id)) {\n        prune.push(topicID);\n\n        this._addBackoff(id, topicID);\n\n        return;\n      }\n\n      this.log('GRAFT: Add mesh link from %s in %s', id, topicID);\n      this.score.graft(id, topicID);\n      peersInMesh.add(id);\n    });\n\n    if (!prune.length) {\n      return [];\n    }\n\n    return prune.map(topic => this._makePrune(id, topic, doPX));\n  }\n  /**\n   * Handles Prune messages\n   * @param {string} id peer id\n   * @param {Array<ControlPrune>} prune\n   * @returns {void}\n   */\n\n\n  _handlePrune(id, prune) {\n    const score = this.score.score(id);\n    prune.forEach(({\n      topicID,\n      backoff,\n      peers\n    }) => {\n      if (!topicID) {\n        return;\n      }\n\n      const peersInMesh = this.mesh.get(topicID);\n\n      if (!peersInMesh) {\n        return;\n      }\n\n      this.log('PRUNE: Remove mesh link to %s in %s', id, topicID);\n      this.score.prune(id, topicID);\n      peersInMesh.delete(id); // is there a backoff specified by the peer? if so obey it\n\n      if (typeof backoff === 'number' && backoff > 0) {\n        this._doAddBackoff(id, topicID, backoff * 1000);\n      } else {\n        this._addBackoff(id, topicID);\n      } // PX\n\n\n      if (peers && peers.length) {\n        // we ignore PX from peers with insufficient scores\n        if (score < this._options.scoreThresholds.acceptPXThreshold) {\n          this.log('PRUNE: ignoring PX from peer %s with insufficient score [score = %d, topic = %s]', id, score, topicID);\n          return;\n        }\n\n        this._pxConnect(peers);\n      }\n    });\n  }\n  /**\n   * Add standard backoff log for a peer in a topic\n   * @param {string} id\n   * @param {string} topic\n   * @returns {void}\n   */\n\n\n  _addBackoff(id, topic) {\n    this._doAddBackoff(id, topic, constants.GossipsubPruneBackoff);\n  }\n  /**\n   * Add backoff expiry interval for a peer in a topic\n   * @param {string} id\n   * @param {string} topic\n   * @param {number} interval backoff duration in milliseconds\n   * @returns {void}\n   */\n\n\n  _doAddBackoff(id, topic, interval) {\n    let backoff = this.backoff.get(topic);\n\n    if (!backoff) {\n      backoff = new Map();\n      this.backoff.set(topic, backoff);\n    }\n\n    const expire = this._now() + interval;\n    const existingExpire = backoff.get(id) || 0;\n\n    if (existingExpire < expire) {\n      backoff.set(id, expire);\n    }\n  }\n  /**\n   * Apply penalties from broken IHAVE/IWANT promises\n   * @returns {void}\n   */\n\n\n  _applyIwantPenalties() {\n    this.gossipTracer.getBrokenPromises().forEach((count, p) => {\n      this.log('peer %s didn\\'t follow up in %d IWANT requests; adding penalty', p, count);\n      this.score.addPenalty(p, count);\n    });\n  }\n  /**\n   * Clear expired backoff expiries\n   * @returns {void}\n   */\n\n\n  _clearBackoff() {\n    // we only clear once every GossipsubPruneBackoffTicks ticks to avoid iterating over the maps too much\n    if (this.heartbeatTicks % constants.GossipsubPruneBackoffTicks !== 0) {\n      return;\n    }\n\n    const now = this._now();\n\n    this.backoff.forEach((backoff, topic) => {\n      backoff.forEach((expire, id) => {\n        if (expire < now) {\n          backoff.delete(id);\n        }\n      });\n\n      if (backoff.size === 0) {\n        this.backoff.delete(topic);\n      }\n    });\n  }\n  /**\n   * Maybe reconnect to direct peers\n   * @returns {void}\n   */\n\n\n  _directConnect() {\n    // we only do this every few ticks to allow pending connections to complete and account for\n    // restarts/downtime\n    if (this.heartbeatTicks % constants.GossipsubDirectConnectTicks !== 0) {\n      return;\n    }\n\n    const toconnect = [];\n    this.direct.forEach(id => {\n      const peer = this.peers.get(id);\n\n      if (!peer || !peer.isWritable) {\n        toconnect.push(id);\n      }\n    });\n\n    if (toconnect.length) {\n      toconnect.forEach(id => {\n        this._connect(id);\n      });\n    }\n  }\n  /**\n   * Maybe attempt connection given signed peer records\n   * @param {PeerInfo[]} peers\n   * @returns {Promise<void>}\n   */\n\n\n  _pxConnect(peers) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (peers.length > constants.GossipsubPrunePeers) {\n        utils_1.shuffle(peers);\n        peers = peers.slice(0, constants.GossipsubPrunePeers);\n      }\n\n      const toconnect = [];\n      yield Promise.all(peers.map(pi => __awaiter(this, void 0, void 0, function* () {\n        if (!pi.peerID) {\n          return;\n        }\n\n        const p = PeerId.createFromBytes(pi.peerID);\n        const id = p.toB58String();\n\n        if (this.peers.has(id)) {\n          return;\n        }\n\n        if (!pi.signedPeerRecord) {\n          toconnect.push(id);\n          return;\n        } // The peer sent us a signed record\n        // This is not a record from the peer who sent the record, but another peer who is connected with it\n        // Ensure that it is valid\n\n\n        try {\n          const envelope = yield Envelope.openAndCertify(pi.signedPeerRecord, 'libp2p-peer-record');\n          const eid = envelope.peerId.toB58String();\n\n          if (id !== eid) {\n            this.log('bogus peer record obtained through px: peer ID %s doesn\\'t match expected peer %s', eid, id);\n            return;\n          }\n\n          if (!this._libp2p.peerStore.addressBook.consumePeerRecord(envelope)) {\n            this.log('bogus peer record obtained through px: could not add peer record to address book');\n            return;\n          }\n\n          toconnect.push(id);\n        } catch (e) {\n          this.log('bogus peer record obtained through px: invalid signature or not a peer record');\n        }\n      })));\n\n      if (!toconnect.length) {\n        return;\n      }\n\n      toconnect.forEach(id => this._connect(id));\n    });\n  }\n  /**\n   * Mounts the gossipsub protocol onto the libp2p node and sends our\n   * our subscriptions to every peer connected\n   * @override\n   * @returns {void}\n   */\n\n\n  start() {\n    super.start();\n    this.heartbeat.start();\n    this.score.start(); // connect to direct peers\n\n    this._directPeerInitial = setTimeout(() => {\n      this.direct.forEach(id => {\n        this._connect(id);\n      });\n    }, constants.GossipsubDirectConnectInitialDelay);\n  }\n  /**\n   * Unmounts the gossipsub protocol and shuts down every connection\n   * @override\n   * @returns {void}\n   */\n\n\n  stop() {\n    super.stop();\n    this.heartbeat.stop();\n    this.score.stop();\n    this.mesh = new Map();\n    this.fanout = new Map();\n    this.lastpub = new Map();\n    this.gossip = new Map();\n    this.control = new Map();\n    this.peerhave = new Map();\n    this.iasked = new Map();\n    this.backoff = new Map();\n    this.outbound = new Map();\n    this.gossipTracer.clear();\n    clearTimeout(this._directPeerInitial);\n  }\n  /**\n   * Connect to a peer using the gossipsub protocol\n   * @param {string} id\n   * @returns {void}\n   */\n\n\n  _connect(id) {\n    this.log('Initiating connection with %s', id);\n\n    this._libp2p.dialProtocol(PeerId.createFromB58String(id), this.multicodecs);\n  }\n  /**\n   * Subscribes to a topic\n   * @override\n   * @param {string} topic\n   * @returns {void}\n   */\n\n\n  subscribe(topic) {\n    super.subscribe(topic);\n    this.join(topic);\n  }\n  /**\n   * Unsubscribe to a topic\n   * @override\n   * @param {string} topic\n   * @returns {void}\n   */\n\n\n  unsubscribe(topic) {\n    super.unsubscribe(topic);\n    this.leave(topic);\n  }\n  /**\n   * Join topic\n   * @param {string} topic\n   * @returns {void}\n   */\n\n\n  join(topic) {\n    if (!this.started) {\n      throw new Error('Gossipsub has not started');\n    }\n\n    this.log('JOIN %s', topic);\n    const fanoutPeers = this.fanout.get(topic);\n\n    if (fanoutPeers) {\n      // these peers have a score above the publish threshold, which may be negative\n      // so drop the ones with a negative score\n      fanoutPeers.forEach(id => {\n        if (this.score.score(id) < 0) {\n          fanoutPeers.delete(id);\n        }\n      });\n\n      if (fanoutPeers.size < this._options.D) {\n        // we need more peers; eager, as this would get fixed in the next heartbeat\n        get_gossip_peers_1.getGossipPeers(this, topic, this._options.D - fanoutPeers.size, id => {\n          // filter our current peers, direct peers, and peers with negative scores\n          return !fanoutPeers.has(id) && !this.direct.has(id) && this.score.score(id) >= 0;\n        }).forEach(id => fanoutPeers.add(id));\n      }\n\n      this.mesh.set(topic, fanoutPeers);\n      this.fanout.delete(topic);\n      this.lastpub.delete(topic);\n    } else {\n      const peers = get_gossip_peers_1.getGossipPeers(this, topic, this._options.D, id => {\n        // filter direct peers and peers with negative score\n        return !this.direct.has(id) && this.score.score(id) >= 0;\n      });\n      this.mesh.set(topic, peers);\n    }\n\n    this.mesh.get(topic).forEach(id => {\n      this.log('JOIN: Add mesh link to %s in %s', id, topic);\n\n      this._sendGraft(id, topic);\n    });\n  }\n  /**\n   * Leave topic\n   * @param {string} topic\n   * @returns {void}\n   */\n\n\n  leave(topic) {\n    if (!this.started) {\n      throw new Error('Gossipsub has not started');\n    }\n\n    this.log('LEAVE %s', topic); // Send PRUNE to mesh peers\n\n    const meshPeers = this.mesh.get(topic);\n\n    if (meshPeers) {\n      meshPeers.forEach(id => {\n        this.log('LEAVE: Remove mesh link to %s in %s', id, topic);\n\n        this._sendPrune(id, topic);\n      });\n      this.mesh.delete(topic);\n    }\n  }\n  /**\n   * Publish messages\n   *\n   * @override\n   * @param {InMessage} msg\n   * @returns {void}\n   */\n\n\n  _publish(msg) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (msg.receivedFrom !== this.peerId.toB58String()) {\n        this.score.deliverMessage(msg);\n        this.gossipTracer.deliverMessage(msg);\n      }\n\n      const msgID = this.getMsgId(msg);\n      const msgIdStr = utils_1.messageIdToString(msgID); // put in seen cache\n\n      this.seenCache.put(msgIdStr);\n      this.messageCache.put(msg);\n      const tosend = new Set();\n      msg.topicIDs.forEach(topic => {\n        const peersInTopic = this.topics.get(topic);\n\n        if (!peersInTopic) {\n          return;\n        }\n\n        if (this._options.floodPublish && msg.from === this.peerId.toB58String()) {\n          // flood-publish behavior\n          // send to direct peers and _all_ peers meeting the publishThreshold\n          peersInTopic.forEach(id => {\n            if (this.direct.has(id) || this.score.score(id) >= this._options.scoreThresholds.publishThreshold) {\n              tosend.add(id);\n            }\n          });\n        } else {\n          // non-flood-publish behavior\n          // send to direct peers, subscribed floodsub peers\n          // and some mesh peers above publishThreshold\n          // direct peers\n          this.direct.forEach(id => {\n            tosend.add(id);\n          }); // floodsub peers\n\n          peersInTopic.forEach(id => {\n            const score = this.score.score(id);\n            const peerStreams = this.peers.get(id);\n\n            if (!peerStreams) {\n              return;\n            }\n\n            if (peerStreams.protocol === constants.FloodsubID && score >= this._options.scoreThresholds.publishThreshold) {\n              tosend.add(id);\n            }\n          }); // Gossipsub peers handling\n\n          let meshPeers = this.mesh.get(topic);\n\n          if (!meshPeers || !meshPeers.size) {\n            // We are not in the mesh for topic, use fanout peers\n            meshPeers = this.fanout.get(topic);\n\n            if (!meshPeers) {\n              // If we are not in the fanout, then pick peers in topic above the publishThreshold\n              const peers = get_gossip_peers_1.getGossipPeers(this, topic, this._options.D, id => {\n                return this.score.score(id) >= this._options.scoreThresholds.publishThreshold;\n              });\n\n              if (peers.size > 0) {\n                meshPeers = peers;\n                this.fanout.set(topic, peers);\n              } else {\n                meshPeers = new Set();\n              }\n            } // Store the latest publishing time\n\n\n            this.lastpub.set(topic, this._now());\n          }\n\n          meshPeers.forEach(peer => {\n            tosend.add(peer);\n          });\n        }\n      }); // Publish messages to peers\n\n      const rpc = utils_1.createGossipRpc([pubsub_1.utils.normalizeOutRpcMessage(msg)]);\n      tosend.forEach(id => {\n        if (id === msg.from) {\n          return;\n        }\n\n        this._sendRpc(id, rpc);\n      });\n    });\n  }\n  /**\n   * Sends a GRAFT message to a peer\n   * @param {string} id peer id\n   * @param {string} topic\n   * @returns {void}\n   */\n\n\n  _sendGraft(id, topic) {\n    const graft = [{\n      topicID: topic\n    }];\n    const out = utils_1.createGossipRpc([], {\n      graft\n    });\n\n    this._sendRpc(id, out);\n  }\n  /**\n   * Sends a PRUNE message to a peer\n   * @param {string} id peer id\n   * @param {string} topic\n   * @returns {void}\n   */\n\n\n  _sendPrune(id, topic) {\n    const prune = [this._makePrune(id, topic, this._options.doPX)];\n    const out = utils_1.createGossipRpc([], {\n      prune\n    });\n\n    this._sendRpc(id, out);\n  }\n  /**\n   * @override\n   */\n\n\n  _sendRpc(id, outRpc) {\n    const peerStreams = this.peers.get(id);\n\n    if (!peerStreams || !peerStreams.isWritable) {\n      return;\n    } // piggyback control message retries\n\n\n    const ctrl = this.control.get(id);\n\n    if (ctrl) {\n      this._piggybackControl(id, outRpc, ctrl);\n\n      this.control.delete(id);\n    } // piggyback gossip\n\n\n    const ihave = this.gossip.get(id);\n\n    if (ihave) {\n      this._piggybackGossip(id, outRpc, ihave);\n\n      this.gossip.delete(id);\n    }\n\n    peerStreams.write(message_1.RPCCodec.encode(outRpc));\n  }\n\n  _piggybackControl(id, outRpc, ctrl) {\n    const tograft = (ctrl.graft || []).filter(({\n      topicID\n    }) => (topicID && this.mesh.get(topicID) || new Set()).has(id));\n    const toprune = (ctrl.prune || []).filter(({\n      topicID\n    }) => !(topicID && this.mesh.get(topicID) || new Set()).has(id));\n\n    if (!tograft.length && !toprune.length) {\n      return;\n    }\n\n    if (outRpc.control) {\n      outRpc.control.graft = outRpc.control.graft.concat(tograft);\n      outRpc.control.prune = outRpc.control.prune.concat(toprune);\n    } else {\n      outRpc.control = {\n        ihave: [],\n        iwant: [],\n        graft: tograft,\n        prune: toprune\n      };\n    }\n  }\n\n  _piggybackGossip(id, outRpc, ihave) {\n    if (!outRpc.control) {\n      outRpc.control = {\n        ihave: [],\n        iwant: [],\n        graft: [],\n        prune: []\n      };\n    }\n\n    outRpc.control.ihave = ihave;\n  }\n  /**\n   * Send graft and prune messages\n   * @param {Map<string, Array<string>>} tograft peer id => topic[]\n   * @param {Map<string, Array<string>>} toprune peer id => topic[]\n   */\n\n\n  _sendGraftPrune(tograft, toprune, noPX) {\n    const doPX = this._options.doPX;\n\n    for (const _ref of tograft) {\n      var _ref2 = _slicedToArray(_ref, 2);\n\n      const id = _ref2[0];\n      const topics = _ref2[1];\n      const graft = topics.map(topicID => ({\n        topicID\n      }));\n      let prune = []; // If a peer also has prunes, process them now\n\n      const pruning = toprune.get(id);\n\n      if (pruning) {\n        prune = pruning.map(topicID => this._makePrune(id, topicID, doPX && !noPX.get(id)));\n        toprune.delete(id);\n      }\n\n      const outRpc = utils_1.createGossipRpc([], {\n        graft,\n        prune\n      });\n\n      this._sendRpc(id, outRpc);\n    }\n\n    for (const _ref3 of toprune) {\n      var _ref4 = _slicedToArray(_ref3, 2);\n\n      const id = _ref4[0];\n      const topics = _ref4[1];\n      const prune = topics.map(topicID => this._makePrune(id, topicID, doPX && !noPX.get(id)));\n      const outRpc = utils_1.createGossipRpc([], {\n        prune\n      });\n\n      this._sendRpc(id, outRpc);\n    }\n  }\n  /**\n   * Emits gossip to peers in a particular topic\n   * @param {string} topic\n   * @param {Set<string>} exclude peers to exclude\n   * @returns {void}\n   */\n\n\n  _emitGossip(topic, exclude) {\n    const messageIDs = this.messageCache.getGossipIDs(topic);\n\n    if (!messageIDs.length) {\n      return;\n    } // shuffle to emit in random order\n\n\n    utils_1.shuffle(messageIDs); // if we are emitting more than GossipsubMaxIHaveLength ids, truncate the list\n\n    if (messageIDs.length > constants.GossipsubMaxIHaveLength) {\n      // we do the truncation (with shuffling) per peer below\n      this.log('too many messages for gossip; will truncate IHAVE list (%d messages)', messageIDs.length);\n    } // Send gossip to GossipFactor peers above threshold with a minimum of D_lazy\n    // First we collect the peers above gossipThreshold that are not in the exclude set\n    // and then randomly select from that set\n    // We also exclude direct peers, as there is no reason to emit gossip to them\n\n\n    const peersToGossip = [];\n    const topicPeers = this.topics.get(topic);\n\n    if (!topicPeers) {\n      // no topic peers, no gossip\n      return;\n    }\n\n    topicPeers.forEach(id => {\n      const peerStreams = this.peers.get(id);\n\n      if (!peerStreams) {\n        return;\n      }\n\n      if (!exclude.has(id) && !this.direct.has(id) && utils_1.hasGossipProtocol(peerStreams.protocol) && this.score.score(id) >= this._options.scoreThresholds.gossipThreshold) {\n        peersToGossip.push(id);\n      }\n    });\n    let target = this._options.Dlazy;\n    const factor = constants.GossipsubGossipFactor * peersToGossip.length;\n\n    if (factor > target) {\n      target = factor;\n    }\n\n    if (target > peersToGossip.length) {\n      target = peersToGossip.length;\n    } else {\n      utils_1.shuffle(peersToGossip);\n    } // Emit the IHAVE gossip to the selected peers up to the target\n\n\n    peersToGossip.slice(0, target).forEach(id => {\n      let peerMessageIDs = messageIDs;\n\n      if (messageIDs.length > constants.GossipsubMaxIHaveLength) {\n        // shuffle and slice message IDs per peer so that we emit a different set for each peer\n        // we have enough reduncancy in the system that this will significantly increase the message\n        // coverage when we do truncate\n        peerMessageIDs = utils_1.shuffle(peerMessageIDs.slice()).slice(0, constants.GossipsubMaxIHaveLength);\n      }\n\n      this._pushGossip(id, {\n        topicID: topic,\n        messageIDs: peerMessageIDs\n      });\n    });\n  }\n  /**\n   * Flush gossip and control messages\n   */\n\n\n  _flush() {\n    // send gossip first, which will also piggyback control\n    for (const _ref5 of this.gossip.entries()) {\n      var _ref6 = _slicedToArray(_ref5, 2);\n\n      const peer = _ref6[0];\n      const ihave = _ref6[1];\n      this.gossip.delete(peer);\n      const out = utils_1.createGossipRpc([], {\n        ihave\n      });\n\n      this._sendRpc(peer, out);\n    } // send the remaining control messages\n\n\n    for (const _ref7 of this.control.entries()) {\n      var _ref8 = _slicedToArray(_ref7, 2);\n\n      const peer = _ref8[0];\n      const control = _ref8[1];\n      this.control.delete(peer);\n      const out = utils_1.createGossipRpc([], {\n        graft: control.graft,\n        prune: control.prune\n      });\n\n      this._sendRpc(peer, out);\n    }\n  }\n  /**\n   * Adds new IHAVE messages to pending gossip\n   * @param {PeerStreams} peerStreams\n   * @param {Array<ControlIHave>} controlIHaveMsgs\n   * @returns {void}\n   */\n\n\n  _pushGossip(id, controlIHaveMsgs) {\n    this.log('Add gossip to %s', id);\n    const gossip = this.gossip.get(id) || [];\n    this.gossip.set(id, gossip.concat(controlIHaveMsgs));\n  }\n  /**\n   * Returns the current time in milliseconds\n   * @returns {number}\n   */\n\n\n  _now() {\n    return Date.now();\n  }\n  /**\n   * Make a PRUNE control message for a peer in a topic\n   * @param {string} id\n   * @param {string} topic\n   * @param {boolean} doPX\n   * @returns {ControlPrune}\n   */\n\n\n  _makePrune(id, topic, doPX) {\n    if (this.peers.get(id).protocol === constants.GossipsubIDv10) {\n      // Gossipsub v1.0 -- no backoff, the peer won't be able to parse it anyway\n      return {\n        topicID: topic,\n        peers: []\n      };\n    } // backoff is measured in seconds\n    // GossipsubPruneBackoff is measured in milliseconds\n\n\n    const backoff = constants.GossipsubPruneBackoff / 1000;\n    const px = [];\n\n    if (doPX) {\n      // select peers for Peer eXchange\n      const peers = get_gossip_peers_1.getGossipPeers(this, topic, constants.GossipsubPrunePeers, xid => {\n        return xid !== id && this.score.score(xid) >= 0;\n      });\n      peers.forEach(p => {\n        // see if we have a signed record to send back; if we don't, just send\n        // the peer ID and let the pruned peer find them in the DHT -- we can't trust\n        // unsigned address records through PX anyways\n        // Finding signed records in the DHT is not supported at the time of writing in js-libp2p\n        const peerId = PeerId.createFromB58String(p);\n        px.push({\n          peerID: peerId.toBytes(),\n          signedPeerRecord: this._libp2p.peerStore.addressBook.getRawEnvelope(peerId)\n        });\n      });\n    }\n\n    return {\n      topicID: topic,\n      peers: px,\n      backoff: backoff\n    };\n  }\n\n}\n\nGossipsub.multicodec = constants.GossipsubIDv11;\nmodule.exports = Gossipsub;","map":null,"metadata":{},"sourceType":"script"}