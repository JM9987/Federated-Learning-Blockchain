{"ast":null,"code":"'use strict';\n\nconst mergeOptions = require('merge-options').bind({\n  ignoreUndefined: true\n});\n\nconst toMfsPath = require('./utils/to-mfs-path');\n\nconst exporter = require('ipfs-unixfs-exporter');\n\nconst log = require('debug')('ipfs:mfs:stat');\n\nconst errCode = require('err-code');\n\nconst withTimeoutOption = require('ipfs-core-utils/src/with-timeout-option');\n\nconst defaultOptions = {\n  withLocal: false,\n  signal: undefined\n};\n/**\n * @param {Object} context\n * @param {import('..').IPLD} context.ipld\n */\n\nmodule.exports = context => {\n  /**\n   * Get file or directory statistics\n   *\n   * @param {string} path - The MFS path return statistics from\n   * @param {StatOptions & AbortOptions} [options]\n   * @returns {Promise<Stat>} - An object containing the file/directory status\n   */\n  async function mfsStat(path, options) {\n    options = mergeOptions(defaultOptions, options);\n    log(\"Fetching stats for \".concat(path));\n\n    const _ref = await toMfsPath(context, path, options),\n          type = _ref.type,\n          cid = _ref.cid,\n          mfsPath = _ref.mfsPath;\n\n    const exportPath = type === 'ipfs' && cid ? cid : mfsPath;\n    let file;\n\n    try {\n      file = await exporter(exportPath, context.ipld);\n    } catch (err) {\n      if (err.code === 'ERR_NOT_FOUND') {\n        throw errCode(new Error(\"\".concat(path, \" does not exist\")), 'ERR_NOT_FOUND');\n      }\n\n      throw err;\n    }\n\n    if (!statters[file.cid.codec]) {\n      throw new Error(\"Cannot stat codec \".concat(file.cid.codec));\n    }\n\n    return statters[file.cid.codec](file);\n  }\n\n  return withTimeoutOption(mfsStat);\n};\n/** @type {Record<string, (file:any) => Stat>} */\n\n\nconst statters = {\n  /**\n   * @param {any} file\n   * @returns {Stat}\n   */\n  raw: file => {\n    return {\n      cid: file.cid,\n      size: file.node.length,\n      cumulativeSize: file.node.length,\n      blocks: 0,\n      type: 'file',\n      // for go compatibility\n      local: undefined,\n      sizeLocal: undefined,\n      withLocality: false\n    };\n  },\n\n  /**\n   * @param {any} file\n   * @returns {Stat}\n   */\n  'dag-pb': file => {\n    const blocks = file.node.Links.length;\n    const size = file.node.size;\n    const cumulativeSize = file.node.size;\n    /** @type {Stat} */\n\n    const output = {\n      cid: file.cid,\n      type: 'file',\n      size: size,\n      cumulativeSize: cumulativeSize,\n      blocks: blocks,\n      local: undefined,\n      sizeLocal: undefined,\n      withLocality: false\n    };\n\n    if (file.unixfs) {\n      output.size = file.unixfs.fileSize(); // for go-ipfs compatibility\n\n      if (file.unixfs.type === 'hamt-sharded-directory') {\n        output.type = 'directory';\n      } else {\n        output.type = file.unixfs.type;\n      }\n\n      output.mode = file.unixfs.mode;\n\n      if (file.unixfs.isDirectory()) {\n        output.size = 0;\n        output.cumulativeSize = file.node.size;\n      }\n\n      if (output.type === 'file') {\n        output.blocks = file.unixfs.blockSizes.length;\n      }\n\n      if (file.unixfs.mtime) {\n        output.mtime = file.unixfs.mtime;\n      }\n    }\n\n    return output;\n  },\n\n  /**\n   * @param {any} file\n   * @returns {Stat}\n   */\n  'dag-cbor': file => {\n    // @ts-ignore - This is incompatible with Stat object\n    // @TODO - https://github.com/ipfs/js-ipfs/issues/3325\n    return {\n      cid: file.cid,\n      local: undefined,\n      sizeLocal: undefined,\n      withLocality: false\n    };\n  },\n\n  /**\n   * @param {any} file\n   * @returns {Stat}\n   */\n  identity: file => {\n    return {\n      cid: file.cid,\n      size: file.node.digest.length,\n      cumulativeSize: file.node.digest.length,\n      blocks: 0,\n      type: 'file',\n      // for go compatibility\n      local: undefined,\n      sizeLocal: undefined,\n      withLocality: false\n    };\n  }\n};\n/**\n * @typedef {Object} StatOptions\n * @property {boolean} [hash=false] - If true, return only the CID\n * @property {boolean} [size=false] - If true, return only the size\n * @property {boolean} [withLocal=false] - If true, compute the amount of the DAG that is local and if possible the total size\n *\n * @typedef {Object} Stat\n * @property {CID} cid - Content idenntifier\n * @property {number} size - An integer with the file size in bytes.\n * @property {number} cumulativeSize - An integer with the size of the\n * DAGNodes making up the file in bytes.\n * @property {'directory'|'file'} type - Type of the file which is  either directory\n * or file.\n * @property {number} blocks - If type is directory, this is the number of files\n * in the directory. If it is file it is the number of blocks that make up the\n * file.\n * @property {boolean} [withLocality] - A boolean to indicate if locality\n * information is present.\n * @property {boolean} [local] - Is a boolean to indicate if the queried dag is\n * fully present locally.\n * @property {number} [sizeLocal] - An integer indicating the cumulative size of\n * the data present locally.\n * @property {number} [mode] - File mode\n * @property {import('ipfs-core-types/src/files').MTime} [mtime] - Modification time\n *\n * @typedef {import('cids')} CID\n * @typedef {import('ipfs-core-types/src/basic').AbortOptions} AbortOptions\n */","map":null,"metadata":{},"sourceType":"script"}