{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.IK = void 0;\n\nconst buffer_1 = require(\"buffer\");\n\nconst utils_1 = require(\"../utils\");\n\nconst abstract_handshake_1 = require(\"./abstract-handshake\");\n\nclass IK extends abstract_handshake_1.AbstractHandshake {\n  initSession(initiator, prologue, s, rs) {\n    const psk = this.createEmptyKey();\n    let hs;\n\n    if (initiator) {\n      hs = this.initializeInitiator(prologue, s, rs, psk);\n    } else {\n      hs = this.initializeResponder(prologue, s, rs, psk);\n    }\n\n    return {\n      hs,\n      i: initiator,\n      mc: 0\n    };\n  }\n\n  sendMessage(session, message) {\n    let messageBuffer;\n\n    if (session.mc === 0) {\n      messageBuffer = this.writeMessageA(session.hs, message);\n    } else if (session.mc === 1) {\n      const _this$writeMessageB = this.writeMessageB(session.hs, message),\n            mb = _this$writeMessageB.messageBuffer,\n            h = _this$writeMessageB.h,\n            cs1 = _this$writeMessageB.cs1,\n            cs2 = _this$writeMessageB.cs2;\n\n      messageBuffer = mb;\n      session.h = h;\n      session.cs1 = cs1;\n      session.cs2 = cs2;\n    } else if (session.mc > 1) {\n      if (session.i) {\n        if (!session.cs1) {\n          throw new Error('CS1 (cipher state) is not defined');\n        }\n\n        messageBuffer = this.writeMessageRegular(session.cs1, message);\n      } else {\n        if (!session.cs2) {\n          throw new Error('CS2 (cipher state) is not defined');\n        }\n\n        messageBuffer = this.writeMessageRegular(session.cs2, message);\n      }\n    } else {\n      throw new Error('Session invalid.');\n    }\n\n    session.mc++;\n    return messageBuffer;\n  }\n\n  recvMessage(session, message) {\n    let plaintext = buffer_1.Buffer.alloc(0);\n    let valid = false;\n\n    if (session.mc === 0) {\n      var _this$readMessageA = this.readMessageA(session.hs, message);\n\n      plaintext = _this$readMessageA.plaintext;\n      valid = _this$readMessageA.valid;\n    }\n\n    if (session.mc === 1) {\n      const _this$readMessageB = this.readMessageB(session.hs, message),\n            pt = _this$readMessageB.plaintext,\n            v = _this$readMessageB.valid,\n            h = _this$readMessageB.h,\n            cs1 = _this$readMessageB.cs1,\n            cs2 = _this$readMessageB.cs2;\n\n      plaintext = pt;\n      valid = v;\n      session.h = h;\n      session.cs1 = cs1;\n      session.cs2 = cs2;\n    }\n\n    session.mc++;\n    return {\n      plaintext,\n      valid\n    };\n  }\n\n  writeMessageA(hs, payload) {\n    hs.e = utils_1.generateKeypair();\n    const ne = hs.e.publicKey;\n    this.mixHash(hs.ss, ne);\n    this.mixKey(hs.ss, this.dh(hs.e.privateKey, hs.rs));\n    const spk = buffer_1.Buffer.from(hs.s.publicKey);\n    const ns = this.encryptAndHash(hs.ss, spk);\n    this.mixKey(hs.ss, this.dh(hs.s.privateKey, hs.rs));\n    const ciphertext = this.encryptAndHash(hs.ss, payload);\n    return {\n      ne,\n      ns,\n      ciphertext\n    };\n  }\n\n  writeMessageB(hs, payload) {\n    hs.e = utils_1.generateKeypair();\n    const ne = hs.e.publicKey;\n    this.mixHash(hs.ss, ne);\n    this.mixKey(hs.ss, this.dh(hs.e.privateKey, hs.re));\n    this.mixKey(hs.ss, this.dh(hs.e.privateKey, hs.rs));\n    const ciphertext = this.encryptAndHash(hs.ss, payload);\n    const ns = this.createEmptyKey();\n    const messageBuffer = {\n      ne,\n      ns,\n      ciphertext\n    };\n\n    const _this$split = this.split(hs.ss),\n          cs1 = _this$split.cs1,\n          cs2 = _this$split.cs2;\n\n    return {\n      messageBuffer,\n      cs1,\n      cs2,\n      h: hs.ss.h\n    };\n  }\n\n  readMessageA(hs, message) {\n    if (utils_1.isValidPublicKey(message.ne)) {\n      hs.re = message.ne;\n    }\n\n    this.mixHash(hs.ss, hs.re);\n    this.mixKey(hs.ss, this.dh(hs.s.privateKey, hs.re));\n\n    const _this$decryptAndHash = this.decryptAndHash(hs.ss, message.ns),\n          ns = _this$decryptAndHash.plaintext,\n          valid1 = _this$decryptAndHash.valid;\n\n    if (valid1 && ns.length === 32 && utils_1.isValidPublicKey(ns)) {\n      hs.rs = ns;\n    }\n\n    this.mixKey(hs.ss, this.dh(hs.s.privateKey, hs.rs));\n\n    const _this$decryptAndHash2 = this.decryptAndHash(hs.ss, message.ciphertext),\n          plaintext = _this$decryptAndHash2.plaintext,\n          valid2 = _this$decryptAndHash2.valid;\n\n    return {\n      plaintext,\n      valid: valid1 && valid2\n    };\n  }\n\n  readMessageB(hs, message) {\n    if (utils_1.isValidPublicKey(message.ne)) {\n      hs.re = message.ne;\n    }\n\n    this.mixHash(hs.ss, hs.re);\n\n    if (!hs.e) {\n      throw new Error('Handshake state should contain ephemeral key by now.');\n    }\n\n    this.mixKey(hs.ss, this.dh(hs.e.privateKey, hs.re));\n    this.mixKey(hs.ss, this.dh(hs.s.privateKey, hs.re));\n\n    const _this$decryptAndHash3 = this.decryptAndHash(hs.ss, message.ciphertext),\n          plaintext = _this$decryptAndHash3.plaintext,\n          valid = _this$decryptAndHash3.valid;\n\n    const _this$split2 = this.split(hs.ss),\n          cs1 = _this$split2.cs1,\n          cs2 = _this$split2.cs2;\n\n    return {\n      h: hs.ss.h,\n      valid,\n      plaintext,\n      cs1,\n      cs2\n    };\n  }\n\n  initializeInitiator(prologue, s, rs, psk) {\n    const name = 'Noise_IK_25519_ChaChaPoly_SHA256';\n    const ss = this.initializeSymmetric(name);\n    this.mixHash(ss, prologue);\n    this.mixHash(ss, rs);\n    const re = buffer_1.Buffer.alloc(32);\n    return {\n      ss,\n      s,\n      rs,\n      re,\n      psk\n    };\n  }\n\n  initializeResponder(prologue, s, rs, psk) {\n    const name = 'Noise_IK_25519_ChaChaPoly_SHA256';\n    const ss = this.initializeSymmetric(name);\n    this.mixHash(ss, prologue);\n    this.mixHash(ss, s.publicKey);\n    const re = buffer_1.Buffer.alloc(32);\n    return {\n      ss,\n      s,\n      rs,\n      re,\n      psk\n    };\n  }\n\n}\n\nexports.IK = IK;","map":null,"metadata":{},"sourceType":"script"}