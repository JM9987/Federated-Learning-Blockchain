{"ast":null,"code":"'use strict';\n\nconst _require = require('ipld-dag-pb'),\n      DAGNode = _require.DAGNode,\n      DAGLink = _require.DAGLink;\n\nconst CID = require('cids');\n\nconst log = require('debug')('ipfs:mfs:core:utils:remove-link');\n\nconst UnixFS = require('ipfs-unixfs');\n\nconst _require2 = require('./hamt-utils'),\n      generatePath = _require2.generatePath,\n      updateHamtDirectory = _require2.updateHamtDirectory;\n\nconst errCode = require('err-code');\n\nconst mc = require('multicodec');\n\nconst mh = require('multihashing-async').multihash;\n\nconst removeLink = async (context, options) => {\n  if (!options.parentCid && !options.parent) {\n    throw errCode(new Error('No parent node or CID passed to removeLink'), 'EINVALIDPARENT');\n  }\n\n  if (options.parentCid && !CID.isCID(options.parentCid)) {\n    throw errCode(new Error('Invalid CID passed to removeLink'), 'EINVALIDPARENTCID');\n  }\n\n  if (!options.parent) {\n    log(\"Loading parent node \".concat(options.parentCid));\n    options.parent = await context.ipld.get(options.parentCid);\n  }\n\n  if (!options.name) {\n    throw errCode(new Error('No child name passed to removeLink'), 'EINVALIDCHILDNAME');\n  }\n\n  const meta = UnixFS.unmarshal(options.parent.Data);\n\n  if (meta.type === 'hamt-sharded-directory') {\n    log(\"Removing \".concat(options.name, \" from sharded directory\"));\n    return removeFromShardedDirectory(context, options);\n  }\n\n  log(\"Removing link \".concat(options.name, \" regular directory\"));\n  return removeFromDirectory(context, options);\n};\n\nconst removeFromDirectory = async (context, options) => {\n  const hashAlg = mh.names[options.hashAlg];\n  options.parent.rmLink(options.name);\n  const cid = await context.ipld.put(options.parent, mc.DAG_PB, {\n    cidVersion: options.cidVersion,\n    hashAlg\n  });\n  log(\"Updated regular directory \".concat(cid));\n  return {\n    node: options.parent,\n    cid\n  };\n};\n\nconst removeFromShardedDirectory = async (context, options) => {\n  const _ref = await generatePath(context, options.name, options.parent),\n        rootBucket = _ref.rootBucket,\n        path = _ref.path;\n\n  await rootBucket.del(options.name);\n\n  const _ref2 = await updateShard(context, path, {\n    name: options.name,\n    cid: options.cid,\n    size: options.size,\n    hashAlg: options.hashAlg,\n    cidVersion: options.cidVersion,\n    flush: options.flush\n  }, options),\n        node = _ref2.node;\n\n  return updateHamtDirectory(context, node.Links, rootBucket, options);\n};\n\nconst updateShard = async (context, positions, child, options) => {\n  const _positions$pop = positions.pop(),\n        bucket = _positions$pop.bucket,\n        prefix = _positions$pop.prefix,\n        node = _positions$pop.node;\n\n  const link = node.Links.find(link => link.Name.substring(0, 2) === prefix);\n\n  if (!link) {\n    throw errCode(new Error(\"No link found with prefix \".concat(prefix, \" for file \").concat(child.name)), 'ERR_NOT_FOUND');\n  }\n\n  if (link.Name === \"\".concat(prefix).concat(child.name)) {\n    log(\"Removing existing link \".concat(link.Name));\n    node.rmLink(link.Name);\n    await bucket.del(child.name);\n    return updateHamtDirectory(context, node.Links, bucket, options);\n  }\n\n  log(\"Descending into sub-shard \".concat(link.Name, \" for \").concat(prefix).concat(child.name));\n  const result = await updateShard(context, positions, child, options);\n  let newName = prefix;\n\n  if (result.node.Links.length === 1) {\n    log(\"Removing subshard for \".concat(prefix)); // convert shard back to normal dir\n\n    result.cid = result.node.Links[0].Hash;\n    result.node = result.node.Links[0];\n    newName = \"\".concat(prefix).concat(result.node.Name.substring(2));\n  }\n\n  log(\"Updating shard \".concat(prefix, \" with name \").concat(newName));\n  const size = DAGNode.isDAGNode(result.node) ? result.node.size : result.node.Tsize;\n  return updateShardParent(context, bucket, node, prefix, newName, size, result.cid, options);\n};\n\nconst updateShardParent = (context, bucket, parent, oldName, newName, size, cid, options) => {\n  parent.rmLink(oldName);\n  parent.addLink(new DAGLink(newName, size, cid));\n  return updateHamtDirectory(context, parent.Links, bucket, options);\n};\n\nmodule.exports = removeLink;","map":null,"metadata":{},"sourceType":"script"}