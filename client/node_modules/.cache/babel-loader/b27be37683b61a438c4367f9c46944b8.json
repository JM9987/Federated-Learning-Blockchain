{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.decode2 = exports.decode1 = exports.decode0 = exports.encode2 = exports.encode1 = exports.encode0 = exports.uint16BEDecode = exports.uint16BEEncode = void 0;\n\nconst buffer_1 = require(\"buffer\");\n\nconst uint16BEEncode = (value, target, offset) => {\n  target = target || buffer_1.Buffer.allocUnsafe(2);\n  target.writeUInt16BE(value, offset);\n  return target;\n};\n\nexports.uint16BEEncode = uint16BEEncode;\nexports.uint16BEEncode.bytes = 2;\n\nconst uint16BEDecode = data => {\n  if (data.length < 2) throw RangeError('Could not decode int16BE');\n  return data.readUInt16BE(0);\n};\n\nexports.uint16BEDecode = uint16BEDecode;\nexports.uint16BEDecode.bytes = 2; // Note: IK and XX encoder usage is opposite (XX uses in stages encode0 where IK uses encode1)\n\nfunction encode0(message) {\n  return buffer_1.Buffer.concat([message.ne, message.ciphertext]);\n}\n\nexports.encode0 = encode0;\n\nfunction encode1(message) {\n  return buffer_1.Buffer.concat([message.ne, message.ns, message.ciphertext]);\n}\n\nexports.encode1 = encode1;\n\nfunction encode2(message) {\n  return buffer_1.Buffer.concat([message.ns, message.ciphertext]);\n}\n\nexports.encode2 = encode2;\n\nfunction decode0(input) {\n  if (input.length < 32) {\n    throw new Error('Cannot decode stage 0 MessageBuffer: length less than 32 bytes.');\n  }\n\n  return {\n    ne: input.slice(0, 32),\n    ciphertext: input.slice(32, input.length),\n    ns: buffer_1.Buffer.alloc(0)\n  };\n}\n\nexports.decode0 = decode0;\n\nfunction decode1(input) {\n  if (input.length < 80) {\n    throw new Error('Cannot decode stage 1 MessageBuffer: length less than 80 bytes.');\n  }\n\n  return {\n    ne: input.slice(0, 32),\n    ns: input.slice(32, 80),\n    ciphertext: input.slice(80, input.length)\n  };\n}\n\nexports.decode1 = decode1;\n\nfunction decode2(input) {\n  if (input.length < 48) {\n    throw new Error('Cannot decode stage 2 MessageBuffer: length less than 48 bytes.');\n  }\n\n  return {\n    ne: buffer_1.Buffer.alloc(0),\n    ns: input.slice(0, 48),\n    ciphertext: input.slice(48, input.length)\n  };\n}\n\nexports.decode2 = decode2;","map":null,"metadata":{},"sourceType":"script"}