{"ast":null,"code":"'use strict';\n\nconst connect = require('it-ws/client');\n\nconst withIs = require('class-is');\n\nconst toUri = require('multiaddr-to-uri');\n\nconst _require = require('abortable-iterator'),\n      AbortError = _require.AbortError;\n\nconst pDefer = require('p-defer');\n\nconst debug = require('debug');\n\nconst log = debug('libp2p:websockets');\nlog.error = debug('libp2p:websockets:error');\n\nconst env = require('ipfs-utils/src/env');\n\nconst createListener = require('./listener');\n\nconst toConnection = require('./socket-to-conn');\n\nconst filters = require('./filters');\n/**\n * @typedef {import('multiaddr').Multiaddr} Multiaddr\n */\n\n/**\n * @class WebSockets\n */\n\n\nclass WebSockets {\n  /**\n   * @class\n   * @param {object} options\n   * @param {Upgrader} options.upgrader\n   * @param {(multiaddrs: Array<Multiaddr>) => Array<Multiaddr>} options.filter - override transport addresses filter\n   */\n  constructor({\n    upgrader,\n    filter\n  }) {\n    if (!upgrader) {\n      throw new Error('An upgrader must be provided. See https://github.com/libp2p/interface-transport#upgrader.');\n    }\n\n    this._upgrader = upgrader;\n    this._filter = filter;\n  }\n  /**\n   * @async\n   * @param {Multiaddr} ma\n   * @param {object} [options]\n   * @param {AbortSignal} [options.signal] - Used to abort dial requests\n   * @returns {Connection} An upgraded Connection\n   */\n\n\n  async dial(ma, options = {}) {\n    log('dialing %s', ma);\n    const socket = await this._connect(ma, options);\n    const maConn = toConnection(socket, {\n      remoteAddr: ma,\n      signal: options.signal\n    });\n    log('new outbound connection %s', maConn.remoteAddr);\n    const conn = await this._upgrader.upgradeOutbound(maConn);\n    log('outbound connection %s upgraded', maConn.remoteAddr);\n    return conn;\n  }\n  /**\n   * @private\n   * @param {Multiaddr} ma\n   * @param {object} [options]\n   * @param {AbortSignal} [options.signal] - Used to abort dial requests\n   * @returns {Promise<WebSocket>} Resolves a extended duplex iterable on top of a WebSocket\n   */\n\n\n  async _connect(ma, options = {}) {\n    if (options.signal && options.signal.aborted) {\n      throw new AbortError();\n    }\n\n    const cOpts = ma.toOptions();\n    log('dialing %s:%s', cOpts.host, cOpts.port);\n    const errorPromise = pDefer();\n\n    const errfn = err => {\n      const msg = \"connection error: \".concat(err.message);\n      log.error(msg);\n      errorPromise.reject(err);\n    };\n\n    const rawSocket = connect(toUri(ma), Object.assign({\n      binary: true\n    }, options));\n\n    if (rawSocket.socket.on) {\n      rawSocket.socket.on('error', errfn);\n    } else {\n      rawSocket.socket.onerror = errfn;\n    }\n\n    if (!options.signal) {\n      await Promise.race([rawSocket.connected(), errorPromise.promise]);\n      log('connected %s', ma);\n      return rawSocket;\n    } // Allow abort via signal during connect\n\n\n    let onAbort;\n    const abort = new Promise((resolve, reject) => {\n      onAbort = () => {\n        reject(new AbortError()); // FIXME: https://github.com/libp2p/js-libp2p-websockets/issues/121\n\n        setTimeout(() => {\n          rawSocket.close();\n        });\n      }; // Already aborted?\n\n\n      if (options.signal.aborted) return onAbort();\n      options.signal.addEventListener('abort', onAbort);\n    });\n\n    try {\n      await Promise.race([abort, errorPromise.promise, rawSocket.connected()]);\n    } finally {\n      options.signal.removeEventListener('abort', onAbort);\n    }\n\n    log('connected %s', ma);\n    return rawSocket;\n  }\n  /**\n   * Creates a Websockets listener. The provided `handler` function will be called\n   * anytime a new incoming Connection has been successfully upgraded via\n   * `upgrader.upgradeInbound`.\n   *\n   * @param {object} [options]\n   * @param {http.Server} [options.server] - A pre-created Node.js HTTP/S server.\n   * @param {function (Connection)} handler\n   * @returns {Listener} A Websockets listener\n   */\n\n\n  createListener(options = {}, handler) {\n    if (typeof options === 'function') {\n      handler = options;\n      options = {};\n    }\n\n    return createListener({\n      handler,\n      upgrader: this._upgrader\n    }, options);\n  }\n  /**\n   * Takes a list of `Multiaddr`s and returns only valid Websockets addresses.\n   * By default, in a browser environment only DNS+WSS multiaddr is accepted,\n   * while in a Node.js environment DNS+{WS, WSS} multiaddrs are accepted.\n   *\n   * @param {Multiaddr[]} multiaddrs\n   * @returns {Multiaddr[]} Valid Websockets multiaddrs\n   */\n\n\n  filter(multiaddrs) {\n    multiaddrs = Array.isArray(multiaddrs) ? multiaddrs : [multiaddrs];\n\n    if (this._filter) {\n      return this._filter(multiaddrs);\n    } // Browser\n\n\n    if (env.isBrowser || env.isWebWorker) {\n      return filters.dnsWss(multiaddrs);\n    }\n\n    return filters.all(multiaddrs);\n  }\n\n}\n\nmodule.exports = withIs(WebSockets, {\n  className: 'WebSockets',\n  symbolName: '@libp2p/js-libp2p-websockets/websockets'\n});","map":null,"metadata":{},"sourceType":"script"}