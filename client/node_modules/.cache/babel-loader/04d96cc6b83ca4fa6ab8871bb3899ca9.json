{"ast":null,"code":"/* eslint max-nested-callbacks: [\"error\", 8] */\n'use strict';\n\nconst _require = require('../../utils'),\n      resolvePath = _require.resolvePath;\n\nconst PinManager = require('./pin-manager');\n\nconst PinTypes = PinManager.PinTypes;\n\nconst withTimeoutOption = require('ipfs-core-utils/src/with-timeout-option');\n/** @type {(source:Source) => AsyncIterable<PinTarget>} */\n\n\nconst normaliseInput = require('ipfs-core-utils/src/pins/normalise-input');\n/**\n * @param {Object} config\n * @param {import('.').GCLock} config.gcLock\n * @param {import('.').DagReader} config.dagReader\n * @param {import('.').PinManager} config.pinManager\n */\n\n\nmodule.exports = ({\n  pinManager,\n  gcLock,\n  dagReader\n}) => {\n  /**\n   * Adds multiple IPFS objects to the pinset and also stores it to the IPFS\n   * repo. pinset is the set of hashes currently pinned (not gc'able)\n   *\n   * @param {Source} source - One or more CIDs or IPFS Paths to pin in your repo\n   * @param {AddOptions} [options]\n   * @returns {AsyncIterable<CID>} - CIDs that were pinned.\n   * @example\n   * ```js\n   * const cid = CID.from('QmWATWQ7fVPP2EFGu71UkfnqhYXDYH566qy47CnJDgvs8u')\n   * for await (const cid of ipfs.pin.addAll([cid])) {\n   *   console.log(cid)\n   * }\n   * // Logs:\n   * // CID('QmWATWQ7fVPP2EFGu71UkfnqhYXDYH566qy47CnJDgvs8u')\n   * ```\n   */\n  async function* addAll(source, options = {}) {\n    /**\n     * @returns {AsyncIterable<CID>}\n     */\n    const pinAdd = async function* () {\n      for await (const _ref of normaliseInput(source)) {\n        const path = _ref.path;\n        const recursive = _ref.recursive;\n        const metadata = _ref.metadata;\n        const cid = await resolvePath(dagReader, path); // verify that each hash can be pinned\n\n        const _ref2 = await pinManager.isPinnedWithType(cid, [PinTypes.recursive, PinTypes.direct]),\n              reason = _ref2.reason;\n\n        if (reason === 'recursive' && !recursive) {\n          // only disallow trying to override recursive pins\n          throw new Error(\"\".concat(cid, \" already pinned recursively\"));\n        }\n\n        if (recursive) {\n          await pinManager.pinRecursively(cid, {\n            metadata\n          });\n        } else {\n          await pinManager.pinDirectly(cid, {\n            metadata\n          });\n        }\n\n        yield cid;\n      }\n    }; // When adding a file, we take a lock that gets released after pinning\n    // is complete, so don't take a second lock here\n\n\n    const lock = Boolean(options.lock);\n\n    if (!lock) {\n      yield* pinAdd();\n      return;\n    }\n\n    const release = await gcLock.readLock();\n\n    try {\n      yield* pinAdd();\n    } finally {\n      release();\n    }\n  }\n\n  return withTimeoutOption(addAll);\n};\n/**\n * @typedef {import('ipfs-core-utils/src/pins/normalise-input').Source} Source\n * @typedef {import('ipfs-core-utils/src/pins/normalise-input').Pin} PinTarget\n *\n * @typedef {AddSettings & AbortOptions} AddOptions\n *\n * @typedef {Object} AddSettings\n * @property {boolean} [lock]\n *\n * @typedef {import('.').AbortOptions} AbortOptions\n *\n * @typedef {import('.').CID} CID\n */\n\n/**\n * @template T\n * @typedef {Iterable<T>|AsyncIterable<T>} AwaitIterable\n */","map":null,"metadata":{},"sourceType":"script"}