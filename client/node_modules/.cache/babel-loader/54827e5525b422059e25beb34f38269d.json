{"ast":null,"code":"'use strict';\n\nconst _require = require('../../src/utils'),\n      createStore = _require.createStore,\n      findLevelJs = _require.findLevelJs;\n\nconst _require2 = require('interface-datastore'),\n      Key = _require2.Key;\n\nconst fromString = require('uint8arrays/from-string');\n\nconst toString = require('uint8arrays/to-string');\n\nasync function keysToBinary(name, store, onProgress = () => {}) {\n  let db = findLevelJs(store); // only interested in level-js\n\n  if (!db) {\n    onProgress(\"\".concat(name, \" did not need an upgrade\"));\n    return;\n  }\n\n  onProgress(\"Upgrading \".concat(name));\n  await withEach(db, (key, value) => {\n    return [{\n      type: 'del',\n      key: key\n    }, {\n      type: 'put',\n      key: fromString(key),\n      value: value\n    }];\n  });\n}\n\nasync function keysToStrings(name, store, onProgress = () => {}) {\n  let db = findLevelJs(store); // only interested in level-js\n\n  if (!db) {\n    onProgress(\"\".concat(name, \" did not need a downgrade\"));\n    return;\n  }\n\n  onProgress(\"Downgrading \".concat(name));\n  await withEach(db, (key, value) => {\n    return [{\n      type: 'del',\n      key: key\n    }, {\n      type: 'put',\n      key: toString(key),\n      value: value\n    }];\n  });\n}\n\nasync function process(repoPath, repoOptions, onProgress, fn) {\n  const datastores = Object.keys(repoOptions.storageBackends).filter(key => repoOptions.storageBackends[key].name === 'LevelDatastore').map(name => ({\n    name,\n    store: createStore(repoPath, name, repoOptions)\n  }));\n  onProgress(0, \"Migrating \".concat(datastores.length, \" dbs\"));\n  let migrated = 0;\n\n  for (const _ref of datastores) {\n    const name = _ref.name;\n    const store = _ref.store;\n    await store.open();\n\n    try {\n      await fn(name, store, message => {\n        onProgress(parseInt(migrated / datastores.length * 100), message);\n      });\n    } finally {\n      migrated++;\n      store.close();\n    }\n  }\n\n  onProgress(100, \"Migrated \".concat(datastores.length, \" dbs\"));\n}\n\nmodule.exports = {\n  version: 10,\n  description: 'Migrates datastore-level keys to binary',\n  migrate: (repoPath, repoOptions, onProgress = () => {}) => {\n    return process(repoPath, repoOptions, onProgress, keysToBinary);\n  },\n  revert: (repoPath, repoOptions, onProgress = () => {}) => {\n    return process(repoPath, repoOptions, onProgress, keysToStrings);\n  }\n};\n/**\n * @typedef {Uint8Array|string} Key\n * @typedef {Uint8Array} Value\n * @typedef {{ type: 'del', key: Key } | { type: 'put', key: Key, value: Value }} Operation\n *\n * Uses the upgrade strategy from level-js@5.x.x - note we can't call the `.upgrade` command\n * directly because it will be removed in level-js@6.x.x and we can't guarantee users will\n * have migrated by then - e.g. they may jump from level-js@4.x.x straight to level-js@6.x.x\n * so we have to duplicate the code here.\n *\n * @param {import('interface-datastore').Datastore} db\n * @param {function (Key, Value): Operation[]} fn\n */\n\nfunction withEach(db, fn) {\n  function batch(operations, next) {\n    const store = db.store('readwrite');\n    const transaction = store.transaction;\n    let index = 0;\n    let error;\n\n    transaction.onabort = () => next(error || transaction.error || new Error('aborted by user'));\n\n    transaction.oncomplete = () => next();\n\n    function loop() {\n      var op = operations[index++];\n      var key = op.key;\n\n      try {\n        var req = op.type === 'del' ? store.delete(key) : store.put(op.value, key);\n      } catch (err) {\n        error = err;\n        transaction.abort();\n        return;\n      }\n\n      if (index < operations.length) {\n        req.onsuccess = loop;\n      }\n    }\n\n    loop();\n  }\n\n  return new Promise((resolve, reject) => {\n    const it = db.iterator(); // raw keys and values only\n\n    it._deserializeKey = it._deserializeValue = data => data;\n\n    next();\n\n    function next() {\n      it.next((err, key, value) => {\n        if (err || key === undefined) {\n          it.end(err2 => {\n            if (err2) {\n              reject(err2);\n              return;\n            }\n\n            resolve();\n          });\n          return;\n        }\n\n        batch(fn(key, value), next);\n      });\n    }\n  });\n}","map":null,"metadata":{},"sourceType":"script"}