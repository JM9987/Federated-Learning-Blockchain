{"ast":null,"code":"'use strict';\n\nconst errCode = require('err-code');\n\nconst log = require('debug')('ipfs:mfs:mkdir');\n\nconst exporter = require('ipfs-unixfs-exporter');\n\nconst createNode = require('./utils/create-node');\n\nconst toPathComponents = require('./utils/to-path-components');\n\nconst updateMfsRoot = require('./utils/update-mfs-root');\n\nconst updateTree = require('./utils/update-tree');\n\nconst addLink = require('./utils/add-link');\n\nconst withMfsRoot = require('./utils/with-mfs-root');\n\nconst mergeOptions = require('merge-options').bind({\n  ignoreUndefined: true\n});\n\nconst withTimeoutOption = require('ipfs-core-utils/src/with-timeout-option');\n\nconst defaultOptions = {\n  parents: false,\n  hashAlg: 'sha2-256',\n  cidVersion: 0,\n  shardSplitThreshold: 1000,\n  flush: true,\n  mode: null,\n  mtime: null,\n  signal: undefined\n};\n\nmodule.exports = context => {\n  /**\n   * Make a directory in your MFS\n   *\n   * @param {string} path\n   * @param {MkdirOptions & AbortOptions} [options]\n   * @returns {Promise<void>}\n   * @example\n   * ```js\n   * await ipfs.files.mkdir('/my/beautiful/directory')\n   * ```\n   */\n  async function mfsMkdir(path, options = {}) {\n    const opts = mergeOptions(defaultOptions, options);\n\n    if (!path) {\n      throw new Error('no path given to Mkdir');\n    }\n\n    path = path.trim();\n\n    if (path === '/') {\n      if (opts.parents) {\n        return;\n      }\n\n      throw errCode(new Error('cannot create directory \\'/\\': Already exists'), 'ERR_INVALID_PATH');\n    }\n\n    if (path.substring(0, 1) !== '/') {\n      throw errCode(new Error('paths must start with a leading slash'), 'ERR_INVALID_PATH');\n    }\n\n    log(\"Creating \".concat(path));\n    const pathComponents = toPathComponents(path);\n\n    if (pathComponents[0] === 'ipfs') {\n      throw errCode(new Error(\"path cannot have the prefix 'ipfs'\"), 'ERR_INVALID_PATH');\n    }\n\n    const root = await withMfsRoot(context, opts);\n    let parent;\n    const trail = [];\n    const emptyDir = await createNode(context, 'directory', opts); // make sure the containing folder exists, creating it if necessary\n\n    for (let i = 0; i <= pathComponents.length; i++) {\n      const subPathComponents = pathComponents.slice(0, i);\n      const subPath = \"/ipfs/\".concat(root, \"/\").concat(subPathComponents.join('/'));\n\n      try {\n        parent = await exporter(subPath, context.ipld);\n        log(\"\".concat(subPath, \" existed\"));\n        log(\"\".concat(subPath, \" had children \").concat(parent.node.Links.map(link => link.Name)));\n\n        if (i === pathComponents.length) {\n          if (opts.parents) {\n            return;\n          }\n\n          throw errCode(new Error('file already exists'), 'ERR_ALREADY_EXISTS');\n        }\n\n        trail.push({\n          name: parent.name,\n          cid: parent.cid\n        });\n      } catch (err) {\n        if (err.code === 'ERR_NOT_FOUND') {\n          if (i < pathComponents.length && !opts.parents) {\n            throw errCode(new Error(\"Intermediate directory path \".concat(subPath, \" does not exist, use the -p flag to create it\")), 'ERR_NOT_FOUND');\n          } // add the intermediate directory\n\n\n          await addEmptyDir(context, subPathComponents[subPathComponents.length - 1], emptyDir, trail[trail.length - 1], trail, opts);\n        } else {\n          throw err;\n        }\n      }\n    } // add an empty dir to the last path component\n    // await addEmptyDir(context, pathComponents[pathComponents.length - 1], emptyDir, parent, trail)\n    // update the tree from the leaf to the root\n\n\n    const newRootCid = await updateTree(context, trail, opts); // Update the MFS record with the new CID for the root of the tree\n\n    await updateMfsRoot(context, newRootCid, opts);\n  }\n\n  return withTimeoutOption(mfsMkdir);\n};\n\nconst addEmptyDir = async (context, childName, emptyDir, parent, trail, options) => {\n  log(\"Adding empty dir called \".concat(childName, \" to \").concat(parent.cid));\n  const result = await addLink(context, {\n    parent: parent.node,\n    parentCid: parent.cid,\n    size: emptyDir.node.size,\n    cid: emptyDir.cid,\n    name: childName,\n    hashAlg: options.hashAlg,\n    cidVersion: options.cidVersion,\n    flush: options.flush\n  });\n  trail[trail.length - 1].cid = result.cid;\n  trail.push({\n    name: childName,\n    cid: emptyDir.cid\n  });\n};\n/**\n * @typedef {Object} MkdirOptions\n * @property {boolean} [parents=false] - If true, create intermediate directories\n * @property {ToMode} [mode] - An integer that represents the file mode\n * @property {ToMTime} [mtime] - A Date object, an object with `{ secs, nsecs }` properties where secs is the number of seconds since (positive) or before (negative) the Unix Epoch began and nsecs is the number of nanoseconds since the last full second, or the output of `process.hrtime()\n * @property {boolean} [flush] - If true the changes will be immediately flushed to disk\n * @property {string} [hashAlg='sha2-256'] - The hash algorithm to use for any updated entries\n * @property {CIDVersion} [cidVersion=0] - The CID version to use for any updated entries\n *\n * @typedef {import('cids')} CID\n * @typedef {import('cids').CIDVersion} CIDVersion\n * @typedef {import('ipfs-core-types/src/basic').AbortOptions} AbortOptions\n * @typedef {import('ipfs-core-types/src/files').MTime} Mtime\n * @typedef {import('ipfs-core-types/src/files').ToMTime} ToMTime\n * @typedef {import('ipfs-core-types/src/files').ToMode} ToMode\n */","map":null,"metadata":{},"sourceType":"script"}