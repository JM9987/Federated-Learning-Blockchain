{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.XXFallbackHandshake = void 0;\n\nconst buffer_1 = require(\"buffer\");\n\nconst handshake_xx_1 = require(\"./handshake-xx\");\n\nconst utils_1 = require(\"./utils\");\n\nconst logger_1 = require(\"./logger\");\n\nconst encoder_1 = require(\"./encoder\");\n\nclass XXFallbackHandshake extends handshake_xx_1.XXHandshake {\n  constructor(isInitiator, payload, prologue, staticKeypair, connection, initialMsg, remotePeer, ephemeralKeys, handshake) {\n    super(isInitiator, payload, prologue, staticKeypair, connection, remotePeer, handshake);\n\n    if (ephemeralKeys) {\n      this.ephemeralKeys = ephemeralKeys;\n    }\n\n    this.initialMsg = initialMsg;\n  } // stage 0\n  // eslint-disable-next-line require-await\n\n\n  async propose() {\n    if (this.isInitiator) {\n      this.xx.sendMessage(this.session, buffer_1.Buffer.alloc(0), this.ephemeralKeys);\n      logger_1.logger('XX Fallback Stage 0 - Initialized state as the first message was sent by initiator.');\n      logger_1.logLocalEphemeralKeys(this.session.hs.e);\n    } else {\n      logger_1.logger('XX Fallback Stage 0 - Responder decoding initial msg from IK.');\n      const receivedMessageBuffer = encoder_1.decode0(this.initialMsg);\n\n      const _this$xx$recvMessage = this.xx.recvMessage(this.session, {\n        ne: receivedMessageBuffer.ne,\n        ns: buffer_1.Buffer.alloc(0),\n        ciphertext: buffer_1.Buffer.alloc(0)\n      }),\n            valid = _this$xx$recvMessage.valid;\n\n      if (!valid) {\n        throw new Error('xx fallback stage 0 decryption validation fail');\n      }\n\n      logger_1.logger('XX Fallback Stage 0 - Responder used received message from IK.');\n      logger_1.logRemoteEphemeralKey(this.session.hs.re);\n    }\n  } // stage 1\n\n\n  async exchange() {\n    if (this.isInitiator) {\n      const receivedMessageBuffer = encoder_1.decode1(this.initialMsg);\n\n      const _this$xx$recvMessage2 = this.xx.recvMessage(this.session, receivedMessageBuffer),\n            plaintext = _this$xx$recvMessage2.plaintext,\n            valid = _this$xx$recvMessage2.valid;\n\n      if (!valid) {\n        throw new Error('xx fallback stage 1 decryption validation fail');\n      }\n\n      logger_1.logger('XX Fallback Stage 1 - Initiator used received message from IK.');\n      logger_1.logRemoteEphemeralKey(this.session.hs.re);\n      logger_1.logRemoteStaticKey(this.session.hs.rs);\n      logger_1.logger(\"Initiator going to check remote's signature...\");\n\n      try {\n        const decodedPayload = await utils_1.decodePayload(plaintext);\n        this.remotePeer = this.remotePeer || (await utils_1.getPeerIdFromPayload(decodedPayload));\n        await utils_1.verifySignedPayload(this.session.hs.rs, decodedPayload, this.remotePeer);\n        this.setRemoteEarlyData(decodedPayload.data);\n      } catch (e) {\n        const err = e;\n        throw new Error(\"Error occurred while verifying signed payload from responder: \".concat(err.message));\n      }\n\n      logger_1.logger('All good with the signature!');\n    } else {\n      logger_1.logger('XX Fallback Stage 1 - Responder start');\n      await super.exchange();\n      logger_1.logger('XX Fallback Stage 1 - Responder end');\n    }\n  }\n\n}\n\nexports.XXFallbackHandshake = XXFallbackHandshake;","map":null,"metadata":{},"sourceType":"script"}