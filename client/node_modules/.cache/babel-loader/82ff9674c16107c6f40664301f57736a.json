{"ast":null,"code":"'use strict';\n\nvar _toArray = require(\"/home/ubuntu/TFG_FL/client/node_modules/@babel/runtime/helpers/toArray\");\n\nconst debug = require('debug');\n\nconst errcode = require('err-code');\n\nconst _require = require('../../utils'),\n      mergeOptions = _require.mergeOptions;\n\nconst CID = require('cids');\n\nconst isDomain = require('is-domain-name');\n\nconst log = Object.assign(debug('ipfs:name:resolve'), {\n  error: debug('ipfs:name:resolve:error')\n});\n\nconst _require2 = require('../../utils'),\n      OFFLINE_ERROR = _require2.OFFLINE_ERROR;\n\nconst withTimeoutOption = require('ipfs-core-utils/src/with-timeout-option');\n/**\n *\n * @param {string} result\n * @param {string[]} remainder\n * @returns {string}\n */\n\n\nconst appendRemainder = (result, remainder) => remainder.length > 0 ? result + '/' + remainder.join('/') : result;\n/**\n * IPNS - Inter-Planetary Naming System\n *\n * @param {Object} config\n * @param {import('.').DNS} config.dns\n * @param {import('.').IPNS} config.ipns\n * @param {import('.').PeerId} config.peerId\n * @param {import('.').IsOnline} config.isOnline\n * @param {ResolveOptions} config.options\n */\n\n\nmodule.exports = ({\n  dns,\n  ipns,\n  peerId,\n  isOnline,\n  options: {\n    offline\n  }\n}) => {\n  /**\n   * Given a key, query the DHT for its best value.\n   *\n   * @param {string} name - ipns name to resolve. Defaults to your node's peerID.\n   * @param {Options & AbortOptions} [options]\n   * @returns {AsyncIterable<string>}\n   * @example\n   * ```js\n   * // The IPNS address you want to resolve.\n   * const addr = '/ipns/ipfs.io'\n   *\n   * for await (const name of ipfs.name.resolve(addr)) {\n   *   console.log(name)\n   * }\n   * // Logs: /ipfs/QmQrX8hka2BtNHa8N8arAq16TCVx5qHcb46c5yPewRycLm\n   * ```\n   */\n  async function* resolve(name, options = {}) {\n    // eslint-disable-line require-await\n    options = mergeOptions({\n      nocache: false,\n      recursive: true\n    }, options); // TODO: params related logic should be in the core implementation\n\n    if (offline && options && options.nocache) {\n      throw errcode(new Error('cannot specify both offline and nocache'), 'ERR_NOCACHE_AND_OFFLINE');\n    } // Set node id as name for being resolved, if it is not received\n\n\n    if (!name) {\n      name = peerId.toB58String();\n    }\n\n    if (!name.startsWith('/ipns/')) {\n      name = \"/ipns/\".concat(name);\n    }\n\n    const _name$slice$split = name.slice(1).split('/'),\n          _name$slice$split2 = _toArray(_name$slice$split),\n          namespace = _name$slice$split2[0],\n          hash = _name$slice$split2[1],\n          remainder = _name$slice$split2.slice(2);\n\n    try {\n      new CID(hash); // eslint-disable-line no-new\n    } catch (err) {\n      // lets check if we have a domain ex. /ipns/ipfs.io and resolve with dns\n      if (isDomain(hash)) {\n        yield appendRemainder((await dns(hash, options)), remainder);\n        return;\n      }\n\n      log.error(err);\n      throw errcode(new Error('Invalid IPNS name'), 'ERR_IPNS_INVALID_NAME');\n    } // multihash is valid lets resolve with IPNS\n    // IPNS resolve needs a online daemon\n\n\n    if (!isOnline() && !offline) {\n      throw errcode(new Error(OFFLINE_ERROR), 'OFFLINE_ERROR');\n    } // TODO: convert ipns.resolve to return an iterator\n\n\n    yield appendRemainder((await ipns.resolve(\"/\".concat(namespace, \"/\").concat(hash), options)), remainder);\n  }\n\n  return withTimeoutOption(resolve);\n};\n/**\n * IPFS resolve options.\n *\n * @typedef {Object} Options\n * @property {boolean} [options.nocache=false] - do not use cached entries.\n * @property {boolean} [options.recursive=true] - resolve until the result is not an IPNS name.\n *\n * @typedef {Object} ResolveOptions\n * @property {boolean} [offline]\n *\n * @typedef {import('.').AbortOptions} AbortOptions\n */","map":null,"metadata":{},"sourceType":"script"}