{"ast":null,"code":"'use strict';\n\nconst PeerId = require('peer-id');\n/** @type {{success:true, time:0, text: ''}} */\n\n\nconst basePacket = {\n  success: true,\n  time: 0,\n  text: ''\n};\n\nconst withTimeoutOption = require('ipfs-core-utils/src/with-timeout-option');\n/**\n * @param {Object} config\n * @param {import('.').NetworkService} config.network\n */\n\n\nmodule.exports = ({\n  network\n}) => {\n  /**\n   * Send echo request packets to IPFS hosts.\n   *\n   * @param {PeerId} peerId - The remote peer to send packets to\n   * @param {PingOptions} [options]\n   * @returns {AsyncIterable<Packet>}\n   * @example\n   * ```js\n   * for await (const res of ipfs.ping('Qmhash')) {\n   *   if (res.time) {\n   *     console.log(`Pong received: time=${res.time} ms`)\n   *   } else {\n   *     console.log(res.text)\n   *   }\n   * }\n   * ```\n   */\n  async function* ping(peerId, options = {}) {\n    const _ref = await network.use(),\n          libp2p = _ref.libp2p;\n\n    options.count = options.count || 10;\n\n    if (!PeerId.isPeerId(peerId)) {\n      peerId = PeerId.createFromCID(peerId);\n    }\n\n    const storedPeer = libp2p.peerStore.get(peerId);\n    let id = storedPeer && storedPeer.id;\n\n    if (!id) {\n      yield { ...basePacket,\n        text: \"Looking up peer \".concat(peerId)\n      };\n      const remotePeer = await libp2p.peerRouting.findPeer(peerId);\n      id = remotePeer && remotePeer.id;\n    }\n\n    if (!id) {\n      throw new Error('Peer was not found');\n    }\n\n    yield { ...basePacket,\n      text: \"PING \".concat(id.toB58String())\n    };\n    let packetCount = 0;\n    let totalTime = 0;\n\n    for (let i = 0; i < options.count; i++) {\n      try {\n        const time = await libp2p.ping(id);\n        totalTime += time;\n        packetCount++;\n        yield { ...basePacket,\n          time\n        };\n      } catch (err) {\n        yield { ...basePacket,\n          success: false,\n          text: err.toString()\n        };\n      }\n    }\n\n    if (packetCount) {\n      const average = totalTime / packetCount;\n      yield { ...basePacket,\n        text: \"Average latency: \".concat(average, \"ms\")\n      };\n    }\n  }\n\n  return withTimeoutOption(ping);\n};\n/**\n * @typedef {Pong|PingFailure|StatusUpdate} Packet\n * Note that not all ping response objects are \"pongs\".\n * A \"pong\" message can be identified by a truthy success property and an empty\n * text property. Other ping responses are failures or status updates.\n *\n * @typedef {Object} Pong\n * @property {true} success\n * @property {number} time\n * @property {''} text\n *\n * @typedef {Object} PingFailure\n * @property {false} success\n * @property {number} time\n * @property {string} text\n *\n * @typedef {Object} StatusUpdate\n * @property {true} success\n * @property {0} time\n * @property {string} text\n *\n * @typedef {PingSettings & AbortOptions} PingOptions\n *\n * @typedef {Object} PingSettings\n * @property {number} [count=10] - The number of ping messages to send\n *\n * @typedef {import('.').AbortOptions} AbortOptions\n */","map":null,"metadata":{},"sourceType":"script"}