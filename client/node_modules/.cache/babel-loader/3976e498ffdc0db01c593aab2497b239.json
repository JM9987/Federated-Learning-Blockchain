{"ast":null,"code":"'use strict';\n\nconst EventEmitter = require('events').EventEmitter;\n\nconst Block = require('ipld-block');\n\nconst uint8ArrayEquals = require('uint8arrays/equals');\n\nconst uint8ArrayToString = require('uint8arrays/to-string');\n\nconst CONSTANTS = require('./constants');\n\nconst logger = require('./utils').logger;\n\nconst unwantEvent = cid => \"unwant:\".concat(uint8ArrayToString(cid.multihash, 'base64'));\n\nconst blockEvent = cid => \"block:\".concat(uint8ArrayToString(cid.multihash, 'base64'));\n/**\n * Internal module used to track events about incoming blocks,\n * wants and unwants.\n *\n * @param {PeerId} peerId\n * @private\n */\n\n\nclass Notifications extends EventEmitter {\n  constructor(peerId) {\n    super();\n    this.setMaxListeners(CONSTANTS.maxListeners);\n    this._log = logger(peerId, 'notif');\n  }\n  /**\n   * Signal the system that we received `block`.\n   *\n   * @param {Block} block\n   * @returns {void}\n   */\n\n\n  hasBlock(block) {\n    const event = blockEvent(block.cid);\n\n    this._log(event);\n\n    this.emit(event, block);\n  }\n  /**\n   * Signal the system that we are waiting to receive the\n   * block associated with the given `cid`.\n   * Returns a Promise that resolves to the block when it is received,\n   * or undefined when the block is unwanted.\n   *\n   * @param {CID} cid\n   * @param {Object} options\n   * @param {AbortSignal} options.abortSignal\n   * @returns {Promise<Block>}\n   */\n\n\n  wantBlock(cid, options = {}) {\n    if (!cid) {\n      throw new Error('Not a valid cid');\n    }\n\n    const blockEvt = blockEvent(cid);\n    const unwantEvt = unwantEvent(cid);\n\n    this._log(\"wantBlock:\".concat(cid));\n\n    return new Promise((resolve, reject) => {\n      const onUnwant = () => {\n        this.removeListener(blockEvt, onBlock);\n        reject(new Error(\"Block for \".concat(cid, \" unwanted\")));\n      };\n\n      const onBlock = block => {\n        this.removeListener(unwantEvt, onUnwant);\n\n        if (!uint8ArrayEquals(cid.multihash, block.cid.multihash)) {\n          // wrong block\n          return reject(new Error(\"Incorrect block received for \".concat(cid)));\n        } else if (cid.version !== block.cid.version || cid.codec !== block.cid.codec) {\n          // right block but wrong version or codec\n          block = new Block(block.data, cid);\n        }\n\n        resolve(block);\n      };\n\n      this.once(unwantEvt, onUnwant);\n      this.once(blockEvt, onBlock);\n\n      if (options && options.signal) {\n        options.signal.addEventListener('abort', () => {\n          this.removeListener(blockEvt, onBlock);\n          this.removeListener(unwantEvt, onUnwant);\n          reject(new Error(\"Want for \".concat(cid, \" aborted\")));\n        });\n      }\n    });\n  }\n  /**\n   * Signal that the block is not wanted anymore.\n   *\n   * @param {CID} cid - the CID of the block that is not wanted anymore.\n   * @returns {void}\n   */\n\n\n  unwantBlock(cid) {\n    const event = unwantEvent(cid);\n\n    this._log(event);\n\n    this.emit(event);\n  }\n\n}\n\nmodule.exports = Notifications;","map":null,"metadata":{},"sourceType":"script"}