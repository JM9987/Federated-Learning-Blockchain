{"ast":null,"code":"'use strict';\n\nvar _objectWithoutProperties = require(\"/home/ubuntu/Codigo_Javier/client/node_modules/@babel/runtime/helpers/objectWithoutProperties\");\n\nconst stream = require('stream');\n\nconst util = require('util');\n\nconst Decoder = require('./decoder');\n\nconst Simple = require('./simple');\n\nconst utils = require('./utils');\n\nconst NoFilter = require('nofilter');\n\nconst _require = require('./constants'),\n      BigNumber = _require.BigNumber,\n      MT = _require.MT,\n      SYMS = _require.SYMS;\n/**\n  * @typedef DiagnoseOptions\n  * @property {string} [separator='\\n'] - output between detected objects\n  * @property {boolean} [stream_errors=false] - put error info into the\n  *   output stream\n  * @property {number} [max_depth=-1] - the maximum depth to parse.\n  *   Use -1 for \"until you run out of memory\".  Set this to a finite\n  *   positive number for un-trusted inputs.  Most standard inputs won't nest\n  *   more than 100 or so levels; I've tested into the millions before\n  *   running out of memory.\n  * @property {object} [tags] - mapping from tag number to function(v),\n  *   where v is the decoded value that comes after the tag, and where the\n  *   function returns the correctly-created value for that tag.\n  * @property {object} [tags] - mapping from tag number to function(v),\n  *   where v is the decoded value that comes after the tag, and where the\n  *   function returns the correctly-created value for that tag.\n  * @property {boolean} [bigint=true] generate JavaScript BigInt's\n  *   instead of BigNumbers, when possible.\n  * @property {boolean} [preferWeb=false] - if true, prefer Uint8Arrays to\n  *   be generated instead of node Buffers.  This might turn on some more\n  *   changes in the future, so forward-compatibility is not guaranteed yet.\n  * @property {string} [encoding='hex'] - the encoding of input, ignored if\n  *   input is not string\n  */\n\n/**\n  * @callback diagnoseCallback\n  * @param {Error} [error] - if one was generated\n  * @param {string} [value] - the diagnostic value\n  */\n\n/**\n  * @param {DiagnoseOptions|diagnoseCallback|string} opts options,\n  *   the callback, or input incoding\n  * @param {diagnoseCallback} [cb] - called on completion\n  * @returns {{options: DiagnoseOptions, cb: diagnoseCallback}}\n  * @private\n  */\n\n\nfunction normalizeOptions(opts, cb) {\n  switch (typeof opts) {\n    case 'function':\n      return {\n        options: {},\n        cb:\n        /** @type {diagnoseCallback} */\n        opts\n      };\n\n    case 'string':\n      return {\n        options: {\n          encoding: opts\n        },\n        cb\n      };\n\n    case 'object':\n      return {\n        options: opts || {},\n        cb\n      };\n\n    default:\n      throw new TypeError('Unknown option type');\n  }\n}\n/**\n * Output the diagnostic format from a stream of CBOR bytes.\n *\n * @extends {stream.Transform}\n */\n\n\nclass Diagnose extends stream.Transform {\n  /**\n   * Creates an instance of Diagnose.\n   *\n   * @param {DiagnoseOptions} [options={}] - options for creation\n   */\n  constructor(options = {}) {\n    const _options$separator = options.separator,\n          separator = _options$separator === void 0 ? '\\n' : _options$separator,\n          _options$stream_error = options.stream_errors,\n          stream_errors = _options$stream_error === void 0 ? false : _options$stream_error,\n          tags = options.tags,\n          max_depth = options.max_depth,\n          bigint = options.bigint,\n          preferWeb = options.preferWeb,\n          encoding = options.encoding,\n          superOpts = _objectWithoutProperties(options, [\"separator\", \"stream_errors\", \"tags\", \"max_depth\", \"bigint\", \"preferWeb\", \"encoding\"]);\n\n    super({ ...superOpts,\n      readableObjectMode: false,\n      writableObjectMode: false\n    });\n    this.float_bytes = -1;\n    this.separator = separator;\n    this.stream_errors = stream_errors;\n    this.parser = new Decoder({\n      tags,\n      max_depth,\n      bigint,\n      preferWeb,\n      encoding\n    });\n    this.parser.on('more-bytes', this._on_more.bind(this));\n    this.parser.on('value', this._on_value.bind(this));\n    this.parser.on('start', this._on_start.bind(this));\n    this.parser.on('stop', this._on_stop.bind(this));\n    this.parser.on('data', this._on_data.bind(this));\n    this.parser.on('error', this._on_error.bind(this));\n  }\n\n  _transform(fresh, encoding, cb) {\n    return this.parser.write(fresh, encoding, cb);\n  }\n\n  _flush(cb) {\n    return this.parser._flush(er => {\n      if (this.stream_errors) {\n        if (er) {\n          this._on_error(er);\n        }\n\n        return cb();\n      } else {\n        return cb(er);\n      }\n    });\n  }\n  /**\n   * Convenience function to return a string in diagnostic format.\n   *\n   * @param {string|Buffer|ArrayBuffer|Uint8Array|Uint8ClampedArray\n   *   |DataView|stream.Readable} input - the CBOR bytes to format\n   * @param {DiagnoseOptions |diagnoseCallback|string} [options={}] -\n   *   options, the callback, or the input encoding\n   * @param {diagnoseCallback} [cb] - callback\n   * @returns {Promise} if callback not specified\n   */\n\n\n  static diagnose(input, options = {}, cb) {\n    if (input == null) {\n      throw new Error('input required');\n    }\n\n    var _normalizeOptions = normalizeOptions(options, cb);\n\n    options = _normalizeOptions.options;\n    cb = _normalizeOptions.cb;\n\n    const _options = options,\n          _options$encoding = _options.encoding,\n          encoding = _options$encoding === void 0 ? 'hex' : _options$encoding,\n          opts = _objectWithoutProperties(_options, [\"encoding\"]);\n\n    const bs = new NoFilter();\n    const d = new Diagnose(opts);\n    let p = null;\n\n    if (typeof cb === 'function') {\n      d.on('end', () => cb(null, bs.toString('utf8')));\n      d.on('error', cb);\n    } else {\n      p = new Promise((resolve, reject) => {\n        d.on('end', () => resolve(bs.toString('utf8')));\n        return d.on('error', reject);\n      });\n    }\n\n    d.pipe(bs);\n    utils.guessEncoding(input, encoding).pipe(d);\n    return p;\n  }\n\n  _on_error(er) {\n    if (this.stream_errors) {\n      return this.push(er.toString());\n    } else {\n      return this.emit('error', er);\n    }\n  }\n\n  _on_more(mt, len, parent_mt, pos) {\n    if (mt === MT.SIMPLE_FLOAT) {\n      return this.float_bytes = {\n        2: 1,\n        4: 2,\n        8: 3\n      }[len];\n    }\n  }\n\n  _fore(parent_mt, pos) {\n    switch (parent_mt) {\n      case MT.BYTE_STRING:\n      case MT.UTF8_STRING:\n      case MT.ARRAY:\n        if (pos > 0) {\n          return this.push(', ');\n        }\n\n        break;\n\n      case MT.MAP:\n        if (pos > 0) {\n          if (pos % 2) {\n            return this.push(': ');\n          } else {\n            return this.push(', ');\n          }\n        }\n\n    }\n  }\n\n  _on_value(val, parent_mt, pos) {\n    if (val === SYMS.BREAK) {\n      return;\n    }\n\n    this._fore(parent_mt, pos);\n\n    const fb = this.float_bytes;\n    this.float_bytes = -1;\n    return this.push(utils.cborValueToString(val, fb));\n  }\n\n  _on_start(mt, tag, parent_mt, pos) {\n    this._fore(parent_mt, pos);\n\n    switch (mt) {\n      case MT.TAG:\n        this.push(\"\".concat(tag, \"(\"));\n        break;\n\n      case MT.ARRAY:\n        this.push('[');\n        break;\n\n      case MT.MAP:\n        this.push('{');\n        break;\n\n      case MT.BYTE_STRING:\n      case MT.UTF8_STRING:\n        this.push('(');\n        break;\n    }\n\n    if (tag === SYMS.STREAM) {\n      return this.push('_ ');\n    }\n  }\n\n  _on_stop(mt) {\n    switch (mt) {\n      case MT.TAG:\n        return this.push(')');\n\n      case MT.ARRAY:\n        return this.push(']');\n\n      case MT.MAP:\n        return this.push('}');\n\n      case MT.BYTE_STRING:\n      case MT.UTF8_STRING:\n        return this.push(')');\n    }\n  }\n\n  _on_data() {\n    return this.push(this.separator);\n  }\n\n}\n\nmodule.exports = Diagnose;","map":null,"metadata":{},"sourceType":"script"}