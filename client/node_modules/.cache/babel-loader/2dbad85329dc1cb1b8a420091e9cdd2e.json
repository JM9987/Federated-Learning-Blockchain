{"ast":null,"code":"'use strict';\n\nconst mkdir = require('./mkdir');\n\nconst stat = require('./stat');\n\nconst log = require('debug')('ipfs:mfs:cp');\n\nconst errCode = require('err-code');\n\nconst updateTree = require('./utils/update-tree');\n\nconst updateMfsRoot = require('./utils/update-mfs-root');\n\nconst addLink = require('./utils/add-link');\n\nconst toMfsPath = require('./utils/to-mfs-path');\n\nconst toSourcesAndDestination = require('./utils/to-sources-and-destination');\n\nconst toTrail = require('./utils/to-trail');\n\nconst withTimeoutOption = require('ipfs-core-utils/src/with-timeout-option');\n\nconst defaultOptions = {\n  parents: false,\n  flush: true,\n  hashAlg: 'sha2-256',\n  cidVersion: 0,\n  shardSplitThreshold: 1000,\n  signal: undefined\n};\n/**\n * @param {any} context\n */\n\nmodule.exports = function derp(context) {\n  /**\n   * @param {[...from:From, options?:CpOptions]} args\n   * @returns {Promise<void>}\n   */\n  async function mfsCp(...args) {\n    let _ref = await toSourcesAndDestination(context, args, defaultOptions),\n        sources = _ref.sources,\n        destination = _ref.destination,\n        options = _ref.options;\n\n    if (!sources.length) {\n      throw errCode(new Error('Please supply at least one source'), 'ERR_INVALID_PARAMS');\n    }\n\n    options.parents = options.p || options.parents; // make sure all sources exist\n\n    const missing = sources.find(source => !source.exists);\n\n    if (missing) {\n      throw errCode(new Error(\"\".concat(missing.path, \" does not exist\")), 'ERR_INVALID_PARAMS');\n    }\n\n    const destinationIsDirectory = isDirectory(destination);\n\n    if (destination.exists) {\n      log('Destination exists');\n\n      if (sources.length === 1 && !destinationIsDirectory) {\n        throw errCode(new Error('directory already has entry by that name'), 'ERR_ALREADY_EXISTS');\n      }\n    } else {\n      log('Destination does not exist');\n\n      if (sources.length > 1) {\n        // copying multiple files to one location, destination will be a directory\n        if (!options.parents) {\n          throw errCode(new Error('destination did not exist, pass -p to create intermediate directories'), 'ERR_INVALID_PARAMS');\n        }\n\n        await mkdir(context)(destination.path, options);\n        destination = await toMfsPath(context, destination.path, options);\n      } else if (destination.parts.length > 1) {\n        // copying to a folder, create it if necessary\n        const parentFolder = \"/\".concat(destination.parts.slice(0, -1).join('/'));\n\n        try {\n          await stat(context)(parentFolder, options);\n        } catch (err) {\n          if (err.code !== 'ERR_NOT_FOUND') {\n            throw err;\n          }\n\n          if (!options.parents) {\n            throw errCode(new Error('destination did not exist, pass -p to create intermediate directories'), 'ERR_INVALID_PARAMS');\n          }\n\n          await mkdir(context)(parentFolder, options);\n          destination = await toMfsPath(context, destination.path, options);\n        }\n      }\n    }\n\n    const destinationPath = isDirectory(destination) ? destination.mfsPath : destination.mfsDirectory;\n    const trail = await toTrail(context, destinationPath);\n\n    if (sources.length === 1) {\n      const source = sources.pop();\n      const destinationName = destinationIsDirectory ? source.name : destination.name;\n      log(\"Only one source, copying to destination \".concat(destinationIsDirectory ? 'directory' : 'file', \" \").concat(destinationName));\n      return copyToFile(context, source, destinationName, trail, options);\n    }\n\n    log('Multiple sources, wrapping in a directory');\n    return copyToDirectory(context, sources, destination, trail, options);\n  }\n\n  return withTimeoutOption(mfsCp);\n};\n\nconst isDirectory = destination => {\n  return destination.unixfs && destination.unixfs.type && destination.unixfs.type.includes('directory');\n};\n\nconst copyToFile = async (context, source, destination, destinationTrail, options) => {\n  let parent = destinationTrail.pop();\n  parent = await addSourceToParent(context, source, destination, parent, options); // update the tree with the new containing directory\n\n  destinationTrail.push(parent);\n  const newRootCid = await updateTree(context, destinationTrail, options); // Update the MFS record with the new CID for the root of the tree\n\n  await updateMfsRoot(context, newRootCid, options);\n};\n\nconst copyToDirectory = async (context, sources, destination, destinationTrail, options) => {\n  // copy all the sources to the destination\n  for (let i = 0; i < sources.length; i++) {\n    const source = sources[i];\n    destination = await addSourceToParent(context, source, source.name, destination, options);\n  } // update the tree with the new containing directory\n\n\n  destinationTrail[destinationTrail.length - 1] = destination;\n  const newRootCid = await updateTree(context, destinationTrail, options); // Update the MFS record with the new CID for the root of the tree\n\n  await updateMfsRoot(context, newRootCid, options);\n};\n\nconst addSourceToParent = async (context, source, childName, parent, options) => {\n  const sourceBlock = await context.repo.blocks.get(source.cid);\n\n  const _ref2 = await addLink(context, {\n    parentCid: parent.cid,\n    size: sourceBlock.data.length,\n    cid: source.cid,\n    name: childName,\n    hashAlg: options.hashAlg,\n    cidVersion: options.cidVersion,\n    flush: options.flush\n  }),\n        node = _ref2.node,\n        cid = _ref2.cid;\n\n  parent.node = node;\n  parent.cid = cid;\n  parent.size = node.size;\n  return parent;\n};\n/**\n * @typedef {Object} CpOptions\n * @property {boolean} [flush=false]\n * @property {number} [shardSplitThreshold=1000]\n * @property {string} [hashAlg=sha2-256]\n * @property {0|1} [cidVersion=0]\n * @property {boolean} [parents=false]\n *\n * @typedef {import('./utils/types').Tuple<CID|string>} From\n *\n * @typedef {import('..').CID} CID\n * @typedef {import('../../utils').AbortOptions} AbortOptions\n */","map":null,"metadata":{},"sourceType":"script"}