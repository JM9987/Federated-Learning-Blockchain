{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.XX = void 0;\n\nconst buffer_1 = require(\"buffer\");\n\nconst utils_1 = require(\"../utils\");\n\nconst abstract_handshake_1 = require(\"./abstract-handshake\");\n\nclass XX extends abstract_handshake_1.AbstractHandshake {\n  initializeInitiator(prologue, s, rs, psk) {\n    const name = 'Noise_XX_25519_ChaChaPoly_SHA256';\n    const ss = this.initializeSymmetric(name);\n    this.mixHash(ss, prologue);\n    const re = buffer_1.Buffer.alloc(32);\n    return {\n      ss,\n      s,\n      rs,\n      psk,\n      re\n    };\n  }\n\n  initializeResponder(prologue, s, rs, psk) {\n    const name = 'Noise_XX_25519_ChaChaPoly_SHA256';\n    const ss = this.initializeSymmetric(name);\n    this.mixHash(ss, prologue);\n    const re = buffer_1.Buffer.alloc(32);\n    return {\n      ss,\n      s,\n      rs,\n      psk,\n      re\n    };\n  }\n\n  writeMessageA(hs, payload, e) {\n    const ns = buffer_1.Buffer.alloc(0);\n\n    if (e !== undefined) {\n      hs.e = e;\n    } else {\n      hs.e = utils_1.generateKeypair();\n    }\n\n    const ne = hs.e.publicKey;\n    this.mixHash(hs.ss, ne);\n    const ciphertext = this.encryptAndHash(hs.ss, payload);\n    return {\n      ne,\n      ns,\n      ciphertext\n    };\n  }\n\n  writeMessageB(hs, payload) {\n    hs.e = utils_1.generateKeypair();\n    const ne = hs.e.publicKey;\n    this.mixHash(hs.ss, ne);\n    this.mixKey(hs.ss, this.dh(hs.e.privateKey, hs.re));\n    const spk = buffer_1.Buffer.from(hs.s.publicKey);\n    const ns = this.encryptAndHash(hs.ss, spk);\n    this.mixKey(hs.ss, this.dh(hs.s.privateKey, hs.re));\n    const ciphertext = this.encryptAndHash(hs.ss, payload);\n    return {\n      ne,\n      ns,\n      ciphertext\n    };\n  }\n\n  writeMessageC(hs, payload) {\n    const spk = buffer_1.Buffer.from(hs.s.publicKey);\n    const ns = this.encryptAndHash(hs.ss, spk);\n    this.mixKey(hs.ss, this.dh(hs.s.privateKey, hs.re));\n    const ciphertext = this.encryptAndHash(hs.ss, payload);\n    const ne = this.createEmptyKey();\n    const messageBuffer = {\n      ne,\n      ns,\n      ciphertext\n    };\n\n    const _this$split = this.split(hs.ss),\n          cs1 = _this$split.cs1,\n          cs2 = _this$split.cs2;\n\n    return {\n      h: hs.ss.h,\n      messageBuffer,\n      cs1,\n      cs2\n    };\n  }\n\n  readMessageA(hs, message) {\n    if (utils_1.isValidPublicKey(message.ne)) {\n      hs.re = message.ne;\n    }\n\n    this.mixHash(hs.ss, hs.re);\n    return this.decryptAndHash(hs.ss, message.ciphertext);\n  }\n\n  readMessageB(hs, message) {\n    if (utils_1.isValidPublicKey(message.ne)) {\n      hs.re = message.ne;\n    }\n\n    this.mixHash(hs.ss, hs.re);\n\n    if (!hs.e) {\n      throw new Error('Handshake state `e` param is missing.');\n    }\n\n    this.mixKey(hs.ss, this.dh(hs.e.privateKey, hs.re));\n\n    const _this$decryptAndHash = this.decryptAndHash(hs.ss, message.ns),\n          ns = _this$decryptAndHash.plaintext,\n          valid1 = _this$decryptAndHash.valid;\n\n    if (valid1 && ns.length === 32 && utils_1.isValidPublicKey(ns)) {\n      hs.rs = ns;\n    }\n\n    this.mixKey(hs.ss, this.dh(hs.e.privateKey, hs.rs));\n\n    const _this$decryptAndHash2 = this.decryptAndHash(hs.ss, message.ciphertext),\n          plaintext = _this$decryptAndHash2.plaintext,\n          valid2 = _this$decryptAndHash2.valid;\n\n    return {\n      plaintext,\n      valid: valid1 && valid2\n    };\n  }\n\n  readMessageC(hs, message) {\n    const _this$decryptAndHash3 = this.decryptAndHash(hs.ss, message.ns),\n          ns = _this$decryptAndHash3.plaintext,\n          valid1 = _this$decryptAndHash3.valid;\n\n    if (valid1 && ns.length === 32 && utils_1.isValidPublicKey(ns)) {\n      hs.rs = ns;\n    }\n\n    if (!hs.e) {\n      throw new Error('Handshake state `e` param is missing.');\n    }\n\n    this.mixKey(hs.ss, this.dh(hs.e.privateKey, hs.rs));\n\n    const _this$decryptAndHash4 = this.decryptAndHash(hs.ss, message.ciphertext),\n          plaintext = _this$decryptAndHash4.plaintext,\n          valid2 = _this$decryptAndHash4.valid;\n\n    const _this$split2 = this.split(hs.ss),\n          cs1 = _this$split2.cs1,\n          cs2 = _this$split2.cs2;\n\n    return {\n      h: hs.ss.h,\n      plaintext,\n      valid: valid1 && valid2,\n      cs1,\n      cs2\n    };\n  }\n\n  initSession(initiator, prologue, s) {\n    const psk = this.createEmptyKey();\n    const rs = buffer_1.Buffer.alloc(32); // no static key yet\n\n    let hs;\n\n    if (initiator) {\n      hs = this.initializeInitiator(prologue, s, rs, psk);\n    } else {\n      hs = this.initializeResponder(prologue, s, rs, psk);\n    }\n\n    return {\n      hs,\n      i: initiator,\n      mc: 0\n    };\n  }\n\n  sendMessage(session, message, ephemeral) {\n    let messageBuffer;\n\n    if (session.mc === 0) {\n      messageBuffer = this.writeMessageA(session.hs, message, ephemeral);\n    } else if (session.mc === 1) {\n      messageBuffer = this.writeMessageB(session.hs, message);\n    } else if (session.mc === 2) {\n      const _this$writeMessageC = this.writeMessageC(session.hs, message),\n            h = _this$writeMessageC.h,\n            resultingBuffer = _this$writeMessageC.messageBuffer,\n            cs1 = _this$writeMessageC.cs1,\n            cs2 = _this$writeMessageC.cs2;\n\n      messageBuffer = resultingBuffer;\n      session.h = h;\n      session.cs1 = cs1;\n      session.cs2 = cs2;\n    } else if (session.mc > 2) {\n      if (session.i) {\n        if (!session.cs1) {\n          throw new Error('CS1 (cipher state) is not defined');\n        }\n\n        messageBuffer = this.writeMessageRegular(session.cs1, message);\n      } else {\n        if (!session.cs2) {\n          throw new Error('CS2 (cipher state) is not defined');\n        }\n\n        messageBuffer = this.writeMessageRegular(session.cs2, message);\n      }\n    } else {\n      throw new Error('Session invalid.');\n    }\n\n    session.mc++;\n    return messageBuffer;\n  }\n\n  recvMessage(session, message) {\n    let plaintext = buffer_1.Buffer.alloc(0);\n    let valid = false;\n\n    if (session.mc === 0) {\n      var _this$readMessageA = this.readMessageA(session.hs, message);\n\n      plaintext = _this$readMessageA.plaintext;\n      valid = _this$readMessageA.valid;\n    } else if (session.mc === 1) {\n      var _this$readMessageB = this.readMessageB(session.hs, message);\n\n      plaintext = _this$readMessageB.plaintext;\n      valid = _this$readMessageB.valid;\n    } else if (session.mc === 2) {\n      const _this$readMessageC = this.readMessageC(session.hs, message),\n            h = _this$readMessageC.h,\n            resultingPlaintext = _this$readMessageC.plaintext,\n            resultingValid = _this$readMessageC.valid,\n            cs1 = _this$readMessageC.cs1,\n            cs2 = _this$readMessageC.cs2;\n\n      plaintext = resultingPlaintext;\n      valid = resultingValid;\n      session.h = h;\n      session.cs1 = cs1;\n      session.cs2 = cs2;\n    }\n\n    session.mc++;\n    return {\n      plaintext,\n      valid\n    };\n  }\n\n}\n\nexports.XX = XX;","map":null,"metadata":{},"sourceType":"script"}