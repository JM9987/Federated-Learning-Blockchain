{"ast":null,"code":"'use strict';\n\nconst _require = require('interface-datastore'),\n      Adapter = _require.Adapter,\n      Key = _require.Key,\n      utf8Encoder = _require.utils.utf8Encoder;\n\nconst sh = require('./shard');\n\nconst KeytransformStore = require('./keytransform');\n\nconst shardKey = new Key(sh.SHARDING_FN);\nconst shardReadmeKey = new Key(sh.README_FN);\n/**\n * @typedef {import('interface-datastore').Datastore} Datastore\n * @typedef {import('interface-datastore').Options} Options\n * @typedef {import('interface-datastore').Batch} Batch\n * @typedef {import('interface-datastore').Query} Query\n * @typedef {import('interface-datastore').Pair} Pair\n * @typedef {import('./types').Shard} Shard\n *\n */\n\n/**\n * @template TValue\n * @typedef {import('./types').Await<TValue> } Await\n */\n\n/**\n * Backend independent abstraction of go-ds-flatfs.\n *\n * Wraps another datastore such that all values are stored\n * sharded according to the given sharding function.\n */\n\nclass ShardingDatastore extends Adapter {\n  /**\n   * @param {Datastore} store\n   * @param {Shard} shard\n   */\n  constructor(store, shard) {\n    super();\n    this.child = new KeytransformStore(store, {\n      convert: this._convertKey.bind(this),\n      invert: this._invertKey.bind(this)\n    });\n    this.shard = shard;\n  }\n\n  async open() {\n    await this.child.open();\n    this.shard = await ShardingDatastore.create(this.child, this.shard);\n  }\n  /**\n   * @param {Key} key\n   */\n\n\n  _convertKey(key) {\n    const s = key.toString();\n\n    if (s === shardKey.toString() || s === shardReadmeKey.toString()) {\n      return key;\n    }\n\n    const parent = new Key(this.shard.fun(s));\n    return parent.child(key);\n  }\n  /**\n   * @param {Key} key\n   */\n\n\n  _invertKey(key) {\n    const s = key.toString();\n\n    if (s === shardKey.toString() || s === shardReadmeKey.toString()) {\n      return key;\n    }\n\n    return Key.withNamespaces(key.list().slice(1));\n  }\n  /**\n   * @deprecated\n   * @param {Datastore} store\n   * @param {Shard} shard\n   */\n\n\n  static async createOrOpen(store, shard) {\n    try {\n      await ShardingDatastore.create(store, shard);\n    } catch (err) {\n      if (err && err.message !== 'datastore exists') throw err;\n    }\n\n    return ShardingDatastore.open(store);\n  }\n  /**\n   * @deprecated\n   * @param {Datastore} store\n   */\n\n\n  static async open(store) {\n    const shard = await sh.readShardFun('/', store);\n    return new ShardingDatastore(store, shard);\n  }\n  /**\n   * @param {Datastore} store\n   * @param {Shard} shard\n   */\n\n\n  static async create(store, shard) {\n    const hasShard = await store.has(shardKey);\n\n    if (!hasShard) {\n      // @ts-ignore i have no idea what putRaw is or saw any implementation\n      const put = typeof store.putRaw === 'function' ? store.putRaw.bind(store) : store.put.bind(store);\n      await Promise.all([put(shardKey, utf8Encoder.encode(shard.toString() + '\\n')), put(shardReadmeKey, utf8Encoder.encode(sh.readme))]);\n      return shard;\n    } // test shards\n\n\n    const diskShard = await sh.readShardFun('/', store);\n    const a = (diskShard || '').toString();\n    const b = shard.toString();\n\n    if (a !== b) {\n      throw new Error(\"specified fun \".concat(b, \" does not match repo shard fun \").concat(a));\n    }\n\n    return diskShard;\n  }\n  /**\n   * @param {Key} key\n   * @param {Uint8Array} val\n   * @param {Options} [options]\n   */\n\n\n  put(key, val, options) {\n    return this.child.put(key, val, options);\n  }\n  /**\n   * @param {Key} key\n   * @param {Options} [options]\n   */\n\n\n  get(key, options) {\n    return this.child.get(key, options);\n  }\n  /**\n   * @param {Key} key\n   * @param {Options} [options]\n   */\n\n\n  has(key, options) {\n    return this.child.has(key, options);\n  }\n  /**\n   * @param {Key} key\n   * @param {Options} [options]\n   */\n\n\n  delete(key, options) {\n    return this.child.delete(key, options);\n  }\n\n  batch() {\n    return this.child.batch();\n  }\n  /**\n   * @param {Query} q\n   * @param {Options} [options]\n   */\n\n\n  query(q, options) {\n    const tq = {\n      keysOnly: q.keysOnly,\n      offset: q.offset,\n      limit: q.limit,\n\n      /** @type Array<(items: Pair[]) => Await<Pair[]>> */\n      orders: [],\n      filters: [\n      /** @type {(item: Pair) => boolean} */\n      e => e.key.toString() !== shardKey.toString(),\n      /** @type {(item: Pair) => boolean} */\n      e => e.key.toString() !== shardReadmeKey.toString()]\n    };\n    const prefix = q.prefix;\n\n    if (prefix != null) {\n      tq.filters.push(e => {\n        return this._invertKey(e.key).toString().startsWith(prefix);\n      });\n    }\n\n    if (q.filters != null) {\n      // @ts-ignore - can't find a way to easily type this\n      const filters = q.filters.map(f => e => {\n        return f(Object.assign({}, e, {\n          key: this._invertKey(e.key)\n        }));\n      });\n      tq.filters = tq.filters.concat(filters);\n    }\n\n    if (q.orders != null) {\n      tq.orders = q.orders.map(o => async res => {\n        res.forEach(e => {\n          e.key = this._invertKey(e.key);\n        });\n        const ordered = await o(res);\n        ordered.forEach(e => {\n          e.key = this._convertKey(e.key);\n        });\n        return ordered;\n      });\n    }\n\n    return this.child.query(tq, options);\n  }\n\n  close() {\n    return this.child.close();\n  }\n\n}\n\nmodule.exports = ShardingDatastore;","map":null,"metadata":{},"sourceType":"script"}