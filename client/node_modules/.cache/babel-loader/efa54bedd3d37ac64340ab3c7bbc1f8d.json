{"ast":null,"code":"/*! asmCrypto Lite v1.1.0, (c) 2013 Artem S Vybornov, opensource.org/licenses/MIT */\n(function (exports, global) {\n  function IllegalStateError() {\n    var err = Error.apply(this, arguments);\n    this.message = err.message, this.stack = err.stack;\n  }\n\n  IllegalStateError.prototype = Object.create(Error.prototype, {\n    name: {\n      value: 'IllegalStateError'\n    }\n  });\n\n  function IllegalArgumentError() {\n    var err = Error.apply(this, arguments);\n    this.message = err.message, this.stack = err.stack;\n  }\n\n  IllegalArgumentError.prototype = Object.create(Error.prototype, {\n    name: {\n      value: 'IllegalArgumentError'\n    }\n  });\n\n  function SecurityError() {\n    var err = Error.apply(this, arguments);\n    this.message = err.message, this.stack = err.stack;\n  }\n\n  SecurityError.prototype = Object.create(Error.prototype, {\n    name: {\n      value: 'SecurityError'\n    }\n  });\n  var FloatArray = global.Float64Array || global.Float32Array; // make PhantomJS happy\n\n  function string_to_bytes(str, utf8) {\n    utf8 = !!utf8;\n    var len = str.length,\n        bytes = new Uint8Array(utf8 ? 4 * len : len);\n\n    for (var i = 0, j = 0; i < len; i++) {\n      var c = str.charCodeAt(i);\n\n      if (utf8 && 0xd800 <= c && c <= 0xdbff) {\n        if (++i >= len) throw new Error(\"Malformed string, low surrogate expected at position \" + i);\n        c = (c ^ 0xd800) << 10 | 0x10000 | str.charCodeAt(i) ^ 0xdc00;\n      } else if (!utf8 && c >>> 8) {\n        throw new Error(\"Wide characters are not allowed.\");\n      }\n\n      if (!utf8 || c <= 0x7f) {\n        bytes[j++] = c;\n      } else if (c <= 0x7ff) {\n        bytes[j++] = 0xc0 | c >> 6;\n        bytes[j++] = 0x80 | c & 0x3f;\n      } else if (c <= 0xffff) {\n        bytes[j++] = 0xe0 | c >> 12;\n        bytes[j++] = 0x80 | c >> 6 & 0x3f;\n        bytes[j++] = 0x80 | c & 0x3f;\n      } else {\n        bytes[j++] = 0xf0 | c >> 18;\n        bytes[j++] = 0x80 | c >> 12 & 0x3f;\n        bytes[j++] = 0x80 | c >> 6 & 0x3f;\n        bytes[j++] = 0x80 | c & 0x3f;\n      }\n    }\n\n    return bytes.subarray(0, j);\n  }\n\n  function hex_to_bytes(str) {\n    var len = str.length;\n\n    if (len & 1) {\n      str = '0' + str;\n      len++;\n    }\n\n    var bytes = new Uint8Array(len >> 1);\n\n    for (var i = 0; i < len; i += 2) {\n      bytes[i >> 1] = parseInt(str.substr(i, 2), 16);\n    }\n\n    return bytes;\n  }\n\n  function base64_to_bytes(str) {\n    return string_to_bytes(atob(str));\n  }\n\n  function bytes_to_string(bytes, utf8) {\n    utf8 = !!utf8;\n    var len = bytes.length,\n        chars = new Array(len);\n\n    for (var i = 0, j = 0; i < len; i++) {\n      var b = bytes[i];\n\n      if (!utf8 || b < 128) {\n        chars[j++] = b;\n      } else if (b >= 192 && b < 224 && i + 1 < len) {\n        chars[j++] = (b & 0x1f) << 6 | bytes[++i] & 0x3f;\n      } else if (b >= 224 && b < 240 && i + 2 < len) {\n        chars[j++] = (b & 0xf) << 12 | (bytes[++i] & 0x3f) << 6 | bytes[++i] & 0x3f;\n      } else if (b >= 240 && b < 248 && i + 3 < len) {\n        var c = (b & 7) << 18 | (bytes[++i] & 0x3f) << 12 | (bytes[++i] & 0x3f) << 6 | bytes[++i] & 0x3f;\n\n        if (c <= 0xffff) {\n          chars[j++] = c;\n        } else {\n          c ^= 0x10000;\n          chars[j++] = 0xd800 | c >> 10;\n          chars[j++] = 0xdc00 | c & 0x3ff;\n        }\n      } else {\n        throw new Error(\"Malformed UTF8 character at byte offset \" + i);\n      }\n    }\n\n    var str = '',\n        bs = 16384;\n\n    for (var i = 0; i < j; i += bs) {\n      str += String.fromCharCode.apply(String, chars.slice(i, i + bs <= j ? i + bs : j));\n    }\n\n    return str;\n  }\n\n  function bytes_to_hex(arr) {\n    var str = '';\n\n    for (var i = 0; i < arr.length; i++) {\n      var h = (arr[i] & 0xff).toString(16);\n      if (h.length < 2) str += '0';\n      str += h;\n    }\n\n    return str;\n  }\n\n  function bytes_to_base64(arr) {\n    return btoa(bytes_to_string(arr));\n  }\n\n  function pow2_ceil(a) {\n    a -= 1;\n    a |= a >>> 1;\n    a |= a >>> 2;\n    a |= a >>> 4;\n    a |= a >>> 8;\n    a |= a >>> 16;\n    a += 1;\n    return a;\n  }\n\n  function is_number(a) {\n    return typeof a === 'number';\n  }\n\n  function is_string(a) {\n    return typeof a === 'string';\n  }\n\n  function is_buffer(a) {\n    return a instanceof ArrayBuffer;\n  }\n\n  function is_bytes(a) {\n    return a instanceof Uint8Array;\n  }\n\n  function is_typed_array(a) {\n    return a instanceof Int8Array || a instanceof Uint8Array || a instanceof Int16Array || a instanceof Uint16Array || a instanceof Int32Array || a instanceof Uint32Array || a instanceof Float32Array || a instanceof Float64Array;\n  }\n\n  function _heap_init(constructor, options) {\n    var heap = options.heap,\n        size = heap ? heap.byteLength : options.heapSize || 65536;\n    if (size & 0xfff || size <= 0) throw new Error(\"heap size must be a positive integer and a multiple of 4096\");\n    heap = heap || new constructor(new ArrayBuffer(size));\n    return heap;\n  }\n\n  function _heap_write(heap, hpos, data, dpos, dlen) {\n    var hlen = heap.length - hpos,\n        wlen = hlen < dlen ? hlen : dlen;\n    heap.set(data.subarray(dpos, dpos + wlen), hpos);\n    return wlen;\n  }\n  /**\n   * Error definitions\n   */\n\n\n  global.IllegalStateError = IllegalStateError;\n  global.IllegalArgumentError = IllegalArgumentError;\n  global.SecurityError = SecurityError;\n  /**\n   * @file {@link http://asmjs.org Asm.js} implementation of the {@link https://en.wikipedia.org/wiki/Advanced_Encryption_Standard Advanced Encryption Standard}.\n   * @author Artem S Vybornov <vybornov@gmail.com>\n   * @license MIT\n   */\n\n  var AES_asm = function () {\n    \"use strict\";\n    /**\n     * Galois Field stuff init flag\n     */\n\n    var ginit_done = false;\n    /**\n     * Galois Field exponentiation and logarithm tables for 3 (the generator)\n     */\n\n    var gexp3, glog3;\n    /**\n     * Init Galois Field tables\n     */\n\n    function ginit() {\n      gexp3 = [], glog3 = [];\n      var a = 1,\n          c,\n          d;\n\n      for (c = 0; c < 255; c++) {\n        gexp3[c] = a; // Multiply by three\n\n        d = a & 0x80, a <<= 1, a &= 255;\n        if (d === 0x80) a ^= 0x1b;\n        a ^= gexp3[c]; // Set the log table value\n\n        glog3[gexp3[c]] = c;\n      }\n\n      gexp3[255] = gexp3[0];\n      glog3[0] = 0;\n      ginit_done = true;\n    }\n    /**\n     * Galois Field multiplication\n     * @param {int} a\n     * @param {int} b\n     * @return {int}\n     */\n\n\n    function gmul(a, b) {\n      var c = gexp3[(glog3[a] + glog3[b]) % 255];\n      if (a === 0 || b === 0) c = 0;\n      return c;\n    }\n    /**\n     * Galois Field reciprocal\n     * @param {int} a\n     * @return {int}\n     */\n\n\n    function ginv(a) {\n      var i = gexp3[255 - glog3[a]];\n      if (a === 0) i = 0;\n      return i;\n    }\n    /**\n     * AES stuff init flag\n     */\n\n\n    var aes_init_done = false;\n    /**\n     * Encryption, Decryption, S-Box and KeyTransform tables\n     */\n\n    var aes_sbox, aes_sinv, aes_enc, aes_dec;\n    /**\n     * Init AES tables\n     */\n\n    function aes_init() {\n      if (!ginit_done) ginit(); // Calculates AES S-Box value\n\n      function _s(a) {\n        var c, s, x;\n        s = x = ginv(a);\n\n        for (c = 0; c < 4; c++) {\n          s = (s << 1 | s >>> 7) & 255;\n          x ^= s;\n        }\n\n        x ^= 99;\n        return x;\n      } // Tables\n\n\n      aes_sbox = [], aes_sinv = [], aes_enc = [[], [], [], []], aes_dec = [[], [], [], []];\n\n      for (var i = 0; i < 256; i++) {\n        var s = _s(i); // S-Box and its inverse\n\n\n        aes_sbox[i] = s;\n        aes_sinv[s] = i; // Ecryption and Decryption tables\n\n        aes_enc[0][i] = gmul(2, s) << 24 | s << 16 | s << 8 | gmul(3, s);\n        aes_dec[0][s] = gmul(14, i) << 24 | gmul(9, i) << 16 | gmul(13, i) << 8 | gmul(11, i); // Rotate tables\n\n        for (var t = 1; t < 4; t++) {\n          aes_enc[t][i] = aes_enc[t - 1][i] >>> 8 | aes_enc[t - 1][i] << 24;\n          aes_dec[t][s] = aes_dec[t - 1][s] >>> 8 | aes_dec[t - 1][s] << 24;\n        }\n      }\n    }\n    /**\n     * Asm.js module constructor.\n     *\n     * <p>\n     * Heap buffer layout by offset:\n     * <pre>\n     * 0x0000   encryption key schedule\n     * 0x0400   decryption key schedule\n     * 0x0800   sbox\n     * 0x0c00   inv sbox\n     * 0x1000   encryption tables\n     * 0x2000   decryption tables\n     * 0x3000   reserved (future GCM multiplication lookup table)\n     * 0x4000   data\n     * </pre>\n     * Don't touch anything before <code>0x400</code>.\n     * </p>\n     *\n     * @alias AES_asm\n     * @class\n     * @param {GlobalScope} stdlib - global scope object (e.g. <code>window</code>)\n     * @param {Object} foreign - <i>ignored</i>\n     * @param {ArrayBuffer} buffer - heap buffer to link with\n     */\n\n\n    var wrapper = function (stdlib, foreign, buffer) {\n      // Init AES stuff for the first time\n      if (!aes_init_done) aes_init(); // Fill up AES tables\n\n      var heap = new Uint32Array(buffer);\n      heap.set(aes_sbox, 0x0800 >> 2);\n      heap.set(aes_sinv, 0x0c00 >> 2);\n\n      for (var i = 0; i < 4; i++) {\n        heap.set(aes_enc[i], 0x1000 + 0x400 * i >> 2);\n        heap.set(aes_dec[i], 0x2000 + 0x400 * i >> 2);\n      }\n      /**\n       * Calculate AES key schedules.\n       * @instance\n       * @memberof AES_asm\n       * @param {int} ks - key size, 4/6/8 (for 128/192/256-bit key correspondingly)\n       * @param {int} k0..k7 - key vector components\n       */\n\n\n      function set_key(ks, k0, k1, k2, k3, k4, k5, k6, k7) {\n        var ekeys = heap.subarray(0x000, 60),\n            dkeys = heap.subarray(0x100, 0x100 + 60); // Encryption key schedule\n\n        ekeys.set([k0, k1, k2, k3, k4, k5, k6, k7]);\n\n        for (var i = ks, rcon = 1; i < 4 * ks + 28; i++) {\n          var k = ekeys[i - 1];\n\n          if (i % ks === 0 || ks === 8 && i % ks === 4) {\n            k = aes_sbox[k >>> 24] << 24 ^ aes_sbox[k >>> 16 & 255] << 16 ^ aes_sbox[k >>> 8 & 255] << 8 ^ aes_sbox[k & 255];\n          }\n\n          if (i % ks === 0) {\n            k = k << 8 ^ k >>> 24 ^ rcon << 24;\n            rcon = rcon << 1 ^ (rcon & 0x80 ? 0x1b : 0);\n          }\n\n          ekeys[i] = ekeys[i - ks] ^ k;\n        } // Decryption key schedule\n\n\n        for (var j = 0; j < i; j += 4) {\n          for (var jj = 0; jj < 4; jj++) {\n            var k = ekeys[i - (4 + j) + (4 - jj) % 4];\n\n            if (j < 4 || j >= i - 4) {\n              dkeys[j + jj] = k;\n            } else {\n              dkeys[j + jj] = aes_dec[0][aes_sbox[k >>> 24]] ^ aes_dec[1][aes_sbox[k >>> 16 & 255]] ^ aes_dec[2][aes_sbox[k >>> 8 & 255]] ^ aes_dec[3][aes_sbox[k & 255]];\n            }\n          }\n        } // Set rounds number\n\n\n        asm.set_rounds(ks + 5);\n      }\n\n      var asm = function (stdlib, foreign, buffer) {\n        \"use asm\";\n\n        var S0 = 0,\n            S1 = 0,\n            S2 = 0,\n            S3 = 0,\n            I0 = 0,\n            I1 = 0,\n            I2 = 0,\n            I3 = 0,\n            N0 = 0,\n            N1 = 0,\n            N2 = 0,\n            N3 = 0,\n            M0 = 0,\n            M1 = 0,\n            M2 = 0,\n            M3 = 0,\n            H0 = 0,\n            H1 = 0,\n            H2 = 0,\n            H3 = 0,\n            R = 0;\n        var HEAP = new stdlib.Uint32Array(buffer),\n            DATA = new stdlib.Uint8Array(buffer);\n        /**\n         * AES core\n         * @param {int} k - precomputed key schedule offset\n         * @param {int} s - precomputed sbox table offset\n         * @param {int} t - precomputed round table offset\n         * @param {int} r - number of inner rounds to perform\n         * @param {int} x0..x3 - 128-bit input block vector\n         */\n\n        function _core(k, s, t, r, x0, x1, x2, x3) {\n          k = k | 0;\n          s = s | 0;\n          t = t | 0;\n          r = r | 0;\n          x0 = x0 | 0;\n          x1 = x1 | 0;\n          x2 = x2 | 0;\n          x3 = x3 | 0;\n          var t1 = 0,\n              t2 = 0,\n              t3 = 0,\n              y0 = 0,\n              y1 = 0,\n              y2 = 0,\n              y3 = 0,\n              i = 0;\n          t1 = t | 0x400, t2 = t | 0x800, t3 = t | 0xc00; // round 0\n\n          x0 = x0 ^ HEAP[(k | 0) >> 2], x1 = x1 ^ HEAP[(k | 4) >> 2], x2 = x2 ^ HEAP[(k | 8) >> 2], x3 = x3 ^ HEAP[(k | 12) >> 2]; // round 1..r\n\n          for (i = 16; (i | 0) <= r << 4; i = i + 16 | 0) {\n            y0 = HEAP[(t | x0 >> 22 & 1020) >> 2] ^ HEAP[(t1 | x1 >> 14 & 1020) >> 2] ^ HEAP[(t2 | x2 >> 6 & 1020) >> 2] ^ HEAP[(t3 | x3 << 2 & 1020) >> 2] ^ HEAP[(k | i | 0) >> 2], y1 = HEAP[(t | x1 >> 22 & 1020) >> 2] ^ HEAP[(t1 | x2 >> 14 & 1020) >> 2] ^ HEAP[(t2 | x3 >> 6 & 1020) >> 2] ^ HEAP[(t3 | x0 << 2 & 1020) >> 2] ^ HEAP[(k | i | 4) >> 2], y2 = HEAP[(t | x2 >> 22 & 1020) >> 2] ^ HEAP[(t1 | x3 >> 14 & 1020) >> 2] ^ HEAP[(t2 | x0 >> 6 & 1020) >> 2] ^ HEAP[(t3 | x1 << 2 & 1020) >> 2] ^ HEAP[(k | i | 8) >> 2], y3 = HEAP[(t | x3 >> 22 & 1020) >> 2] ^ HEAP[(t1 | x0 >> 14 & 1020) >> 2] ^ HEAP[(t2 | x1 >> 6 & 1020) >> 2] ^ HEAP[(t3 | x2 << 2 & 1020) >> 2] ^ HEAP[(k | i | 12) >> 2];\n            x0 = y0, x1 = y1, x2 = y2, x3 = y3;\n          } // final round\n\n\n          S0 = HEAP[(s | x0 >> 22 & 1020) >> 2] << 24 ^ HEAP[(s | x1 >> 14 & 1020) >> 2] << 16 ^ HEAP[(s | x2 >> 6 & 1020) >> 2] << 8 ^ HEAP[(s | x3 << 2 & 1020) >> 2] ^ HEAP[(k | i | 0) >> 2], S1 = HEAP[(s | x1 >> 22 & 1020) >> 2] << 24 ^ HEAP[(s | x2 >> 14 & 1020) >> 2] << 16 ^ HEAP[(s | x3 >> 6 & 1020) >> 2] << 8 ^ HEAP[(s | x0 << 2 & 1020) >> 2] ^ HEAP[(k | i | 4) >> 2], S2 = HEAP[(s | x2 >> 22 & 1020) >> 2] << 24 ^ HEAP[(s | x3 >> 14 & 1020) >> 2] << 16 ^ HEAP[(s | x0 >> 6 & 1020) >> 2] << 8 ^ HEAP[(s | x1 << 2 & 1020) >> 2] ^ HEAP[(k | i | 8) >> 2], S3 = HEAP[(s | x3 >> 22 & 1020) >> 2] << 24 ^ HEAP[(s | x0 >> 14 & 1020) >> 2] << 16 ^ HEAP[(s | x1 >> 6 & 1020) >> 2] << 8 ^ HEAP[(s | x2 << 2 & 1020) >> 2] ^ HEAP[(k | i | 12) >> 2];\n        }\n        /**\n         * ECB mode encryption\n         * @param {int} x0..x3 - 128-bit input block vector\n         */\n\n\n        function _ecb_enc(x0, x1, x2, x3) {\n          x0 = x0 | 0;\n          x1 = x1 | 0;\n          x2 = x2 | 0;\n          x3 = x3 | 0;\n\n          _core(0x0000, 0x0800, 0x1000, R, x0, x1, x2, x3);\n        }\n        /**\n         * ECB mode decryption\n         * @param {int} x0..x3 - 128-bit input block vector\n         */\n\n\n        function _ecb_dec(x0, x1, x2, x3) {\n          x0 = x0 | 0;\n          x1 = x1 | 0;\n          x2 = x2 | 0;\n          x3 = x3 | 0;\n          var t = 0;\n\n          _core(0x0400, 0x0c00, 0x2000, R, x0, x3, x2, x1);\n\n          t = S1, S1 = S3, S3 = t;\n        }\n        /**\n         * CBC mode encryption\n         * @param {int} x0..x3 - 128-bit input block vector\n         */\n\n\n        function _cbc_enc(x0, x1, x2, x3) {\n          x0 = x0 | 0;\n          x1 = x1 | 0;\n          x2 = x2 | 0;\n          x3 = x3 | 0;\n\n          _core(0x0000, 0x0800, 0x1000, R, I0 ^ x0, I1 ^ x1, I2 ^ x2, I3 ^ x3);\n\n          I0 = S0, I1 = S1, I2 = S2, I3 = S3;\n        }\n        /**\n         * CBC mode decryption\n         * @param {int} x0..x3 - 128-bit input block vector\n         */\n\n\n        function _cbc_dec(x0, x1, x2, x3) {\n          x0 = x0 | 0;\n          x1 = x1 | 0;\n          x2 = x2 | 0;\n          x3 = x3 | 0;\n          var t = 0;\n\n          _core(0x0400, 0x0c00, 0x2000, R, x0, x3, x2, x1);\n\n          t = S1, S1 = S3, S3 = t;\n          S0 = S0 ^ I0, S1 = S1 ^ I1, S2 = S2 ^ I2, S3 = S3 ^ I3;\n          I0 = x0, I1 = x1, I2 = x2, I3 = x3;\n        }\n        /**\n         * CFB mode encryption\n         * @param {int} x0..x3 - 128-bit input block vector\n         */\n\n\n        function _cfb_enc(x0, x1, x2, x3) {\n          x0 = x0 | 0;\n          x1 = x1 | 0;\n          x2 = x2 | 0;\n          x3 = x3 | 0;\n\n          _core(0x0000, 0x0800, 0x1000, R, I0, I1, I2, I3);\n\n          I0 = S0 = S0 ^ x0, I1 = S1 = S1 ^ x1, I2 = S2 = S2 ^ x2, I3 = S3 = S3 ^ x3;\n        }\n        /**\n         * CFB mode decryption\n         * @param {int} x0..x3 - 128-bit input block vector\n         */\n\n\n        function _cfb_dec(x0, x1, x2, x3) {\n          x0 = x0 | 0;\n          x1 = x1 | 0;\n          x2 = x2 | 0;\n          x3 = x3 | 0;\n\n          _core(0x0000, 0x0800, 0x1000, R, I0, I1, I2, I3);\n\n          S0 = S0 ^ x0, S1 = S1 ^ x1, S2 = S2 ^ x2, S3 = S3 ^ x3;\n          I0 = x0, I1 = x1, I2 = x2, I3 = x3;\n        }\n        /**\n         * OFB mode encryption / decryption\n         * @param {int} x0..x3 - 128-bit input block vector\n         */\n\n\n        function _ofb(x0, x1, x2, x3) {\n          x0 = x0 | 0;\n          x1 = x1 | 0;\n          x2 = x2 | 0;\n          x3 = x3 | 0;\n\n          _core(0x0000, 0x0800, 0x1000, R, I0, I1, I2, I3);\n\n          I0 = S0, I1 = S1, I2 = S2, I3 = S3;\n          S0 = S0 ^ x0, S1 = S1 ^ x1, S2 = S2 ^ x2, S3 = S3 ^ x3;\n        }\n        /**\n         * CTR mode encryption / decryption\n         * @param {int} x0..x3 - 128-bit input block vector\n         */\n\n\n        function _ctr(x0, x1, x2, x3) {\n          x0 = x0 | 0;\n          x1 = x1 | 0;\n          x2 = x2 | 0;\n          x3 = x3 | 0;\n\n          _core(0x0000, 0x0800, 0x1000, R, N0, N1, N2, N3);\n\n          N3 = ~M3 & N3 | M3 & N3 + 1, N2 = ~M2 & N2 | M2 & N2 + ((N3 | 0) == 0), N1 = ~M1 & N1 | M1 & N1 + ((N2 | 0) == 0), N0 = ~M0 & N0 | M0 & N0 + ((N1 | 0) == 0);\n          S0 = S0 ^ x0, S1 = S1 ^ x1, S2 = S2 ^ x2, S3 = S3 ^ x3;\n        }\n        /**\n         * GCM mode MAC calculation\n         * @param {int} x0..x3 - 128-bit input block vector\n         */\n\n\n        function _gcm_mac(x0, x1, x2, x3) {\n          x0 = x0 | 0;\n          x1 = x1 | 0;\n          x2 = x2 | 0;\n          x3 = x3 | 0;\n          var y0 = 0,\n              y1 = 0,\n              y2 = 0,\n              y3 = 0,\n              z0 = 0,\n              z1 = 0,\n              z2 = 0,\n              z3 = 0,\n              i = 0,\n              c = 0;\n          x0 = x0 ^ I0, x1 = x1 ^ I1, x2 = x2 ^ I2, x3 = x3 ^ I3;\n          y0 = H0 | 0, y1 = H1 | 0, y2 = H2 | 0, y3 = H3 | 0;\n\n          for (; (i | 0) < 128; i = i + 1 | 0) {\n            if (y0 >>> 31) {\n              z0 = z0 ^ x0, z1 = z1 ^ x1, z2 = z2 ^ x2, z3 = z3 ^ x3;\n            }\n\n            y0 = y0 << 1 | y1 >>> 31, y1 = y1 << 1 | y2 >>> 31, y2 = y2 << 1 | y3 >>> 31, y3 = y3 << 1;\n            c = x3 & 1;\n            x3 = x3 >>> 1 | x2 << 31, x2 = x2 >>> 1 | x1 << 31, x1 = x1 >>> 1 | x0 << 31, x0 = x0 >>> 1;\n            if (c) x0 = x0 ^ 0xe1000000;\n          }\n\n          I0 = z0, I1 = z1, I2 = z2, I3 = z3;\n        }\n        /**\n         * Set the internal rounds number.\n         * @instance\n         * @memberof AES_asm\n         * @param {int} r - number if inner AES rounds\n         */\n\n\n        function set_rounds(r) {\n          r = r | 0;\n          R = r;\n        }\n        /**\n         * Populate the internal state of the module.\n         * @instance\n         * @memberof AES_asm\n         * @param {int} s0...s3 - state vector\n         */\n\n\n        function set_state(s0, s1, s2, s3) {\n          s0 = s0 | 0;\n          s1 = s1 | 0;\n          s2 = s2 | 0;\n          s3 = s3 | 0;\n          S0 = s0, S1 = s1, S2 = s2, S3 = s3;\n        }\n        /**\n         * Populate the internal iv of the module.\n         * @instance\n         * @memberof AES_asm\n         * @param {int} i0...i3 - iv vector\n         */\n\n\n        function set_iv(i0, i1, i2, i3) {\n          i0 = i0 | 0;\n          i1 = i1 | 0;\n          i2 = i2 | 0;\n          i3 = i3 | 0;\n          I0 = i0, I1 = i1, I2 = i2, I3 = i3;\n        }\n        /**\n         * Set nonce for CTR-family modes.\n         * @instance\n         * @memberof AES_asm\n         * @param {int} n0..n3 - nonce vector\n         */\n\n\n        function set_nonce(n0, n1, n2, n3) {\n          n0 = n0 | 0;\n          n1 = n1 | 0;\n          n2 = n2 | 0;\n          n3 = n3 | 0;\n          N0 = n0, N1 = n1, N2 = n2, N3 = n3;\n        }\n        /**\n         * Set counter mask for CTR-family modes.\n         * @instance\n         * @memberof AES_asm\n         * @param {int} m0...m3 - counter mask vector\n         */\n\n\n        function set_mask(m0, m1, m2, m3) {\n          m0 = m0 | 0;\n          m1 = m1 | 0;\n          m2 = m2 | 0;\n          m3 = m3 | 0;\n          M0 = m0, M1 = m1, M2 = m2, M3 = m3;\n        }\n        /**\n         * Set counter for CTR-family modes.\n         * @instance\n         * @memberof AES_asm\n         * @param {int} c0...c3 - counter vector\n         */\n\n\n        function set_counter(c0, c1, c2, c3) {\n          c0 = c0 | 0;\n          c1 = c1 | 0;\n          c2 = c2 | 0;\n          c3 = c3 | 0;\n          N3 = ~M3 & N3 | M3 & c3, N2 = ~M2 & N2 | M2 & c2, N1 = ~M1 & N1 | M1 & c1, N0 = ~M0 & N0 | M0 & c0;\n        }\n        /**\n         * Store the internal state vector into the heap.\n         * @instance\n         * @memberof AES_asm\n         * @param {int} pos - offset where to put the data\n         * @return {int} The number of bytes have been written into the heap, always 16.\n         */\n\n\n        function get_state(pos) {\n          pos = pos | 0;\n          if (pos & 15) return -1;\n          DATA[pos | 0] = S0 >>> 24, DATA[pos | 1] = S0 >>> 16 & 255, DATA[pos | 2] = S0 >>> 8 & 255, DATA[pos | 3] = S0 & 255, DATA[pos | 4] = S1 >>> 24, DATA[pos | 5] = S1 >>> 16 & 255, DATA[pos | 6] = S1 >>> 8 & 255, DATA[pos | 7] = S1 & 255, DATA[pos | 8] = S2 >>> 24, DATA[pos | 9] = S2 >>> 16 & 255, DATA[pos | 10] = S2 >>> 8 & 255, DATA[pos | 11] = S2 & 255, DATA[pos | 12] = S3 >>> 24, DATA[pos | 13] = S3 >>> 16 & 255, DATA[pos | 14] = S3 >>> 8 & 255, DATA[pos | 15] = S3 & 255;\n          return 16;\n        }\n        /**\n         * Store the internal iv vector into the heap.\n         * @instance\n         * @memberof AES_asm\n         * @param {int} pos - offset where to put the data\n         * @return {int} The number of bytes have been written into the heap, always 16.\n         */\n\n\n        function get_iv(pos) {\n          pos = pos | 0;\n          if (pos & 15) return -1;\n          DATA[pos | 0] = I0 >>> 24, DATA[pos | 1] = I0 >>> 16 & 255, DATA[pos | 2] = I0 >>> 8 & 255, DATA[pos | 3] = I0 & 255, DATA[pos | 4] = I1 >>> 24, DATA[pos | 5] = I1 >>> 16 & 255, DATA[pos | 6] = I1 >>> 8 & 255, DATA[pos | 7] = I1 & 255, DATA[pos | 8] = I2 >>> 24, DATA[pos | 9] = I2 >>> 16 & 255, DATA[pos | 10] = I2 >>> 8 & 255, DATA[pos | 11] = I2 & 255, DATA[pos | 12] = I3 >>> 24, DATA[pos | 13] = I3 >>> 16 & 255, DATA[pos | 14] = I3 >>> 8 & 255, DATA[pos | 15] = I3 & 255;\n          return 16;\n        }\n        /**\n         * GCM initialization.\n         * @instance\n         * @memberof AES_asm\n         */\n\n\n        function gcm_init() {\n          _ecb_enc(0, 0, 0, 0);\n\n          H0 = S0, H1 = S1, H2 = S2, H3 = S3;\n        }\n        /**\n         * Perform ciphering operation on the supplied data.\n         * @instance\n         * @memberof AES_asm\n         * @param {int} mode - block cipher mode (see {@link AES_asm} mode constants)\n         * @param {int} pos - offset of the data being processed\n         * @param {int} len - length of the data being processed\n         * @return {int} Actual amount of data have been processed.\n         */\n\n\n        function cipher(mode, pos, len) {\n          mode = mode | 0;\n          pos = pos | 0;\n          len = len | 0;\n          var ret = 0;\n          if (pos & 15) return -1;\n\n          while ((len | 0) >= 16) {\n            _cipher_modes[mode & 7](DATA[pos | 0] << 24 | DATA[pos | 1] << 16 | DATA[pos | 2] << 8 | DATA[pos | 3], DATA[pos | 4] << 24 | DATA[pos | 5] << 16 | DATA[pos | 6] << 8 | DATA[pos | 7], DATA[pos | 8] << 24 | DATA[pos | 9] << 16 | DATA[pos | 10] << 8 | DATA[pos | 11], DATA[pos | 12] << 24 | DATA[pos | 13] << 16 | DATA[pos | 14] << 8 | DATA[pos | 15]);\n\n            DATA[pos | 0] = S0 >>> 24, DATA[pos | 1] = S0 >>> 16 & 255, DATA[pos | 2] = S0 >>> 8 & 255, DATA[pos | 3] = S0 & 255, DATA[pos | 4] = S1 >>> 24, DATA[pos | 5] = S1 >>> 16 & 255, DATA[pos | 6] = S1 >>> 8 & 255, DATA[pos | 7] = S1 & 255, DATA[pos | 8] = S2 >>> 24, DATA[pos | 9] = S2 >>> 16 & 255, DATA[pos | 10] = S2 >>> 8 & 255, DATA[pos | 11] = S2 & 255, DATA[pos | 12] = S3 >>> 24, DATA[pos | 13] = S3 >>> 16 & 255, DATA[pos | 14] = S3 >>> 8 & 255, DATA[pos | 15] = S3 & 255;\n            ret = ret + 16 | 0, pos = pos + 16 | 0, len = len - 16 | 0;\n          }\n\n          return ret | 0;\n        }\n        /**\n         * Calculates MAC of the supplied data.\n         * @instance\n         * @memberof AES_asm\n         * @param {int} mode - block cipher mode (see {@link AES_asm} mode constants)\n         * @param {int} pos - offset of the data being processed\n         * @param {int} len - length of the data being processed\n         * @return {int} Actual amount of data have been processed.\n         */\n\n\n        function mac(mode, pos, len) {\n          mode = mode | 0;\n          pos = pos | 0;\n          len = len | 0;\n          var ret = 0;\n          if (pos & 15) return -1;\n\n          while ((len | 0) >= 16) {\n            _mac_modes[mode & 1](DATA[pos | 0] << 24 | DATA[pos | 1] << 16 | DATA[pos | 2] << 8 | DATA[pos | 3], DATA[pos | 4] << 24 | DATA[pos | 5] << 16 | DATA[pos | 6] << 8 | DATA[pos | 7], DATA[pos | 8] << 24 | DATA[pos | 9] << 16 | DATA[pos | 10] << 8 | DATA[pos | 11], DATA[pos | 12] << 24 | DATA[pos | 13] << 16 | DATA[pos | 14] << 8 | DATA[pos | 15]);\n\n            ret = ret + 16 | 0, pos = pos + 16 | 0, len = len - 16 | 0;\n          }\n\n          return ret | 0;\n        }\n        /**\n         * AES cipher modes table (virual methods)\n         */\n\n\n        var _cipher_modes = [_ecb_enc, _ecb_dec, _cbc_enc, _cbc_dec, _cfb_enc, _cfb_dec, _ofb, _ctr];\n        /**\n         * AES MAC modes table (virual methods)\n         */\n\n        var _mac_modes = [_cbc_enc, _gcm_mac];\n        /**\n         * Asm.js module exports\n         */\n\n        return {\n          set_rounds: set_rounds,\n          set_state: set_state,\n          set_iv: set_iv,\n          set_nonce: set_nonce,\n          set_mask: set_mask,\n          set_counter: set_counter,\n          get_state: get_state,\n          get_iv: get_iv,\n          gcm_init: gcm_init,\n          cipher: cipher,\n          mac: mac\n        };\n      }(stdlib, foreign, buffer);\n\n      asm.set_key = set_key;\n      return asm;\n    };\n    /**\n     * AES enciphering mode constants\n     * @enum {int}\n     * @const\n     */\n\n\n    wrapper.ENC = {\n      ECB: 0,\n      CBC: 2,\n      CFB: 4,\n      OFB: 6,\n      CTR: 7\n    },\n    /**\n     * AES deciphering mode constants\n     * @enum {int}\n     * @const\n     */\n    wrapper.DEC = {\n      ECB: 1,\n      CBC: 3,\n      CFB: 5,\n      OFB: 6,\n      CTR: 7\n    },\n    /**\n     * AES MAC mode constants\n     * @enum {int}\n     * @const\n     */\n    wrapper.MAC = {\n      CBC: 0,\n      GCM: 1\n    };\n    /**\n     * Heap data offset\n     * @type {int}\n     * @const\n     */\n\n    wrapper.HEAP_DATA = 0x4000;\n    return wrapper;\n  }();\n\n  function AES(options) {\n    options = options || {};\n    this.heap = _heap_init(Uint8Array, options).subarray(AES_asm.HEAP_DATA);\n    this.asm = options.asm || AES_asm(global, null, this.heap.buffer);\n    this.mode = null;\n    this.key = null;\n    this.reset(options);\n  }\n\n  function AES_set_key(key) {\n    if (key !== undefined) {\n      if (is_buffer(key) || is_bytes(key)) {\n        key = new Uint8Array(key);\n      } else if (is_string(key)) {\n        key = string_to_bytes(key);\n      } else {\n        throw new TypeError(\"unexpected key type\");\n      }\n\n      var keylen = key.length;\n      if (keylen !== 16 && keylen !== 24 && keylen !== 32) throw new IllegalArgumentError(\"illegal key size\");\n      var keyview = new DataView(key.buffer, key.byteOffset, key.byteLength);\n      this.asm.set_key(keylen >> 2, keyview.getUint32(0), keyview.getUint32(4), keyview.getUint32(8), keyview.getUint32(12), keylen > 16 ? keyview.getUint32(16) : 0, keylen > 16 ? keyview.getUint32(20) : 0, keylen > 24 ? keyview.getUint32(24) : 0, keylen > 24 ? keyview.getUint32(28) : 0);\n      this.key = key;\n    } else if (!this.key) {\n      throw new Error(\"key is required\");\n    }\n  }\n\n  function AES_set_iv(iv) {\n    if (iv !== undefined) {\n      if (is_buffer(iv) || is_bytes(iv)) {\n        iv = new Uint8Array(iv);\n      } else if (is_string(iv)) {\n        iv = string_to_bytes(iv);\n      } else {\n        throw new TypeError(\"unexpected iv type\");\n      }\n\n      if (iv.length !== 16) throw new IllegalArgumentError(\"illegal iv size\");\n      var ivview = new DataView(iv.buffer, iv.byteOffset, iv.byteLength);\n      this.iv = iv;\n      this.asm.set_iv(ivview.getUint32(0), ivview.getUint32(4), ivview.getUint32(8), ivview.getUint32(12));\n    } else {\n      this.iv = null;\n      this.asm.set_iv(0, 0, 0, 0);\n    }\n  }\n\n  function AES_set_padding(padding) {\n    if (padding !== undefined) {\n      this.padding = !!padding;\n    } else {\n      this.padding = true;\n    }\n  }\n\n  function AES_reset(options) {\n    options = options || {};\n    this.result = null;\n    this.pos = 0;\n    this.len = 0;\n    AES_set_key.call(this, options.key);\n    if (this.hasOwnProperty('iv')) AES_set_iv.call(this, options.iv);\n    if (this.hasOwnProperty('padding')) AES_set_padding.call(this, options.padding);\n    return this;\n  }\n\n  function AES_Encrypt_process(data) {\n    if (is_string(data)) data = string_to_bytes(data);\n    if (is_buffer(data)) data = new Uint8Array(data);\n    if (!is_bytes(data)) throw new TypeError(\"data isn't of expected type\");\n    var asm = this.asm,\n        heap = this.heap,\n        amode = AES_asm.ENC[this.mode],\n        hpos = AES_asm.HEAP_DATA,\n        pos = this.pos,\n        len = this.len,\n        dpos = 0,\n        dlen = data.length || 0,\n        rpos = 0,\n        rlen = len + dlen & -16,\n        wlen = 0;\n    var result = new Uint8Array(rlen);\n\n    while (dlen > 0) {\n      wlen = _heap_write(heap, pos + len, data, dpos, dlen);\n      len += wlen;\n      dpos += wlen;\n      dlen -= wlen;\n      wlen = asm.cipher(amode, hpos + pos, len);\n      if (wlen) result.set(heap.subarray(pos, pos + wlen), rpos);\n      rpos += wlen;\n\n      if (wlen < len) {\n        pos += wlen;\n        len -= wlen;\n      } else {\n        pos = 0;\n        len = 0;\n      }\n    }\n\n    this.result = result;\n    this.pos = pos;\n    this.len = len;\n    return this;\n  }\n\n  function AES_Encrypt_finish(data) {\n    var presult = null,\n        prlen = 0;\n\n    if (data !== undefined) {\n      presult = AES_Encrypt_process.call(this, data).result;\n      prlen = presult.length;\n    }\n\n    var asm = this.asm,\n        heap = this.heap,\n        amode = AES_asm.ENC[this.mode],\n        hpos = AES_asm.HEAP_DATA,\n        pos = this.pos,\n        len = this.len,\n        plen = 16 - len % 16,\n        rlen = len;\n\n    if (this.hasOwnProperty('padding')) {\n      if (this.padding) {\n        for (var p = 0; p < plen; ++p) heap[pos + len + p] = plen;\n\n        len += plen;\n        rlen = len;\n      } else if (len % 16) {\n        throw new IllegalArgumentError(\"data length must be a multiple of the block size\");\n      }\n    } else {\n      len += plen;\n    }\n\n    var result = new Uint8Array(prlen + rlen);\n    if (prlen) result.set(presult);\n    if (len) asm.cipher(amode, hpos + pos, len);\n    if (rlen) result.set(heap.subarray(pos, pos + rlen), prlen);\n    this.result = result;\n    this.pos = 0;\n    this.len = 0;\n    return this;\n  }\n\n  function AES_Decrypt_process(data) {\n    if (is_string(data)) data = string_to_bytes(data);\n    if (is_buffer(data)) data = new Uint8Array(data);\n    if (!is_bytes(data)) throw new TypeError(\"data isn't of expected type\");\n    var asm = this.asm,\n        heap = this.heap,\n        amode = AES_asm.DEC[this.mode],\n        hpos = AES_asm.HEAP_DATA,\n        pos = this.pos,\n        len = this.len,\n        dpos = 0,\n        dlen = data.length || 0,\n        rpos = 0,\n        rlen = len + dlen & -16,\n        plen = 0,\n        wlen = 0;\n\n    if (this.hasOwnProperty('padding') && this.padding) {\n      plen = len + dlen - rlen || 16;\n      rlen -= plen;\n    }\n\n    var result = new Uint8Array(rlen);\n\n    while (dlen > 0) {\n      wlen = _heap_write(heap, pos + len, data, dpos, dlen);\n      len += wlen;\n      dpos += wlen;\n      dlen -= wlen;\n      wlen = asm.cipher(amode, hpos + pos, len - (!dlen ? plen : 0));\n      if (wlen) result.set(heap.subarray(pos, pos + wlen), rpos);\n      rpos += wlen;\n\n      if (wlen < len) {\n        pos += wlen;\n        len -= wlen;\n      } else {\n        pos = 0;\n        len = 0;\n      }\n    }\n\n    this.result = result;\n    this.pos = pos;\n    this.len = len;\n    return this;\n  }\n\n  function AES_Decrypt_finish(data) {\n    var presult = null,\n        prlen = 0;\n\n    if (data !== undefined) {\n      presult = AES_Decrypt_process.call(this, data).result;\n      prlen = presult.length;\n    }\n\n    var asm = this.asm,\n        heap = this.heap,\n        amode = AES_asm.DEC[this.mode],\n        hpos = AES_asm.HEAP_DATA,\n        pos = this.pos,\n        len = this.len,\n        rlen = len;\n\n    if (len > 0) {\n      if (len % 16) {\n        if (this.hasOwnProperty('padding')) {\n          throw new IllegalArgumentError(\"data length must be a multiple of the block size\");\n        } else {\n          len += 16 - len % 16;\n        }\n      }\n\n      asm.cipher(amode, hpos + pos, len);\n\n      if (this.hasOwnProperty('padding') && this.padding) {\n        var pad = heap[pos + rlen - 1];\n        if (pad < 1 || pad > 16 || pad > rlen) throw new SecurityError(\"bad padding\");\n        var pcheck = 0;\n\n        for (var i = pad; i > 1; i--) pcheck |= pad ^ heap[pos + rlen - i];\n\n        if (pcheck) throw new SecurityError(\"bad padding\");\n        rlen -= pad;\n      }\n    }\n\n    var result = new Uint8Array(prlen + rlen);\n\n    if (prlen > 0) {\n      result.set(presult);\n    }\n\n    if (rlen > 0) {\n      result.set(heap.subarray(pos, pos + rlen), prlen);\n    }\n\n    this.result = result;\n    this.pos = 0;\n    this.len = 0;\n    return this;\n  }\n  /**\n   * Cipher Feedback Mode (CFB)\n   */\n\n\n  function AES_CFB(options) {\n    this.iv = null;\n    AES.call(this, options);\n    this.mode = 'CFB';\n  }\n\n  var AES_CFB_prototype = AES_CFB.prototype;\n  AES_CFB_prototype.BLOCK_SIZE = 16;\n  AES_CFB_prototype.reset = AES_reset;\n  AES_CFB_prototype.encrypt = AES_Encrypt_finish;\n  AES_CFB_prototype.decrypt = AES_Decrypt_finish;\n\n  function AES_CFB_Encrypt(options) {\n    AES_CFB.call(this, options);\n  }\n\n  var AES_CFB_Encrypt_prototype = AES_CFB_Encrypt.prototype;\n  AES_CFB_Encrypt_prototype.BLOCK_SIZE = 16;\n  AES_CFB_Encrypt_prototype.reset = AES_reset;\n  AES_CFB_Encrypt_prototype.process = AES_Encrypt_process;\n  AES_CFB_Encrypt_prototype.finish = AES_Encrypt_finish;\n\n  function AES_CFB_Decrypt(options) {\n    AES_CFB.call(this, options);\n  }\n\n  var AES_CFB_Decrypt_prototype = AES_CFB_Decrypt.prototype;\n  AES_CFB_Decrypt_prototype.BLOCK_SIZE = 16;\n  AES_CFB_Decrypt_prototype.reset = AES_reset;\n  AES_CFB_Decrypt_prototype.process = AES_Decrypt_process;\n  AES_CFB_Decrypt_prototype.finish = AES_Decrypt_finish;\n  /**\n   * Counter Mode (CTR)\n   */\n\n  function AES_CTR(options) {\n    this.nonce = null, this.counter = 0, this.counterSize = 0;\n    AES.call(this, options);\n    this.mode = 'CTR';\n  }\n\n  function AES_CTR_Crypt(options) {\n    AES_CTR.call(this, options);\n  }\n\n  function AES_CTR_set_options(nonce, counter, size) {\n    if (size !== undefined) {\n      if (size < 8 || size > 48) throw new IllegalArgumentError(\"illegal counter size\");\n      this.counterSize = size;\n      var mask = Math.pow(2, size) - 1;\n      this.asm.set_mask(0, 0, mask / 0x100000000 | 0, mask | 0);\n    } else {\n      this.counterSize = size = 48;\n      this.asm.set_mask(0, 0, 0xffff, 0xffffffff);\n    }\n\n    if (nonce !== undefined) {\n      if (is_buffer(nonce) || is_bytes(nonce)) {\n        nonce = new Uint8Array(nonce);\n      } else if (is_string(nonce)) {\n        nonce = string_to_bytes(nonce);\n      } else {\n        throw new TypeError(\"unexpected nonce type\");\n      }\n\n      var len = nonce.length;\n      if (!len || len > 16) throw new IllegalArgumentError(\"illegal nonce size\");\n      this.nonce = nonce;\n      var view = new DataView(new ArrayBuffer(16));\n      new Uint8Array(view.buffer).set(nonce);\n      this.asm.set_nonce(view.getUint32(0), view.getUint32(4), view.getUint32(8), view.getUint32(12));\n    } else {\n      throw new Error(\"nonce is required\");\n    }\n\n    if (counter !== undefined) {\n      if (!is_number(counter)) throw new TypeError(\"unexpected counter type\");\n      if (counter < 0 || counter >= Math.pow(2, size)) throw new IllegalArgumentError(\"illegal counter value\");\n      this.counter = counter;\n      this.asm.set_counter(0, 0, counter / 0x100000000 | 0, counter | 0);\n    } else {\n      this.counter = counter = 0;\n    }\n  }\n\n  function AES_CTR_reset(options) {\n    options = options || {};\n    AES_reset.call(this, options);\n    AES_CTR_set_options.call(this, options.nonce, options.counter, options.counterSize);\n    return this;\n  }\n\n  var AES_CTR_prototype = AES_CTR.prototype;\n  AES_CTR_prototype.BLOCK_SIZE = 16;\n  AES_CTR_prototype.reset = AES_CTR_reset;\n  AES_CTR_prototype.encrypt = AES_Encrypt_finish;\n  AES_CTR_prototype.decrypt = AES_Encrypt_finish;\n  var AES_CTR_Crypt_prototype = AES_CTR_Crypt.prototype;\n  AES_CTR_Crypt_prototype.BLOCK_SIZE = 16;\n  AES_CTR_Crypt_prototype.reset = AES_CTR_reset;\n  AES_CTR_Crypt_prototype.process = AES_Encrypt_process;\n  AES_CTR_Crypt_prototype.finish = AES_Encrypt_finish;\n  /**\n   * Galois/Counter mode\n   */\n\n  var _AES_GCM_data_maxLength = 68719476704; // 2^36 - 2^5\n\n  function _gcm_mac_process(data) {\n    var heap = this.heap,\n        asm = this.asm,\n        dpos = 0,\n        dlen = data.length || 0,\n        wlen = 0;\n\n    while (dlen > 0) {\n      wlen = _heap_write(heap, 0, data, dpos, dlen);\n      dpos += wlen;\n      dlen -= wlen;\n\n      while (wlen & 15) heap[wlen++] = 0;\n\n      asm.mac(AES_asm.MAC.GCM, AES_asm.HEAP_DATA, wlen);\n    }\n  }\n\n  function AES_GCM(options) {\n    this.nonce = null;\n    this.adata = null;\n    this.iv = null;\n    this.counter = 1;\n    this.tagSize = 16;\n    AES.call(this, options);\n    this.mode = 'GCM';\n  }\n\n  function AES_GCM_Encrypt(options) {\n    AES_GCM.call(this, options);\n  }\n\n  function AES_GCM_Decrypt(options) {\n    AES_GCM.call(this, options);\n  }\n\n  function AES_GCM_reset(options) {\n    options = options || {};\n    AES_reset.call(this, options);\n    var asm = this.asm,\n        heap = this.heap;\n    asm.gcm_init();\n    var tagSize = options.tagSize;\n\n    if (tagSize !== undefined) {\n      if (!is_number(tagSize)) throw new TypeError(\"tagSize must be a number\");\n      if (tagSize < 4 || tagSize > 16) throw new IllegalArgumentError(\"illegal tagSize value\");\n      this.tagSize = tagSize;\n    } else {\n      this.tagSize = 16;\n    }\n\n    var nonce = options.nonce;\n\n    if (nonce !== undefined) {\n      if (is_bytes(nonce) || is_buffer(nonce)) {\n        nonce = new Uint8Array(nonce);\n      } else if (is_string(nonce)) {\n        nonce = string_to_bytes(nonce);\n      } else {\n        throw new TypeError(\"unexpected nonce type\");\n      }\n\n      this.nonce = nonce;\n      var noncelen = nonce.length || 0,\n          noncebuf = new Uint8Array(16);\n\n      if (noncelen !== 12) {\n        _gcm_mac_process.call(this, nonce);\n\n        heap[0] = heap[1] = heap[2] = heap[3] = heap[4] = heap[5] = heap[6] = heap[7] = heap[8] = heap[9] = heap[10] = 0, heap[11] = noncelen >>> 29, heap[12] = noncelen >>> 21 & 255, heap[13] = noncelen >>> 13 & 255, heap[14] = noncelen >>> 5 & 255, heap[15] = noncelen << 3 & 255;\n        asm.mac(AES_asm.MAC.GCM, AES_asm.HEAP_DATA, 16);\n        asm.get_iv(AES_asm.HEAP_DATA);\n        asm.set_iv();\n        noncebuf.set(heap.subarray(0, 16));\n      } else {\n        noncebuf.set(nonce);\n        noncebuf[15] = 1;\n      }\n\n      var nonceview = new DataView(noncebuf.buffer);\n      this.gamma0 = nonceview.getUint32(12);\n      asm.set_nonce(nonceview.getUint32(0), nonceview.getUint32(4), nonceview.getUint32(8), 0);\n      asm.set_mask(0, 0, 0, 0xffffffff);\n    } else {\n      throw new Error(\"nonce is required\");\n    }\n\n    var adata = options.adata;\n\n    if (adata !== undefined && adata !== null) {\n      if (is_bytes(adata) || is_buffer(adata)) {\n        adata = new Uint8Array(adata);\n      } else if (is_string(adata)) {\n        adata = string_to_bytes(adata);\n      } else {\n        throw new TypeError(\"unexpected adata type\");\n      }\n\n      if (adata.length > _AES_GCM_data_maxLength) throw new IllegalArgumentError(\"illegal adata length\");\n\n      if (adata.length) {\n        this.adata = adata;\n\n        _gcm_mac_process.call(this, adata);\n      } else {\n        this.adata = null;\n      }\n    } else {\n      this.adata = null;\n    }\n\n    var counter = options.counter;\n\n    if (counter !== undefined) {\n      if (!is_number(counter)) throw new TypeError(\"counter must be a number\");\n      if (counter < 1 || counter > 0xffffffff) throw new RangeError(\"counter must be a positive 32-bit integer\");\n      this.counter = counter;\n      asm.set_counter(0, 0, 0, this.gamma0 + counter | 0);\n    } else {\n      this.counter = 1;\n      asm.set_counter(0, 0, 0, this.gamma0 + 1 | 0);\n    }\n\n    var iv = options.iv;\n\n    if (iv !== undefined) {\n      if (!is_number(counter)) throw new TypeError(\"counter must be a number\");\n      this.iv = iv;\n      AES_set_iv.call(this, iv);\n    }\n\n    return this;\n  }\n\n  function AES_GCM_Encrypt_process(data) {\n    if (is_string(data)) data = string_to_bytes(data);\n    if (is_buffer(data)) data = new Uint8Array(data);\n    if (!is_bytes(data)) throw new TypeError(\"data isn't of expected type\");\n    var dpos = 0,\n        dlen = data.length || 0,\n        asm = this.asm,\n        heap = this.heap,\n        counter = this.counter,\n        pos = this.pos,\n        len = this.len,\n        rpos = 0,\n        rlen = len + dlen & -16,\n        wlen = 0;\n    if ((counter - 1 << 4) + len + dlen > _AES_GCM_data_maxLength) throw new RangeError(\"counter overflow\");\n    var result = new Uint8Array(rlen);\n\n    while (dlen > 0) {\n      wlen = _heap_write(heap, pos + len, data, dpos, dlen);\n      len += wlen;\n      dpos += wlen;\n      dlen -= wlen;\n      wlen = asm.cipher(AES_asm.ENC.CTR, AES_asm.HEAP_DATA + pos, len);\n      wlen = asm.mac(AES_asm.MAC.GCM, AES_asm.HEAP_DATA + pos, wlen);\n      if (wlen) result.set(heap.subarray(pos, pos + wlen), rpos);\n      counter += wlen >>> 4;\n      rpos += wlen;\n\n      if (wlen < len) {\n        pos += wlen;\n        len -= wlen;\n      } else {\n        pos = 0;\n        len = 0;\n      }\n    }\n\n    this.result = result;\n    this.counter = counter;\n    this.pos = pos;\n    this.len = len;\n    return this;\n  }\n\n  function AES_GCM_Encrypt_finish() {\n    var asm = this.asm,\n        heap = this.heap,\n        counter = this.counter,\n        tagSize = this.tagSize,\n        adata = this.adata,\n        pos = this.pos,\n        len = this.len;\n    var result = new Uint8Array(len + tagSize);\n    asm.cipher(AES_asm.ENC.CTR, AES_asm.HEAP_DATA + pos, len + 15 & -16);\n    if (len) result.set(heap.subarray(pos, pos + len));\n\n    for (var i = len; i & 15; i++) heap[pos + i] = 0;\n\n    asm.mac(AES_asm.MAC.GCM, AES_asm.HEAP_DATA + pos, i);\n    var alen = adata !== null ? adata.length : 0,\n        clen = (counter - 1 << 4) + len;\n    heap[0] = heap[1] = heap[2] = 0, heap[3] = alen >>> 29, heap[4] = alen >>> 21, heap[5] = alen >>> 13 & 255, heap[6] = alen >>> 5 & 255, heap[7] = alen << 3 & 255, heap[8] = heap[9] = heap[10] = 0, heap[11] = clen >>> 29, heap[12] = clen >>> 21 & 255, heap[13] = clen >>> 13 & 255, heap[14] = clen >>> 5 & 255, heap[15] = clen << 3 & 255;\n    asm.mac(AES_asm.MAC.GCM, AES_asm.HEAP_DATA, 16);\n    asm.get_iv(AES_asm.HEAP_DATA);\n    asm.set_counter(0, 0, 0, this.gamma0);\n    asm.cipher(AES_asm.ENC.CTR, AES_asm.HEAP_DATA, 16);\n    result.set(heap.subarray(0, tagSize), len);\n    this.result = result;\n    this.counter = 1;\n    this.pos = 0;\n    this.len = 0;\n    return this;\n  }\n\n  function AES_GCM_encrypt(data) {\n    var result1 = AES_GCM_Encrypt_process.call(this, data).result,\n        result2 = AES_GCM_Encrypt_finish.call(this).result;\n    var result = new Uint8Array(result1.length + result2.length);\n    if (result1.length) result.set(result1);\n    if (result2.length) result.set(result2, result1.length);\n    this.result = result;\n    return this;\n  }\n\n  function AES_GCM_Decrypt_process(data) {\n    if (is_string(data)) data = string_to_bytes(data);\n    if (is_buffer(data)) data = new Uint8Array(data);\n    if (!is_bytes(data)) throw new TypeError(\"data isn't of expected type\");\n    var dpos = 0,\n        dlen = data.length || 0,\n        asm = this.asm,\n        heap = this.heap,\n        counter = this.counter,\n        tagSize = this.tagSize,\n        pos = this.pos,\n        len = this.len,\n        rpos = 0,\n        rlen = len + dlen > tagSize ? len + dlen - tagSize & -16 : 0,\n        tlen = len + dlen - rlen,\n        wlen = 0;\n    if ((counter - 1 << 4) + len + dlen > _AES_GCM_data_maxLength) throw new RangeError(\"counter overflow\");\n    var result = new Uint8Array(rlen);\n\n    while (dlen > tlen) {\n      wlen = _heap_write(heap, pos + len, data, dpos, dlen - tlen);\n      len += wlen;\n      dpos += wlen;\n      dlen -= wlen;\n      wlen = asm.mac(AES_asm.MAC.GCM, AES_asm.HEAP_DATA + pos, wlen);\n      wlen = asm.cipher(AES_asm.DEC.CTR, AES_asm.HEAP_DATA + pos, wlen);\n      if (wlen) result.set(heap.subarray(pos, pos + wlen), rpos);\n      counter += wlen >>> 4;\n      rpos += wlen;\n      pos = 0;\n      len = 0;\n    }\n\n    if (dlen > 0) {\n      len += _heap_write(heap, 0, data, dpos, dlen);\n    }\n\n    this.result = result;\n    this.counter = counter;\n    this.pos = pos;\n    this.len = len;\n    return this;\n  }\n\n  function AES_GCM_Decrypt_finish() {\n    var asm = this.asm,\n        heap = this.heap,\n        tagSize = this.tagSize,\n        adata = this.adata,\n        counter = this.counter,\n        pos = this.pos,\n        len = this.len,\n        rlen = len - tagSize,\n        wlen = 0;\n    if (len < tagSize) throw new IllegalStateError(\"authentication tag not found\");\n    var result = new Uint8Array(rlen),\n        atag = new Uint8Array(heap.subarray(pos + rlen, pos + len));\n\n    for (var i = rlen; i & 15; i++) heap[pos + i] = 0;\n\n    wlen = asm.mac(AES_asm.MAC.GCM, AES_asm.HEAP_DATA + pos, i);\n    wlen = asm.cipher(AES_asm.DEC.CTR, AES_asm.HEAP_DATA + pos, i);\n    if (rlen) result.set(heap.subarray(pos, pos + rlen));\n    var alen = adata !== null ? adata.length : 0,\n        clen = (counter - 1 << 4) + len - tagSize;\n    heap[0] = heap[1] = heap[2] = 0, heap[3] = alen >>> 29, heap[4] = alen >>> 21, heap[5] = alen >>> 13 & 255, heap[6] = alen >>> 5 & 255, heap[7] = alen << 3 & 255, heap[8] = heap[9] = heap[10] = 0, heap[11] = clen >>> 29, heap[12] = clen >>> 21 & 255, heap[13] = clen >>> 13 & 255, heap[14] = clen >>> 5 & 255, heap[15] = clen << 3 & 255;\n    asm.mac(AES_asm.MAC.GCM, AES_asm.HEAP_DATA, 16);\n    asm.get_iv(AES_asm.HEAP_DATA);\n    asm.set_counter(0, 0, 0, this.gamma0);\n    asm.cipher(AES_asm.ENC.CTR, AES_asm.HEAP_DATA, 16);\n    var acheck = 0;\n\n    for (var i = 0; i < tagSize; ++i) acheck |= atag[i] ^ heap[i];\n\n    if (acheck) throw new SecurityError(\"data integrity check failed\");\n    this.result = result;\n    this.counter = 1;\n    this.pos = 0;\n    this.len = 0;\n    return this;\n  }\n\n  function AES_GCM_decrypt(data) {\n    var result1 = AES_GCM_Decrypt_process.call(this, data).result,\n        result2 = AES_GCM_Decrypt_finish.call(this).result;\n    var result = new Uint8Array(result1.length + result2.length);\n    if (result1.length) result.set(result1);\n    if (result2.length) result.set(result2, result1.length);\n    this.result = result;\n    return this;\n  }\n\n  var AES_GCM_prototype = AES_GCM.prototype;\n  AES_GCM_prototype.BLOCK_SIZE = 16;\n  AES_GCM_prototype.reset = AES_GCM_reset;\n  AES_GCM_prototype.encrypt = AES_GCM_encrypt;\n  AES_GCM_prototype.decrypt = AES_GCM_decrypt;\n  var AES_GCM_Encrypt_prototype = AES_GCM_Encrypt.prototype;\n  AES_GCM_Encrypt_prototype.BLOCK_SIZE = 16;\n  AES_GCM_Encrypt_prototype.reset = AES_GCM_reset;\n  AES_GCM_Encrypt_prototype.process = AES_GCM_Encrypt_process;\n  AES_GCM_Encrypt_prototype.finish = AES_GCM_Encrypt_finish;\n  var AES_GCM_Decrypt_prototype = AES_GCM_Decrypt.prototype;\n  AES_GCM_Decrypt_prototype.BLOCK_SIZE = 16;\n  AES_GCM_Decrypt_prototype.reset = AES_GCM_reset;\n  AES_GCM_Decrypt_prototype.process = AES_GCM_Decrypt_process;\n  AES_GCM_Decrypt_prototype.finish = AES_GCM_Decrypt_finish; // shared asm.js module and heap\n\n  var _AES_heap_instance = new Uint8Array(0x100000),\n      _AES_asm_instance = AES_asm(global, null, _AES_heap_instance.buffer);\n  /**\n   * AES-CFB exports\n   */\n\n\n  function AES_CFB_encrypt_bytes(data, key, iv) {\n    if (data === undefined) throw new SyntaxError(\"data required\");\n    if (key === undefined) throw new SyntaxError(\"key required\");\n    return new AES_CFB({\n      heap: _AES_heap_instance,\n      asm: _AES_asm_instance,\n      key: key,\n      iv: iv\n    }).encrypt(data).result;\n  }\n\n  function AES_CFB_decrypt_bytes(data, key, iv) {\n    if (data === undefined) throw new SyntaxError(\"data required\");\n    if (key === undefined) throw new SyntaxError(\"key required\");\n    return new AES_CFB({\n      heap: _AES_heap_instance,\n      asm: _AES_asm_instance,\n      key: key,\n      iv: iv\n    }).decrypt(data).result;\n  }\n\n  exports.AES_CFB = AES_CFB;\n  exports.AES_CFB.encrypt = AES_CFB_encrypt_bytes;\n  exports.AES_CFB.decrypt = AES_CFB_decrypt_bytes;\n  exports.AES_CFB.Encrypt = AES_CFB_Encrypt;\n  exports.AES_CFB.Decrypt = AES_CFB_Decrypt;\n  /**\n   * AES-GCM exports\n   */\n\n  function AES_GCM_encrypt_bytes(data, key, nonce, adata, tagSize) {\n    if (data === undefined) throw new SyntaxError(\"data required\");\n    if (key === undefined) throw new SyntaxError(\"key required\");\n    if (nonce === undefined) throw new SyntaxError(\"nonce required\");\n    return new AES_GCM({\n      heap: _AES_heap_instance,\n      asm: _AES_asm_instance,\n      key: key,\n      nonce: nonce,\n      adata: adata,\n      tagSize: tagSize\n    }).encrypt(data).result;\n  }\n\n  function AES_GCM_decrypt_bytes(data, key, nonce, adata, tagSize) {\n    if (data === undefined) throw new SyntaxError(\"data required\");\n    if (key === undefined) throw new SyntaxError(\"key required\");\n    if (nonce === undefined) throw new SyntaxError(\"nonce required\");\n    return new AES_GCM({\n      heap: _AES_heap_instance,\n      asm: _AES_asm_instance,\n      key: key,\n      nonce: nonce,\n      adata: adata,\n      tagSize: tagSize\n    }).decrypt(data).result;\n  }\n\n  exports.AES_GCM = AES_GCM;\n  exports.AES_GCM.encrypt = AES_GCM_encrypt_bytes;\n  exports.AES_GCM.decrypt = AES_GCM_decrypt_bytes;\n  exports.AES_GCM.Encrypt = AES_GCM_Encrypt;\n  exports.AES_GCM.Decrypt = AES_GCM_Decrypt;\n\n  function hash_reset() {\n    this.result = null;\n    this.pos = 0;\n    this.len = 0;\n    this.asm.reset();\n    return this;\n  }\n\n  function hash_process(data) {\n    if (this.result !== null) throw new IllegalStateError(\"state must be reset before processing new data\");\n    if (is_string(data)) data = string_to_bytes(data);\n    if (is_buffer(data)) data = new Uint8Array(data);\n    if (!is_bytes(data)) throw new TypeError(\"data isn't of expected type\");\n    var asm = this.asm,\n        heap = this.heap,\n        hpos = this.pos,\n        hlen = this.len,\n        dpos = 0,\n        dlen = data.length,\n        wlen = 0;\n\n    while (dlen > 0) {\n      wlen = _heap_write(heap, hpos + hlen, data, dpos, dlen);\n      hlen += wlen;\n      dpos += wlen;\n      dlen -= wlen;\n      wlen = asm.process(hpos, hlen);\n      hpos += wlen;\n      hlen -= wlen;\n      if (!hlen) hpos = 0;\n    }\n\n    this.pos = hpos;\n    this.len = hlen;\n    return this;\n  }\n\n  function hash_finish() {\n    if (this.result !== null) throw new IllegalStateError(\"state must be reset before processing new data\");\n    this.asm.finish(this.pos, this.len, 0);\n    this.result = new Uint8Array(this.HASH_SIZE);\n    this.result.set(this.heap.subarray(0, this.HASH_SIZE));\n    this.pos = 0;\n    this.len = 0;\n    return this;\n  }\n\n  function sha256_asm(stdlib, foreign, buffer) {\n    \"use asm\"; // SHA256 state\n\n    var H0 = 0,\n        H1 = 0,\n        H2 = 0,\n        H3 = 0,\n        H4 = 0,\n        H5 = 0,\n        H6 = 0,\n        H7 = 0,\n        TOTAL0 = 0,\n        TOTAL1 = 0; // HMAC state\n\n    var I0 = 0,\n        I1 = 0,\n        I2 = 0,\n        I3 = 0,\n        I4 = 0,\n        I5 = 0,\n        I6 = 0,\n        I7 = 0,\n        O0 = 0,\n        O1 = 0,\n        O2 = 0,\n        O3 = 0,\n        O4 = 0,\n        O5 = 0,\n        O6 = 0,\n        O7 = 0; // I/O buffer\n\n    var HEAP = new stdlib.Uint8Array(buffer);\n\n    function _core(w0, w1, w2, w3, w4, w5, w6, w7, w8, w9, w10, w11, w12, w13, w14, w15) {\n      w0 = w0 | 0;\n      w1 = w1 | 0;\n      w2 = w2 | 0;\n      w3 = w3 | 0;\n      w4 = w4 | 0;\n      w5 = w5 | 0;\n      w6 = w6 | 0;\n      w7 = w7 | 0;\n      w8 = w8 | 0;\n      w9 = w9 | 0;\n      w10 = w10 | 0;\n      w11 = w11 | 0;\n      w12 = w12 | 0;\n      w13 = w13 | 0;\n      w14 = w14 | 0;\n      w15 = w15 | 0;\n      var a = 0,\n          b = 0,\n          c = 0,\n          d = 0,\n          e = 0,\n          f = 0,\n          g = 0,\n          h = 0,\n          t = 0;\n      a = H0;\n      b = H1;\n      c = H2;\n      d = H3;\n      e = H4;\n      f = H5;\n      g = H6;\n      h = H7; // 0\n\n      t = w0 + h + (e >>> 6 ^ e >>> 11 ^ e >>> 25 ^ e << 26 ^ e << 21 ^ e << 7) + (g ^ e & (f ^ g)) + 0x428a2f98 | 0;\n      h = g;\n      g = f;\n      f = e;\n      e = d + t | 0;\n      d = c;\n      c = b;\n      b = a;\n      a = t + (b & c ^ d & (b ^ c)) + (b >>> 2 ^ b >>> 13 ^ b >>> 22 ^ b << 30 ^ b << 19 ^ b << 10) | 0; // 1\n\n      t = w1 + h + (e >>> 6 ^ e >>> 11 ^ e >>> 25 ^ e << 26 ^ e << 21 ^ e << 7) + (g ^ e & (f ^ g)) + 0x71374491 | 0;\n      h = g;\n      g = f;\n      f = e;\n      e = d + t | 0;\n      d = c;\n      c = b;\n      b = a;\n      a = t + (b & c ^ d & (b ^ c)) + (b >>> 2 ^ b >>> 13 ^ b >>> 22 ^ b << 30 ^ b << 19 ^ b << 10) | 0; // 2\n\n      t = w2 + h + (e >>> 6 ^ e >>> 11 ^ e >>> 25 ^ e << 26 ^ e << 21 ^ e << 7) + (g ^ e & (f ^ g)) + 0xb5c0fbcf | 0;\n      h = g;\n      g = f;\n      f = e;\n      e = d + t | 0;\n      d = c;\n      c = b;\n      b = a;\n      a = t + (b & c ^ d & (b ^ c)) + (b >>> 2 ^ b >>> 13 ^ b >>> 22 ^ b << 30 ^ b << 19 ^ b << 10) | 0; // 3\n\n      t = w3 + h + (e >>> 6 ^ e >>> 11 ^ e >>> 25 ^ e << 26 ^ e << 21 ^ e << 7) + (g ^ e & (f ^ g)) + 0xe9b5dba5 | 0;\n      h = g;\n      g = f;\n      f = e;\n      e = d + t | 0;\n      d = c;\n      c = b;\n      b = a;\n      a = t + (b & c ^ d & (b ^ c)) + (b >>> 2 ^ b >>> 13 ^ b >>> 22 ^ b << 30 ^ b << 19 ^ b << 10) | 0; // 4\n\n      t = w4 + h + (e >>> 6 ^ e >>> 11 ^ e >>> 25 ^ e << 26 ^ e << 21 ^ e << 7) + (g ^ e & (f ^ g)) + 0x3956c25b | 0;\n      h = g;\n      g = f;\n      f = e;\n      e = d + t | 0;\n      d = c;\n      c = b;\n      b = a;\n      a = t + (b & c ^ d & (b ^ c)) + (b >>> 2 ^ b >>> 13 ^ b >>> 22 ^ b << 30 ^ b << 19 ^ b << 10) | 0; // 5\n\n      t = w5 + h + (e >>> 6 ^ e >>> 11 ^ e >>> 25 ^ e << 26 ^ e << 21 ^ e << 7) + (g ^ e & (f ^ g)) + 0x59f111f1 | 0;\n      h = g;\n      g = f;\n      f = e;\n      e = d + t | 0;\n      d = c;\n      c = b;\n      b = a;\n      a = t + (b & c ^ d & (b ^ c)) + (b >>> 2 ^ b >>> 13 ^ b >>> 22 ^ b << 30 ^ b << 19 ^ b << 10) | 0; // 6\n\n      t = w6 + h + (e >>> 6 ^ e >>> 11 ^ e >>> 25 ^ e << 26 ^ e << 21 ^ e << 7) + (g ^ e & (f ^ g)) + 0x923f82a4 | 0;\n      h = g;\n      g = f;\n      f = e;\n      e = d + t | 0;\n      d = c;\n      c = b;\n      b = a;\n      a = t + (b & c ^ d & (b ^ c)) + (b >>> 2 ^ b >>> 13 ^ b >>> 22 ^ b << 30 ^ b << 19 ^ b << 10) | 0; // 7\n\n      t = w7 + h + (e >>> 6 ^ e >>> 11 ^ e >>> 25 ^ e << 26 ^ e << 21 ^ e << 7) + (g ^ e & (f ^ g)) + 0xab1c5ed5 | 0;\n      h = g;\n      g = f;\n      f = e;\n      e = d + t | 0;\n      d = c;\n      c = b;\n      b = a;\n      a = t + (b & c ^ d & (b ^ c)) + (b >>> 2 ^ b >>> 13 ^ b >>> 22 ^ b << 30 ^ b << 19 ^ b << 10) | 0; // 8\n\n      t = w8 + h + (e >>> 6 ^ e >>> 11 ^ e >>> 25 ^ e << 26 ^ e << 21 ^ e << 7) + (g ^ e & (f ^ g)) + 0xd807aa98 | 0;\n      h = g;\n      g = f;\n      f = e;\n      e = d + t | 0;\n      d = c;\n      c = b;\n      b = a;\n      a = t + (b & c ^ d & (b ^ c)) + (b >>> 2 ^ b >>> 13 ^ b >>> 22 ^ b << 30 ^ b << 19 ^ b << 10) | 0; // 9\n\n      t = w9 + h + (e >>> 6 ^ e >>> 11 ^ e >>> 25 ^ e << 26 ^ e << 21 ^ e << 7) + (g ^ e & (f ^ g)) + 0x12835b01 | 0;\n      h = g;\n      g = f;\n      f = e;\n      e = d + t | 0;\n      d = c;\n      c = b;\n      b = a;\n      a = t + (b & c ^ d & (b ^ c)) + (b >>> 2 ^ b >>> 13 ^ b >>> 22 ^ b << 30 ^ b << 19 ^ b << 10) | 0; // 10\n\n      t = w10 + h + (e >>> 6 ^ e >>> 11 ^ e >>> 25 ^ e << 26 ^ e << 21 ^ e << 7) + (g ^ e & (f ^ g)) + 0x243185be | 0;\n      h = g;\n      g = f;\n      f = e;\n      e = d + t | 0;\n      d = c;\n      c = b;\n      b = a;\n      a = t + (b & c ^ d & (b ^ c)) + (b >>> 2 ^ b >>> 13 ^ b >>> 22 ^ b << 30 ^ b << 19 ^ b << 10) | 0; // 11\n\n      t = w11 + h + (e >>> 6 ^ e >>> 11 ^ e >>> 25 ^ e << 26 ^ e << 21 ^ e << 7) + (g ^ e & (f ^ g)) + 0x550c7dc3 | 0;\n      h = g;\n      g = f;\n      f = e;\n      e = d + t | 0;\n      d = c;\n      c = b;\n      b = a;\n      a = t + (b & c ^ d & (b ^ c)) + (b >>> 2 ^ b >>> 13 ^ b >>> 22 ^ b << 30 ^ b << 19 ^ b << 10) | 0; // 12\n\n      t = w12 + h + (e >>> 6 ^ e >>> 11 ^ e >>> 25 ^ e << 26 ^ e << 21 ^ e << 7) + (g ^ e & (f ^ g)) + 0x72be5d74 | 0;\n      h = g;\n      g = f;\n      f = e;\n      e = d + t | 0;\n      d = c;\n      c = b;\n      b = a;\n      a = t + (b & c ^ d & (b ^ c)) + (b >>> 2 ^ b >>> 13 ^ b >>> 22 ^ b << 30 ^ b << 19 ^ b << 10) | 0; // 13\n\n      t = w13 + h + (e >>> 6 ^ e >>> 11 ^ e >>> 25 ^ e << 26 ^ e << 21 ^ e << 7) + (g ^ e & (f ^ g)) + 0x80deb1fe | 0;\n      h = g;\n      g = f;\n      f = e;\n      e = d + t | 0;\n      d = c;\n      c = b;\n      b = a;\n      a = t + (b & c ^ d & (b ^ c)) + (b >>> 2 ^ b >>> 13 ^ b >>> 22 ^ b << 30 ^ b << 19 ^ b << 10) | 0; // 14\n\n      t = w14 + h + (e >>> 6 ^ e >>> 11 ^ e >>> 25 ^ e << 26 ^ e << 21 ^ e << 7) + (g ^ e & (f ^ g)) + 0x9bdc06a7 | 0;\n      h = g;\n      g = f;\n      f = e;\n      e = d + t | 0;\n      d = c;\n      c = b;\n      b = a;\n      a = t + (b & c ^ d & (b ^ c)) + (b >>> 2 ^ b >>> 13 ^ b >>> 22 ^ b << 30 ^ b << 19 ^ b << 10) | 0; // 15\n\n      t = w15 + h + (e >>> 6 ^ e >>> 11 ^ e >>> 25 ^ e << 26 ^ e << 21 ^ e << 7) + (g ^ e & (f ^ g)) + 0xc19bf174 | 0;\n      h = g;\n      g = f;\n      f = e;\n      e = d + t | 0;\n      d = c;\n      c = b;\n      b = a;\n      a = t + (b & c ^ d & (b ^ c)) + (b >>> 2 ^ b >>> 13 ^ b >>> 22 ^ b << 30 ^ b << 19 ^ b << 10) | 0; // 16\n\n      w0 = t = (w1 >>> 7 ^ w1 >>> 18 ^ w1 >>> 3 ^ w1 << 25 ^ w1 << 14) + (w14 >>> 17 ^ w14 >>> 19 ^ w14 >>> 10 ^ w14 << 15 ^ w14 << 13) + w0 + w9 | 0;\n      t = t + h + (e >>> 6 ^ e >>> 11 ^ e >>> 25 ^ e << 26 ^ e << 21 ^ e << 7) + (g ^ e & (f ^ g)) + 0xe49b69c1 | 0;\n      h = g;\n      g = f;\n      f = e;\n      e = d + t | 0;\n      d = c;\n      c = b;\n      b = a;\n      a = t + (b & c ^ d & (b ^ c)) + (b >>> 2 ^ b >>> 13 ^ b >>> 22 ^ b << 30 ^ b << 19 ^ b << 10) | 0; // 17\n\n      w1 = t = (w2 >>> 7 ^ w2 >>> 18 ^ w2 >>> 3 ^ w2 << 25 ^ w2 << 14) + (w15 >>> 17 ^ w15 >>> 19 ^ w15 >>> 10 ^ w15 << 15 ^ w15 << 13) + w1 + w10 | 0;\n      t = t + h + (e >>> 6 ^ e >>> 11 ^ e >>> 25 ^ e << 26 ^ e << 21 ^ e << 7) + (g ^ e & (f ^ g)) + 0xefbe4786 | 0;\n      h = g;\n      g = f;\n      f = e;\n      e = d + t | 0;\n      d = c;\n      c = b;\n      b = a;\n      a = t + (b & c ^ d & (b ^ c)) + (b >>> 2 ^ b >>> 13 ^ b >>> 22 ^ b << 30 ^ b << 19 ^ b << 10) | 0; // 18\n\n      w2 = t = (w3 >>> 7 ^ w3 >>> 18 ^ w3 >>> 3 ^ w3 << 25 ^ w3 << 14) + (w0 >>> 17 ^ w0 >>> 19 ^ w0 >>> 10 ^ w0 << 15 ^ w0 << 13) + w2 + w11 | 0;\n      t = t + h + (e >>> 6 ^ e >>> 11 ^ e >>> 25 ^ e << 26 ^ e << 21 ^ e << 7) + (g ^ e & (f ^ g)) + 0x0fc19dc6 | 0;\n      h = g;\n      g = f;\n      f = e;\n      e = d + t | 0;\n      d = c;\n      c = b;\n      b = a;\n      a = t + (b & c ^ d & (b ^ c)) + (b >>> 2 ^ b >>> 13 ^ b >>> 22 ^ b << 30 ^ b << 19 ^ b << 10) | 0; // 19\n\n      w3 = t = (w4 >>> 7 ^ w4 >>> 18 ^ w4 >>> 3 ^ w4 << 25 ^ w4 << 14) + (w1 >>> 17 ^ w1 >>> 19 ^ w1 >>> 10 ^ w1 << 15 ^ w1 << 13) + w3 + w12 | 0;\n      t = t + h + (e >>> 6 ^ e >>> 11 ^ e >>> 25 ^ e << 26 ^ e << 21 ^ e << 7) + (g ^ e & (f ^ g)) + 0x240ca1cc | 0;\n      h = g;\n      g = f;\n      f = e;\n      e = d + t | 0;\n      d = c;\n      c = b;\n      b = a;\n      a = t + (b & c ^ d & (b ^ c)) + (b >>> 2 ^ b >>> 13 ^ b >>> 22 ^ b << 30 ^ b << 19 ^ b << 10) | 0; // 20\n\n      w4 = t = (w5 >>> 7 ^ w5 >>> 18 ^ w5 >>> 3 ^ w5 << 25 ^ w5 << 14) + (w2 >>> 17 ^ w2 >>> 19 ^ w2 >>> 10 ^ w2 << 15 ^ w2 << 13) + w4 + w13 | 0;\n      t = t + h + (e >>> 6 ^ e >>> 11 ^ e >>> 25 ^ e << 26 ^ e << 21 ^ e << 7) + (g ^ e & (f ^ g)) + 0x2de92c6f | 0;\n      h = g;\n      g = f;\n      f = e;\n      e = d + t | 0;\n      d = c;\n      c = b;\n      b = a;\n      a = t + (b & c ^ d & (b ^ c)) + (b >>> 2 ^ b >>> 13 ^ b >>> 22 ^ b << 30 ^ b << 19 ^ b << 10) | 0; // 21\n\n      w5 = t = (w6 >>> 7 ^ w6 >>> 18 ^ w6 >>> 3 ^ w6 << 25 ^ w6 << 14) + (w3 >>> 17 ^ w3 >>> 19 ^ w3 >>> 10 ^ w3 << 15 ^ w3 << 13) + w5 + w14 | 0;\n      t = t + h + (e >>> 6 ^ e >>> 11 ^ e >>> 25 ^ e << 26 ^ e << 21 ^ e << 7) + (g ^ e & (f ^ g)) + 0x4a7484aa | 0;\n      h = g;\n      g = f;\n      f = e;\n      e = d + t | 0;\n      d = c;\n      c = b;\n      b = a;\n      a = t + (b & c ^ d & (b ^ c)) + (b >>> 2 ^ b >>> 13 ^ b >>> 22 ^ b << 30 ^ b << 19 ^ b << 10) | 0; // 22\n\n      w6 = t = (w7 >>> 7 ^ w7 >>> 18 ^ w7 >>> 3 ^ w7 << 25 ^ w7 << 14) + (w4 >>> 17 ^ w4 >>> 19 ^ w4 >>> 10 ^ w4 << 15 ^ w4 << 13) + w6 + w15 | 0;\n      t = t + h + (e >>> 6 ^ e >>> 11 ^ e >>> 25 ^ e << 26 ^ e << 21 ^ e << 7) + (g ^ e & (f ^ g)) + 0x5cb0a9dc | 0;\n      h = g;\n      g = f;\n      f = e;\n      e = d + t | 0;\n      d = c;\n      c = b;\n      b = a;\n      a = t + (b & c ^ d & (b ^ c)) + (b >>> 2 ^ b >>> 13 ^ b >>> 22 ^ b << 30 ^ b << 19 ^ b << 10) | 0; // 23\n\n      w7 = t = (w8 >>> 7 ^ w8 >>> 18 ^ w8 >>> 3 ^ w8 << 25 ^ w8 << 14) + (w5 >>> 17 ^ w5 >>> 19 ^ w5 >>> 10 ^ w5 << 15 ^ w5 << 13) + w7 + w0 | 0;\n      t = t + h + (e >>> 6 ^ e >>> 11 ^ e >>> 25 ^ e << 26 ^ e << 21 ^ e << 7) + (g ^ e & (f ^ g)) + 0x76f988da | 0;\n      h = g;\n      g = f;\n      f = e;\n      e = d + t | 0;\n      d = c;\n      c = b;\n      b = a;\n      a = t + (b & c ^ d & (b ^ c)) + (b >>> 2 ^ b >>> 13 ^ b >>> 22 ^ b << 30 ^ b << 19 ^ b << 10) | 0; // 24\n\n      w8 = t = (w9 >>> 7 ^ w9 >>> 18 ^ w9 >>> 3 ^ w9 << 25 ^ w9 << 14) + (w6 >>> 17 ^ w6 >>> 19 ^ w6 >>> 10 ^ w6 << 15 ^ w6 << 13) + w8 + w1 | 0;\n      t = t + h + (e >>> 6 ^ e >>> 11 ^ e >>> 25 ^ e << 26 ^ e << 21 ^ e << 7) + (g ^ e & (f ^ g)) + 0x983e5152 | 0;\n      h = g;\n      g = f;\n      f = e;\n      e = d + t | 0;\n      d = c;\n      c = b;\n      b = a;\n      a = t + (b & c ^ d & (b ^ c)) + (b >>> 2 ^ b >>> 13 ^ b >>> 22 ^ b << 30 ^ b << 19 ^ b << 10) | 0; // 25\n\n      w9 = t = (w10 >>> 7 ^ w10 >>> 18 ^ w10 >>> 3 ^ w10 << 25 ^ w10 << 14) + (w7 >>> 17 ^ w7 >>> 19 ^ w7 >>> 10 ^ w7 << 15 ^ w7 << 13) + w9 + w2 | 0;\n      t = t + h + (e >>> 6 ^ e >>> 11 ^ e >>> 25 ^ e << 26 ^ e << 21 ^ e << 7) + (g ^ e & (f ^ g)) + 0xa831c66d | 0;\n      h = g;\n      g = f;\n      f = e;\n      e = d + t | 0;\n      d = c;\n      c = b;\n      b = a;\n      a = t + (b & c ^ d & (b ^ c)) + (b >>> 2 ^ b >>> 13 ^ b >>> 22 ^ b << 30 ^ b << 19 ^ b << 10) | 0; // 26\n\n      w10 = t = (w11 >>> 7 ^ w11 >>> 18 ^ w11 >>> 3 ^ w11 << 25 ^ w11 << 14) + (w8 >>> 17 ^ w8 >>> 19 ^ w8 >>> 10 ^ w8 << 15 ^ w8 << 13) + w10 + w3 | 0;\n      t = t + h + (e >>> 6 ^ e >>> 11 ^ e >>> 25 ^ e << 26 ^ e << 21 ^ e << 7) + (g ^ e & (f ^ g)) + 0xb00327c8 | 0;\n      h = g;\n      g = f;\n      f = e;\n      e = d + t | 0;\n      d = c;\n      c = b;\n      b = a;\n      a = t + (b & c ^ d & (b ^ c)) + (b >>> 2 ^ b >>> 13 ^ b >>> 22 ^ b << 30 ^ b << 19 ^ b << 10) | 0; // 27\n\n      w11 = t = (w12 >>> 7 ^ w12 >>> 18 ^ w12 >>> 3 ^ w12 << 25 ^ w12 << 14) + (w9 >>> 17 ^ w9 >>> 19 ^ w9 >>> 10 ^ w9 << 15 ^ w9 << 13) + w11 + w4 | 0;\n      t = t + h + (e >>> 6 ^ e >>> 11 ^ e >>> 25 ^ e << 26 ^ e << 21 ^ e << 7) + (g ^ e & (f ^ g)) + 0xbf597fc7 | 0;\n      h = g;\n      g = f;\n      f = e;\n      e = d + t | 0;\n      d = c;\n      c = b;\n      b = a;\n      a = t + (b & c ^ d & (b ^ c)) + (b >>> 2 ^ b >>> 13 ^ b >>> 22 ^ b << 30 ^ b << 19 ^ b << 10) | 0; // 28\n\n      w12 = t = (w13 >>> 7 ^ w13 >>> 18 ^ w13 >>> 3 ^ w13 << 25 ^ w13 << 14) + (w10 >>> 17 ^ w10 >>> 19 ^ w10 >>> 10 ^ w10 << 15 ^ w10 << 13) + w12 + w5 | 0;\n      t = t + h + (e >>> 6 ^ e >>> 11 ^ e >>> 25 ^ e << 26 ^ e << 21 ^ e << 7) + (g ^ e & (f ^ g)) + 0xc6e00bf3 | 0;\n      h = g;\n      g = f;\n      f = e;\n      e = d + t | 0;\n      d = c;\n      c = b;\n      b = a;\n      a = t + (b & c ^ d & (b ^ c)) + (b >>> 2 ^ b >>> 13 ^ b >>> 22 ^ b << 30 ^ b << 19 ^ b << 10) | 0; // 29\n\n      w13 = t = (w14 >>> 7 ^ w14 >>> 18 ^ w14 >>> 3 ^ w14 << 25 ^ w14 << 14) + (w11 >>> 17 ^ w11 >>> 19 ^ w11 >>> 10 ^ w11 << 15 ^ w11 << 13) + w13 + w6 | 0;\n      t = t + h + (e >>> 6 ^ e >>> 11 ^ e >>> 25 ^ e << 26 ^ e << 21 ^ e << 7) + (g ^ e & (f ^ g)) + 0xd5a79147 | 0;\n      h = g;\n      g = f;\n      f = e;\n      e = d + t | 0;\n      d = c;\n      c = b;\n      b = a;\n      a = t + (b & c ^ d & (b ^ c)) + (b >>> 2 ^ b >>> 13 ^ b >>> 22 ^ b << 30 ^ b << 19 ^ b << 10) | 0; // 30\n\n      w14 = t = (w15 >>> 7 ^ w15 >>> 18 ^ w15 >>> 3 ^ w15 << 25 ^ w15 << 14) + (w12 >>> 17 ^ w12 >>> 19 ^ w12 >>> 10 ^ w12 << 15 ^ w12 << 13) + w14 + w7 | 0;\n      t = t + h + (e >>> 6 ^ e >>> 11 ^ e >>> 25 ^ e << 26 ^ e << 21 ^ e << 7) + (g ^ e & (f ^ g)) + 0x06ca6351 | 0;\n      h = g;\n      g = f;\n      f = e;\n      e = d + t | 0;\n      d = c;\n      c = b;\n      b = a;\n      a = t + (b & c ^ d & (b ^ c)) + (b >>> 2 ^ b >>> 13 ^ b >>> 22 ^ b << 30 ^ b << 19 ^ b << 10) | 0; // 31\n\n      w15 = t = (w0 >>> 7 ^ w0 >>> 18 ^ w0 >>> 3 ^ w0 << 25 ^ w0 << 14) + (w13 >>> 17 ^ w13 >>> 19 ^ w13 >>> 10 ^ w13 << 15 ^ w13 << 13) + w15 + w8 | 0;\n      t = t + h + (e >>> 6 ^ e >>> 11 ^ e >>> 25 ^ e << 26 ^ e << 21 ^ e << 7) + (g ^ e & (f ^ g)) + 0x14292967 | 0;\n      h = g;\n      g = f;\n      f = e;\n      e = d + t | 0;\n      d = c;\n      c = b;\n      b = a;\n      a = t + (b & c ^ d & (b ^ c)) + (b >>> 2 ^ b >>> 13 ^ b >>> 22 ^ b << 30 ^ b << 19 ^ b << 10) | 0; // 32\n\n      w0 = t = (w1 >>> 7 ^ w1 >>> 18 ^ w1 >>> 3 ^ w1 << 25 ^ w1 << 14) + (w14 >>> 17 ^ w14 >>> 19 ^ w14 >>> 10 ^ w14 << 15 ^ w14 << 13) + w0 + w9 | 0;\n      t = t + h + (e >>> 6 ^ e >>> 11 ^ e >>> 25 ^ e << 26 ^ e << 21 ^ e << 7) + (g ^ e & (f ^ g)) + 0x27b70a85 | 0;\n      h = g;\n      g = f;\n      f = e;\n      e = d + t | 0;\n      d = c;\n      c = b;\n      b = a;\n      a = t + (b & c ^ d & (b ^ c)) + (b >>> 2 ^ b >>> 13 ^ b >>> 22 ^ b << 30 ^ b << 19 ^ b << 10) | 0; // 33\n\n      w1 = t = (w2 >>> 7 ^ w2 >>> 18 ^ w2 >>> 3 ^ w2 << 25 ^ w2 << 14) + (w15 >>> 17 ^ w15 >>> 19 ^ w15 >>> 10 ^ w15 << 15 ^ w15 << 13) + w1 + w10 | 0;\n      t = t + h + (e >>> 6 ^ e >>> 11 ^ e >>> 25 ^ e << 26 ^ e << 21 ^ e << 7) + (g ^ e & (f ^ g)) + 0x2e1b2138 | 0;\n      h = g;\n      g = f;\n      f = e;\n      e = d + t | 0;\n      d = c;\n      c = b;\n      b = a;\n      a = t + (b & c ^ d & (b ^ c)) + (b >>> 2 ^ b >>> 13 ^ b >>> 22 ^ b << 30 ^ b << 19 ^ b << 10) | 0; // 34\n\n      w2 = t = (w3 >>> 7 ^ w3 >>> 18 ^ w3 >>> 3 ^ w3 << 25 ^ w3 << 14) + (w0 >>> 17 ^ w0 >>> 19 ^ w0 >>> 10 ^ w0 << 15 ^ w0 << 13) + w2 + w11 | 0;\n      t = t + h + (e >>> 6 ^ e >>> 11 ^ e >>> 25 ^ e << 26 ^ e << 21 ^ e << 7) + (g ^ e & (f ^ g)) + 0x4d2c6dfc | 0;\n      h = g;\n      g = f;\n      f = e;\n      e = d + t | 0;\n      d = c;\n      c = b;\n      b = a;\n      a = t + (b & c ^ d & (b ^ c)) + (b >>> 2 ^ b >>> 13 ^ b >>> 22 ^ b << 30 ^ b << 19 ^ b << 10) | 0; // 35\n\n      w3 = t = (w4 >>> 7 ^ w4 >>> 18 ^ w4 >>> 3 ^ w4 << 25 ^ w4 << 14) + (w1 >>> 17 ^ w1 >>> 19 ^ w1 >>> 10 ^ w1 << 15 ^ w1 << 13) + w3 + w12 | 0;\n      t = t + h + (e >>> 6 ^ e >>> 11 ^ e >>> 25 ^ e << 26 ^ e << 21 ^ e << 7) + (g ^ e & (f ^ g)) + 0x53380d13 | 0;\n      h = g;\n      g = f;\n      f = e;\n      e = d + t | 0;\n      d = c;\n      c = b;\n      b = a;\n      a = t + (b & c ^ d & (b ^ c)) + (b >>> 2 ^ b >>> 13 ^ b >>> 22 ^ b << 30 ^ b << 19 ^ b << 10) | 0; // 36\n\n      w4 = t = (w5 >>> 7 ^ w5 >>> 18 ^ w5 >>> 3 ^ w5 << 25 ^ w5 << 14) + (w2 >>> 17 ^ w2 >>> 19 ^ w2 >>> 10 ^ w2 << 15 ^ w2 << 13) + w4 + w13 | 0;\n      t = t + h + (e >>> 6 ^ e >>> 11 ^ e >>> 25 ^ e << 26 ^ e << 21 ^ e << 7) + (g ^ e & (f ^ g)) + 0x650a7354 | 0;\n      h = g;\n      g = f;\n      f = e;\n      e = d + t | 0;\n      d = c;\n      c = b;\n      b = a;\n      a = t + (b & c ^ d & (b ^ c)) + (b >>> 2 ^ b >>> 13 ^ b >>> 22 ^ b << 30 ^ b << 19 ^ b << 10) | 0; // 37\n\n      w5 = t = (w6 >>> 7 ^ w6 >>> 18 ^ w6 >>> 3 ^ w6 << 25 ^ w6 << 14) + (w3 >>> 17 ^ w3 >>> 19 ^ w3 >>> 10 ^ w3 << 15 ^ w3 << 13) + w5 + w14 | 0;\n      t = t + h + (e >>> 6 ^ e >>> 11 ^ e >>> 25 ^ e << 26 ^ e << 21 ^ e << 7) + (g ^ e & (f ^ g)) + 0x766a0abb | 0;\n      h = g;\n      g = f;\n      f = e;\n      e = d + t | 0;\n      d = c;\n      c = b;\n      b = a;\n      a = t + (b & c ^ d & (b ^ c)) + (b >>> 2 ^ b >>> 13 ^ b >>> 22 ^ b << 30 ^ b << 19 ^ b << 10) | 0; // 38\n\n      w6 = t = (w7 >>> 7 ^ w7 >>> 18 ^ w7 >>> 3 ^ w7 << 25 ^ w7 << 14) + (w4 >>> 17 ^ w4 >>> 19 ^ w4 >>> 10 ^ w4 << 15 ^ w4 << 13) + w6 + w15 | 0;\n      t = t + h + (e >>> 6 ^ e >>> 11 ^ e >>> 25 ^ e << 26 ^ e << 21 ^ e << 7) + (g ^ e & (f ^ g)) + 0x81c2c92e | 0;\n      h = g;\n      g = f;\n      f = e;\n      e = d + t | 0;\n      d = c;\n      c = b;\n      b = a;\n      a = t + (b & c ^ d & (b ^ c)) + (b >>> 2 ^ b >>> 13 ^ b >>> 22 ^ b << 30 ^ b << 19 ^ b << 10) | 0; // 39\n\n      w7 = t = (w8 >>> 7 ^ w8 >>> 18 ^ w8 >>> 3 ^ w8 << 25 ^ w8 << 14) + (w5 >>> 17 ^ w5 >>> 19 ^ w5 >>> 10 ^ w5 << 15 ^ w5 << 13) + w7 + w0 | 0;\n      t = t + h + (e >>> 6 ^ e >>> 11 ^ e >>> 25 ^ e << 26 ^ e << 21 ^ e << 7) + (g ^ e & (f ^ g)) + 0x92722c85 | 0;\n      h = g;\n      g = f;\n      f = e;\n      e = d + t | 0;\n      d = c;\n      c = b;\n      b = a;\n      a = t + (b & c ^ d & (b ^ c)) + (b >>> 2 ^ b >>> 13 ^ b >>> 22 ^ b << 30 ^ b << 19 ^ b << 10) | 0; // 40\n\n      w8 = t = (w9 >>> 7 ^ w9 >>> 18 ^ w9 >>> 3 ^ w9 << 25 ^ w9 << 14) + (w6 >>> 17 ^ w6 >>> 19 ^ w6 >>> 10 ^ w6 << 15 ^ w6 << 13) + w8 + w1 | 0;\n      t = t + h + (e >>> 6 ^ e >>> 11 ^ e >>> 25 ^ e << 26 ^ e << 21 ^ e << 7) + (g ^ e & (f ^ g)) + 0xa2bfe8a1 | 0;\n      h = g;\n      g = f;\n      f = e;\n      e = d + t | 0;\n      d = c;\n      c = b;\n      b = a;\n      a = t + (b & c ^ d & (b ^ c)) + (b >>> 2 ^ b >>> 13 ^ b >>> 22 ^ b << 30 ^ b << 19 ^ b << 10) | 0; // 41\n\n      w9 = t = (w10 >>> 7 ^ w10 >>> 18 ^ w10 >>> 3 ^ w10 << 25 ^ w10 << 14) + (w7 >>> 17 ^ w7 >>> 19 ^ w7 >>> 10 ^ w7 << 15 ^ w7 << 13) + w9 + w2 | 0;\n      t = t + h + (e >>> 6 ^ e >>> 11 ^ e >>> 25 ^ e << 26 ^ e << 21 ^ e << 7) + (g ^ e & (f ^ g)) + 0xa81a664b | 0;\n      h = g;\n      g = f;\n      f = e;\n      e = d + t | 0;\n      d = c;\n      c = b;\n      b = a;\n      a = t + (b & c ^ d & (b ^ c)) + (b >>> 2 ^ b >>> 13 ^ b >>> 22 ^ b << 30 ^ b << 19 ^ b << 10) | 0; // 42\n\n      w10 = t = (w11 >>> 7 ^ w11 >>> 18 ^ w11 >>> 3 ^ w11 << 25 ^ w11 << 14) + (w8 >>> 17 ^ w8 >>> 19 ^ w8 >>> 10 ^ w8 << 15 ^ w8 << 13) + w10 + w3 | 0;\n      t = t + h + (e >>> 6 ^ e >>> 11 ^ e >>> 25 ^ e << 26 ^ e << 21 ^ e << 7) + (g ^ e & (f ^ g)) + 0xc24b8b70 | 0;\n      h = g;\n      g = f;\n      f = e;\n      e = d + t | 0;\n      d = c;\n      c = b;\n      b = a;\n      a = t + (b & c ^ d & (b ^ c)) + (b >>> 2 ^ b >>> 13 ^ b >>> 22 ^ b << 30 ^ b << 19 ^ b << 10) | 0; // 43\n\n      w11 = t = (w12 >>> 7 ^ w12 >>> 18 ^ w12 >>> 3 ^ w12 << 25 ^ w12 << 14) + (w9 >>> 17 ^ w9 >>> 19 ^ w9 >>> 10 ^ w9 << 15 ^ w9 << 13) + w11 + w4 | 0;\n      t = t + h + (e >>> 6 ^ e >>> 11 ^ e >>> 25 ^ e << 26 ^ e << 21 ^ e << 7) + (g ^ e & (f ^ g)) + 0xc76c51a3 | 0;\n      h = g;\n      g = f;\n      f = e;\n      e = d + t | 0;\n      d = c;\n      c = b;\n      b = a;\n      a = t + (b & c ^ d & (b ^ c)) + (b >>> 2 ^ b >>> 13 ^ b >>> 22 ^ b << 30 ^ b << 19 ^ b << 10) | 0; // 44\n\n      w12 = t = (w13 >>> 7 ^ w13 >>> 18 ^ w13 >>> 3 ^ w13 << 25 ^ w13 << 14) + (w10 >>> 17 ^ w10 >>> 19 ^ w10 >>> 10 ^ w10 << 15 ^ w10 << 13) + w12 + w5 | 0;\n      t = t + h + (e >>> 6 ^ e >>> 11 ^ e >>> 25 ^ e << 26 ^ e << 21 ^ e << 7) + (g ^ e & (f ^ g)) + 0xd192e819 | 0;\n      h = g;\n      g = f;\n      f = e;\n      e = d + t | 0;\n      d = c;\n      c = b;\n      b = a;\n      a = t + (b & c ^ d & (b ^ c)) + (b >>> 2 ^ b >>> 13 ^ b >>> 22 ^ b << 30 ^ b << 19 ^ b << 10) | 0; // 45\n\n      w13 = t = (w14 >>> 7 ^ w14 >>> 18 ^ w14 >>> 3 ^ w14 << 25 ^ w14 << 14) + (w11 >>> 17 ^ w11 >>> 19 ^ w11 >>> 10 ^ w11 << 15 ^ w11 << 13) + w13 + w6 | 0;\n      t = t + h + (e >>> 6 ^ e >>> 11 ^ e >>> 25 ^ e << 26 ^ e << 21 ^ e << 7) + (g ^ e & (f ^ g)) + 0xd6990624 | 0;\n      h = g;\n      g = f;\n      f = e;\n      e = d + t | 0;\n      d = c;\n      c = b;\n      b = a;\n      a = t + (b & c ^ d & (b ^ c)) + (b >>> 2 ^ b >>> 13 ^ b >>> 22 ^ b << 30 ^ b << 19 ^ b << 10) | 0; // 46\n\n      w14 = t = (w15 >>> 7 ^ w15 >>> 18 ^ w15 >>> 3 ^ w15 << 25 ^ w15 << 14) + (w12 >>> 17 ^ w12 >>> 19 ^ w12 >>> 10 ^ w12 << 15 ^ w12 << 13) + w14 + w7 | 0;\n      t = t + h + (e >>> 6 ^ e >>> 11 ^ e >>> 25 ^ e << 26 ^ e << 21 ^ e << 7) + (g ^ e & (f ^ g)) + 0xf40e3585 | 0;\n      h = g;\n      g = f;\n      f = e;\n      e = d + t | 0;\n      d = c;\n      c = b;\n      b = a;\n      a = t + (b & c ^ d & (b ^ c)) + (b >>> 2 ^ b >>> 13 ^ b >>> 22 ^ b << 30 ^ b << 19 ^ b << 10) | 0; // 47\n\n      w15 = t = (w0 >>> 7 ^ w0 >>> 18 ^ w0 >>> 3 ^ w0 << 25 ^ w0 << 14) + (w13 >>> 17 ^ w13 >>> 19 ^ w13 >>> 10 ^ w13 << 15 ^ w13 << 13) + w15 + w8 | 0;\n      t = t + h + (e >>> 6 ^ e >>> 11 ^ e >>> 25 ^ e << 26 ^ e << 21 ^ e << 7) + (g ^ e & (f ^ g)) + 0x106aa070 | 0;\n      h = g;\n      g = f;\n      f = e;\n      e = d + t | 0;\n      d = c;\n      c = b;\n      b = a;\n      a = t + (b & c ^ d & (b ^ c)) + (b >>> 2 ^ b >>> 13 ^ b >>> 22 ^ b << 30 ^ b << 19 ^ b << 10) | 0; // 48\n\n      w0 = t = (w1 >>> 7 ^ w1 >>> 18 ^ w1 >>> 3 ^ w1 << 25 ^ w1 << 14) + (w14 >>> 17 ^ w14 >>> 19 ^ w14 >>> 10 ^ w14 << 15 ^ w14 << 13) + w0 + w9 | 0;\n      t = t + h + (e >>> 6 ^ e >>> 11 ^ e >>> 25 ^ e << 26 ^ e << 21 ^ e << 7) + (g ^ e & (f ^ g)) + 0x19a4c116 | 0;\n      h = g;\n      g = f;\n      f = e;\n      e = d + t | 0;\n      d = c;\n      c = b;\n      b = a;\n      a = t + (b & c ^ d & (b ^ c)) + (b >>> 2 ^ b >>> 13 ^ b >>> 22 ^ b << 30 ^ b << 19 ^ b << 10) | 0; // 49\n\n      w1 = t = (w2 >>> 7 ^ w2 >>> 18 ^ w2 >>> 3 ^ w2 << 25 ^ w2 << 14) + (w15 >>> 17 ^ w15 >>> 19 ^ w15 >>> 10 ^ w15 << 15 ^ w15 << 13) + w1 + w10 | 0;\n      t = t + h + (e >>> 6 ^ e >>> 11 ^ e >>> 25 ^ e << 26 ^ e << 21 ^ e << 7) + (g ^ e & (f ^ g)) + 0x1e376c08 | 0;\n      h = g;\n      g = f;\n      f = e;\n      e = d + t | 0;\n      d = c;\n      c = b;\n      b = a;\n      a = t + (b & c ^ d & (b ^ c)) + (b >>> 2 ^ b >>> 13 ^ b >>> 22 ^ b << 30 ^ b << 19 ^ b << 10) | 0; // 50\n\n      w2 = t = (w3 >>> 7 ^ w3 >>> 18 ^ w3 >>> 3 ^ w3 << 25 ^ w3 << 14) + (w0 >>> 17 ^ w0 >>> 19 ^ w0 >>> 10 ^ w0 << 15 ^ w0 << 13) + w2 + w11 | 0;\n      t = t + h + (e >>> 6 ^ e >>> 11 ^ e >>> 25 ^ e << 26 ^ e << 21 ^ e << 7) + (g ^ e & (f ^ g)) + 0x2748774c | 0;\n      h = g;\n      g = f;\n      f = e;\n      e = d + t | 0;\n      d = c;\n      c = b;\n      b = a;\n      a = t + (b & c ^ d & (b ^ c)) + (b >>> 2 ^ b >>> 13 ^ b >>> 22 ^ b << 30 ^ b << 19 ^ b << 10) | 0; // 51\n\n      w3 = t = (w4 >>> 7 ^ w4 >>> 18 ^ w4 >>> 3 ^ w4 << 25 ^ w4 << 14) + (w1 >>> 17 ^ w1 >>> 19 ^ w1 >>> 10 ^ w1 << 15 ^ w1 << 13) + w3 + w12 | 0;\n      t = t + h + (e >>> 6 ^ e >>> 11 ^ e >>> 25 ^ e << 26 ^ e << 21 ^ e << 7) + (g ^ e & (f ^ g)) + 0x34b0bcb5 | 0;\n      h = g;\n      g = f;\n      f = e;\n      e = d + t | 0;\n      d = c;\n      c = b;\n      b = a;\n      a = t + (b & c ^ d & (b ^ c)) + (b >>> 2 ^ b >>> 13 ^ b >>> 22 ^ b << 30 ^ b << 19 ^ b << 10) | 0; // 52\n\n      w4 = t = (w5 >>> 7 ^ w5 >>> 18 ^ w5 >>> 3 ^ w5 << 25 ^ w5 << 14) + (w2 >>> 17 ^ w2 >>> 19 ^ w2 >>> 10 ^ w2 << 15 ^ w2 << 13) + w4 + w13 | 0;\n      t = t + h + (e >>> 6 ^ e >>> 11 ^ e >>> 25 ^ e << 26 ^ e << 21 ^ e << 7) + (g ^ e & (f ^ g)) + 0x391c0cb3 | 0;\n      h = g;\n      g = f;\n      f = e;\n      e = d + t | 0;\n      d = c;\n      c = b;\n      b = a;\n      a = t + (b & c ^ d & (b ^ c)) + (b >>> 2 ^ b >>> 13 ^ b >>> 22 ^ b << 30 ^ b << 19 ^ b << 10) | 0; // 53\n\n      w5 = t = (w6 >>> 7 ^ w6 >>> 18 ^ w6 >>> 3 ^ w6 << 25 ^ w6 << 14) + (w3 >>> 17 ^ w3 >>> 19 ^ w3 >>> 10 ^ w3 << 15 ^ w3 << 13) + w5 + w14 | 0;\n      t = t + h + (e >>> 6 ^ e >>> 11 ^ e >>> 25 ^ e << 26 ^ e << 21 ^ e << 7) + (g ^ e & (f ^ g)) + 0x4ed8aa4a | 0;\n      h = g;\n      g = f;\n      f = e;\n      e = d + t | 0;\n      d = c;\n      c = b;\n      b = a;\n      a = t + (b & c ^ d & (b ^ c)) + (b >>> 2 ^ b >>> 13 ^ b >>> 22 ^ b << 30 ^ b << 19 ^ b << 10) | 0; // 54\n\n      w6 = t = (w7 >>> 7 ^ w7 >>> 18 ^ w7 >>> 3 ^ w7 << 25 ^ w7 << 14) + (w4 >>> 17 ^ w4 >>> 19 ^ w4 >>> 10 ^ w4 << 15 ^ w4 << 13) + w6 + w15 | 0;\n      t = t + h + (e >>> 6 ^ e >>> 11 ^ e >>> 25 ^ e << 26 ^ e << 21 ^ e << 7) + (g ^ e & (f ^ g)) + 0x5b9cca4f | 0;\n      h = g;\n      g = f;\n      f = e;\n      e = d + t | 0;\n      d = c;\n      c = b;\n      b = a;\n      a = t + (b & c ^ d & (b ^ c)) + (b >>> 2 ^ b >>> 13 ^ b >>> 22 ^ b << 30 ^ b << 19 ^ b << 10) | 0; // 55\n\n      w7 = t = (w8 >>> 7 ^ w8 >>> 18 ^ w8 >>> 3 ^ w8 << 25 ^ w8 << 14) + (w5 >>> 17 ^ w5 >>> 19 ^ w5 >>> 10 ^ w5 << 15 ^ w5 << 13) + w7 + w0 | 0;\n      t = t + h + (e >>> 6 ^ e >>> 11 ^ e >>> 25 ^ e << 26 ^ e << 21 ^ e << 7) + (g ^ e & (f ^ g)) + 0x682e6ff3 | 0;\n      h = g;\n      g = f;\n      f = e;\n      e = d + t | 0;\n      d = c;\n      c = b;\n      b = a;\n      a = t + (b & c ^ d & (b ^ c)) + (b >>> 2 ^ b >>> 13 ^ b >>> 22 ^ b << 30 ^ b << 19 ^ b << 10) | 0; // 56\n\n      w8 = t = (w9 >>> 7 ^ w9 >>> 18 ^ w9 >>> 3 ^ w9 << 25 ^ w9 << 14) + (w6 >>> 17 ^ w6 >>> 19 ^ w6 >>> 10 ^ w6 << 15 ^ w6 << 13) + w8 + w1 | 0;\n      t = t + h + (e >>> 6 ^ e >>> 11 ^ e >>> 25 ^ e << 26 ^ e << 21 ^ e << 7) + (g ^ e & (f ^ g)) + 0x748f82ee | 0;\n      h = g;\n      g = f;\n      f = e;\n      e = d + t | 0;\n      d = c;\n      c = b;\n      b = a;\n      a = t + (b & c ^ d & (b ^ c)) + (b >>> 2 ^ b >>> 13 ^ b >>> 22 ^ b << 30 ^ b << 19 ^ b << 10) | 0; // 57\n\n      w9 = t = (w10 >>> 7 ^ w10 >>> 18 ^ w10 >>> 3 ^ w10 << 25 ^ w10 << 14) + (w7 >>> 17 ^ w7 >>> 19 ^ w7 >>> 10 ^ w7 << 15 ^ w7 << 13) + w9 + w2 | 0;\n      t = t + h + (e >>> 6 ^ e >>> 11 ^ e >>> 25 ^ e << 26 ^ e << 21 ^ e << 7) + (g ^ e & (f ^ g)) + 0x78a5636f | 0;\n      h = g;\n      g = f;\n      f = e;\n      e = d + t | 0;\n      d = c;\n      c = b;\n      b = a;\n      a = t + (b & c ^ d & (b ^ c)) + (b >>> 2 ^ b >>> 13 ^ b >>> 22 ^ b << 30 ^ b << 19 ^ b << 10) | 0; // 58\n\n      w10 = t = (w11 >>> 7 ^ w11 >>> 18 ^ w11 >>> 3 ^ w11 << 25 ^ w11 << 14) + (w8 >>> 17 ^ w8 >>> 19 ^ w8 >>> 10 ^ w8 << 15 ^ w8 << 13) + w10 + w3 | 0;\n      t = t + h + (e >>> 6 ^ e >>> 11 ^ e >>> 25 ^ e << 26 ^ e << 21 ^ e << 7) + (g ^ e & (f ^ g)) + 0x84c87814 | 0;\n      h = g;\n      g = f;\n      f = e;\n      e = d + t | 0;\n      d = c;\n      c = b;\n      b = a;\n      a = t + (b & c ^ d & (b ^ c)) + (b >>> 2 ^ b >>> 13 ^ b >>> 22 ^ b << 30 ^ b << 19 ^ b << 10) | 0; // 59\n\n      w11 = t = (w12 >>> 7 ^ w12 >>> 18 ^ w12 >>> 3 ^ w12 << 25 ^ w12 << 14) + (w9 >>> 17 ^ w9 >>> 19 ^ w9 >>> 10 ^ w9 << 15 ^ w9 << 13) + w11 + w4 | 0;\n      t = t + h + (e >>> 6 ^ e >>> 11 ^ e >>> 25 ^ e << 26 ^ e << 21 ^ e << 7) + (g ^ e & (f ^ g)) + 0x8cc70208 | 0;\n      h = g;\n      g = f;\n      f = e;\n      e = d + t | 0;\n      d = c;\n      c = b;\n      b = a;\n      a = t + (b & c ^ d & (b ^ c)) + (b >>> 2 ^ b >>> 13 ^ b >>> 22 ^ b << 30 ^ b << 19 ^ b << 10) | 0; // 60\n\n      w12 = t = (w13 >>> 7 ^ w13 >>> 18 ^ w13 >>> 3 ^ w13 << 25 ^ w13 << 14) + (w10 >>> 17 ^ w10 >>> 19 ^ w10 >>> 10 ^ w10 << 15 ^ w10 << 13) + w12 + w5 | 0;\n      t = t + h + (e >>> 6 ^ e >>> 11 ^ e >>> 25 ^ e << 26 ^ e << 21 ^ e << 7) + (g ^ e & (f ^ g)) + 0x90befffa | 0;\n      h = g;\n      g = f;\n      f = e;\n      e = d + t | 0;\n      d = c;\n      c = b;\n      b = a;\n      a = t + (b & c ^ d & (b ^ c)) + (b >>> 2 ^ b >>> 13 ^ b >>> 22 ^ b << 30 ^ b << 19 ^ b << 10) | 0; // 61\n\n      w13 = t = (w14 >>> 7 ^ w14 >>> 18 ^ w14 >>> 3 ^ w14 << 25 ^ w14 << 14) + (w11 >>> 17 ^ w11 >>> 19 ^ w11 >>> 10 ^ w11 << 15 ^ w11 << 13) + w13 + w6 | 0;\n      t = t + h + (e >>> 6 ^ e >>> 11 ^ e >>> 25 ^ e << 26 ^ e << 21 ^ e << 7) + (g ^ e & (f ^ g)) + 0xa4506ceb | 0;\n      h = g;\n      g = f;\n      f = e;\n      e = d + t | 0;\n      d = c;\n      c = b;\n      b = a;\n      a = t + (b & c ^ d & (b ^ c)) + (b >>> 2 ^ b >>> 13 ^ b >>> 22 ^ b << 30 ^ b << 19 ^ b << 10) | 0; // 62\n\n      w14 = t = (w15 >>> 7 ^ w15 >>> 18 ^ w15 >>> 3 ^ w15 << 25 ^ w15 << 14) + (w12 >>> 17 ^ w12 >>> 19 ^ w12 >>> 10 ^ w12 << 15 ^ w12 << 13) + w14 + w7 | 0;\n      t = t + h + (e >>> 6 ^ e >>> 11 ^ e >>> 25 ^ e << 26 ^ e << 21 ^ e << 7) + (g ^ e & (f ^ g)) + 0xbef9a3f7 | 0;\n      h = g;\n      g = f;\n      f = e;\n      e = d + t | 0;\n      d = c;\n      c = b;\n      b = a;\n      a = t + (b & c ^ d & (b ^ c)) + (b >>> 2 ^ b >>> 13 ^ b >>> 22 ^ b << 30 ^ b << 19 ^ b << 10) | 0; // 63\n\n      w15 = t = (w0 >>> 7 ^ w0 >>> 18 ^ w0 >>> 3 ^ w0 << 25 ^ w0 << 14) + (w13 >>> 17 ^ w13 >>> 19 ^ w13 >>> 10 ^ w13 << 15 ^ w13 << 13) + w15 + w8 | 0;\n      t = t + h + (e >>> 6 ^ e >>> 11 ^ e >>> 25 ^ e << 26 ^ e << 21 ^ e << 7) + (g ^ e & (f ^ g)) + 0xc67178f2 | 0;\n      h = g;\n      g = f;\n      f = e;\n      e = d + t | 0;\n      d = c;\n      c = b;\n      b = a;\n      a = t + (b & c ^ d & (b ^ c)) + (b >>> 2 ^ b >>> 13 ^ b >>> 22 ^ b << 30 ^ b << 19 ^ b << 10) | 0;\n      H0 = H0 + a | 0;\n      H1 = H1 + b | 0;\n      H2 = H2 + c | 0;\n      H3 = H3 + d | 0;\n      H4 = H4 + e | 0;\n      H5 = H5 + f | 0;\n      H6 = H6 + g | 0;\n      H7 = H7 + h | 0;\n    }\n\n    function _core_heap(offset) {\n      offset = offset | 0;\n\n      _core(HEAP[offset | 0] << 24 | HEAP[offset | 1] << 16 | HEAP[offset | 2] << 8 | HEAP[offset | 3], HEAP[offset | 4] << 24 | HEAP[offset | 5] << 16 | HEAP[offset | 6] << 8 | HEAP[offset | 7], HEAP[offset | 8] << 24 | HEAP[offset | 9] << 16 | HEAP[offset | 10] << 8 | HEAP[offset | 11], HEAP[offset | 12] << 24 | HEAP[offset | 13] << 16 | HEAP[offset | 14] << 8 | HEAP[offset | 15], HEAP[offset | 16] << 24 | HEAP[offset | 17] << 16 | HEAP[offset | 18] << 8 | HEAP[offset | 19], HEAP[offset | 20] << 24 | HEAP[offset | 21] << 16 | HEAP[offset | 22] << 8 | HEAP[offset | 23], HEAP[offset | 24] << 24 | HEAP[offset | 25] << 16 | HEAP[offset | 26] << 8 | HEAP[offset | 27], HEAP[offset | 28] << 24 | HEAP[offset | 29] << 16 | HEAP[offset | 30] << 8 | HEAP[offset | 31], HEAP[offset | 32] << 24 | HEAP[offset | 33] << 16 | HEAP[offset | 34] << 8 | HEAP[offset | 35], HEAP[offset | 36] << 24 | HEAP[offset | 37] << 16 | HEAP[offset | 38] << 8 | HEAP[offset | 39], HEAP[offset | 40] << 24 | HEAP[offset | 41] << 16 | HEAP[offset | 42] << 8 | HEAP[offset | 43], HEAP[offset | 44] << 24 | HEAP[offset | 45] << 16 | HEAP[offset | 46] << 8 | HEAP[offset | 47], HEAP[offset | 48] << 24 | HEAP[offset | 49] << 16 | HEAP[offset | 50] << 8 | HEAP[offset | 51], HEAP[offset | 52] << 24 | HEAP[offset | 53] << 16 | HEAP[offset | 54] << 8 | HEAP[offset | 55], HEAP[offset | 56] << 24 | HEAP[offset | 57] << 16 | HEAP[offset | 58] << 8 | HEAP[offset | 59], HEAP[offset | 60] << 24 | HEAP[offset | 61] << 16 | HEAP[offset | 62] << 8 | HEAP[offset | 63]);\n    } // offset — multiple of 32\n\n\n    function _state_to_heap(output) {\n      output = output | 0;\n      HEAP[output | 0] = H0 >>> 24;\n      HEAP[output | 1] = H0 >>> 16 & 255;\n      HEAP[output | 2] = H0 >>> 8 & 255;\n      HEAP[output | 3] = H0 & 255;\n      HEAP[output | 4] = H1 >>> 24;\n      HEAP[output | 5] = H1 >>> 16 & 255;\n      HEAP[output | 6] = H1 >>> 8 & 255;\n      HEAP[output | 7] = H1 & 255;\n      HEAP[output | 8] = H2 >>> 24;\n      HEAP[output | 9] = H2 >>> 16 & 255;\n      HEAP[output | 10] = H2 >>> 8 & 255;\n      HEAP[output | 11] = H2 & 255;\n      HEAP[output | 12] = H3 >>> 24;\n      HEAP[output | 13] = H3 >>> 16 & 255;\n      HEAP[output | 14] = H3 >>> 8 & 255;\n      HEAP[output | 15] = H3 & 255;\n      HEAP[output | 16] = H4 >>> 24;\n      HEAP[output | 17] = H4 >>> 16 & 255;\n      HEAP[output | 18] = H4 >>> 8 & 255;\n      HEAP[output | 19] = H4 & 255;\n      HEAP[output | 20] = H5 >>> 24;\n      HEAP[output | 21] = H5 >>> 16 & 255;\n      HEAP[output | 22] = H5 >>> 8 & 255;\n      HEAP[output | 23] = H5 & 255;\n      HEAP[output | 24] = H6 >>> 24;\n      HEAP[output | 25] = H6 >>> 16 & 255;\n      HEAP[output | 26] = H6 >>> 8 & 255;\n      HEAP[output | 27] = H6 & 255;\n      HEAP[output | 28] = H7 >>> 24;\n      HEAP[output | 29] = H7 >>> 16 & 255;\n      HEAP[output | 30] = H7 >>> 8 & 255;\n      HEAP[output | 31] = H7 & 255;\n    }\n\n    function reset() {\n      H0 = 0x6a09e667;\n      H1 = 0xbb67ae85;\n      H2 = 0x3c6ef372;\n      H3 = 0xa54ff53a;\n      H4 = 0x510e527f;\n      H5 = 0x9b05688c;\n      H6 = 0x1f83d9ab;\n      H7 = 0x5be0cd19;\n      TOTAL0 = TOTAL1 = 0;\n    }\n\n    function init(h0, h1, h2, h3, h4, h5, h6, h7, total0, total1) {\n      h0 = h0 | 0;\n      h1 = h1 | 0;\n      h2 = h2 | 0;\n      h3 = h3 | 0;\n      h4 = h4 | 0;\n      h5 = h5 | 0;\n      h6 = h6 | 0;\n      h7 = h7 | 0;\n      total0 = total0 | 0;\n      total1 = total1 | 0;\n      H0 = h0;\n      H1 = h1;\n      H2 = h2;\n      H3 = h3;\n      H4 = h4;\n      H5 = h5;\n      H6 = h6;\n      H7 = h7;\n      TOTAL0 = total0;\n      TOTAL1 = total1;\n    } // offset — multiple of 64\n\n\n    function process(offset, length) {\n      offset = offset | 0;\n      length = length | 0;\n      var hashed = 0;\n      if (offset & 63) return -1;\n\n      while ((length | 0) >= 64) {\n        _core_heap(offset);\n\n        offset = offset + 64 | 0;\n        length = length - 64 | 0;\n        hashed = hashed + 64 | 0;\n      }\n\n      TOTAL0 = TOTAL0 + hashed | 0;\n      if (TOTAL0 >>> 0 < hashed >>> 0) TOTAL1 = TOTAL1 + 1 | 0;\n      return hashed | 0;\n    } // offset — multiple of 64\n    // output — multiple of 32\n\n\n    function finish(offset, length, output) {\n      offset = offset | 0;\n      length = length | 0;\n      output = output | 0;\n      var hashed = 0,\n          i = 0;\n      if (offset & 63) return -1;\n      if (~output) if (output & 31) return -1;\n\n      if ((length | 0) >= 64) {\n        hashed = process(offset, length) | 0;\n        if ((hashed | 0) == -1) return -1;\n        offset = offset + hashed | 0;\n        length = length - hashed | 0;\n      }\n\n      hashed = hashed + length | 0;\n      TOTAL0 = TOTAL0 + length | 0;\n      if (TOTAL0 >>> 0 < length >>> 0) TOTAL1 = TOTAL1 + 1 | 0;\n      HEAP[offset | length] = 0x80;\n\n      if ((length | 0) >= 56) {\n        for (i = length + 1 | 0; (i | 0) < 64; i = i + 1 | 0) HEAP[offset | i] = 0x00;\n\n        _core_heap(offset);\n\n        length = 0;\n        HEAP[offset | 0] = 0;\n      }\n\n      for (i = length + 1 | 0; (i | 0) < 59; i = i + 1 | 0) HEAP[offset | i] = 0;\n\n      HEAP[offset | 56] = TOTAL1 >>> 21 & 255;\n      HEAP[offset | 57] = TOTAL1 >>> 13 & 255;\n      HEAP[offset | 58] = TOTAL1 >>> 5 & 255;\n      HEAP[offset | 59] = TOTAL1 << 3 & 255 | TOTAL0 >>> 29;\n      HEAP[offset | 60] = TOTAL0 >>> 21 & 255;\n      HEAP[offset | 61] = TOTAL0 >>> 13 & 255;\n      HEAP[offset | 62] = TOTAL0 >>> 5 & 255;\n      HEAP[offset | 63] = TOTAL0 << 3 & 255;\n\n      _core_heap(offset);\n\n      if (~output) _state_to_heap(output);\n      return hashed | 0;\n    }\n\n    function hmac_reset() {\n      H0 = I0;\n      H1 = I1;\n      H2 = I2;\n      H3 = I3;\n      H4 = I4;\n      H5 = I5;\n      H6 = I6;\n      H7 = I7;\n      TOTAL0 = 64;\n      TOTAL1 = 0;\n    }\n\n    function _hmac_opad() {\n      H0 = O0;\n      H1 = O1;\n      H2 = O2;\n      H3 = O3;\n      H4 = O4;\n      H5 = O5;\n      H6 = O6;\n      H7 = O7;\n      TOTAL0 = 64;\n      TOTAL1 = 0;\n    }\n\n    function hmac_init(p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15) {\n      p0 = p0 | 0;\n      p1 = p1 | 0;\n      p2 = p2 | 0;\n      p3 = p3 | 0;\n      p4 = p4 | 0;\n      p5 = p5 | 0;\n      p6 = p6 | 0;\n      p7 = p7 | 0;\n      p8 = p8 | 0;\n      p9 = p9 | 0;\n      p10 = p10 | 0;\n      p11 = p11 | 0;\n      p12 = p12 | 0;\n      p13 = p13 | 0;\n      p14 = p14 | 0;\n      p15 = p15 | 0; // opad\n\n      reset();\n\n      _core(p0 ^ 0x5c5c5c5c, p1 ^ 0x5c5c5c5c, p2 ^ 0x5c5c5c5c, p3 ^ 0x5c5c5c5c, p4 ^ 0x5c5c5c5c, p5 ^ 0x5c5c5c5c, p6 ^ 0x5c5c5c5c, p7 ^ 0x5c5c5c5c, p8 ^ 0x5c5c5c5c, p9 ^ 0x5c5c5c5c, p10 ^ 0x5c5c5c5c, p11 ^ 0x5c5c5c5c, p12 ^ 0x5c5c5c5c, p13 ^ 0x5c5c5c5c, p14 ^ 0x5c5c5c5c, p15 ^ 0x5c5c5c5c);\n\n      O0 = H0;\n      O1 = H1;\n      O2 = H2;\n      O3 = H3;\n      O4 = H4;\n      O5 = H5;\n      O6 = H6;\n      O7 = H7; // ipad\n\n      reset();\n\n      _core(p0 ^ 0x36363636, p1 ^ 0x36363636, p2 ^ 0x36363636, p3 ^ 0x36363636, p4 ^ 0x36363636, p5 ^ 0x36363636, p6 ^ 0x36363636, p7 ^ 0x36363636, p8 ^ 0x36363636, p9 ^ 0x36363636, p10 ^ 0x36363636, p11 ^ 0x36363636, p12 ^ 0x36363636, p13 ^ 0x36363636, p14 ^ 0x36363636, p15 ^ 0x36363636);\n\n      I0 = H0;\n      I1 = H1;\n      I2 = H2;\n      I3 = H3;\n      I4 = H4;\n      I5 = H5;\n      I6 = H6;\n      I7 = H7;\n      TOTAL0 = 64;\n      TOTAL1 = 0;\n    } // offset — multiple of 64\n    // output — multiple of 32\n\n\n    function hmac_finish(offset, length, output) {\n      offset = offset | 0;\n      length = length | 0;\n      output = output | 0;\n      var t0 = 0,\n          t1 = 0,\n          t2 = 0,\n          t3 = 0,\n          t4 = 0,\n          t5 = 0,\n          t6 = 0,\n          t7 = 0,\n          hashed = 0;\n      if (offset & 63) return -1;\n      if (~output) if (output & 31) return -1;\n      hashed = finish(offset, length, -1) | 0;\n      t0 = H0, t1 = H1, t2 = H2, t3 = H3, t4 = H4, t5 = H5, t6 = H6, t7 = H7;\n\n      _hmac_opad();\n\n      _core(t0, t1, t2, t3, t4, t5, t6, t7, 0x80000000, 0, 0, 0, 0, 0, 0, 768);\n\n      if (~output) _state_to_heap(output);\n      return hashed | 0;\n    } // salt is assumed to be already processed\n    // offset — multiple of 64\n    // output — multiple of 32\n\n\n    function pbkdf2_generate_block(offset, length, block, count, output) {\n      offset = offset | 0;\n      length = length | 0;\n      block = block | 0;\n      count = count | 0;\n      output = output | 0;\n      var h0 = 0,\n          h1 = 0,\n          h2 = 0,\n          h3 = 0,\n          h4 = 0,\n          h5 = 0,\n          h6 = 0,\n          h7 = 0,\n          t0 = 0,\n          t1 = 0,\n          t2 = 0,\n          t3 = 0,\n          t4 = 0,\n          t5 = 0,\n          t6 = 0,\n          t7 = 0;\n      if (offset & 63) return -1;\n      if (~output) if (output & 31) return -1; // pad block number into heap\n      // FIXME probable OOB write\n\n      HEAP[offset + length | 0] = block >>> 24;\n      HEAP[offset + length + 1 | 0] = block >>> 16 & 255;\n      HEAP[offset + length + 2 | 0] = block >>> 8 & 255;\n      HEAP[offset + length + 3 | 0] = block & 255; // finish first iteration\n\n      hmac_finish(offset, length + 4 | 0, -1) | 0;\n      h0 = t0 = H0, h1 = t1 = H1, h2 = t2 = H2, h3 = t3 = H3, h4 = t4 = H4, h5 = t5 = H5, h6 = t6 = H6, h7 = t7 = H7;\n      count = count - 1 | 0; // perform the rest iterations\n\n      while ((count | 0) > 0) {\n        hmac_reset();\n\n        _core(t0, t1, t2, t3, t4, t5, t6, t7, 0x80000000, 0, 0, 0, 0, 0, 0, 768);\n\n        t0 = H0, t1 = H1, t2 = H2, t3 = H3, t4 = H4, t5 = H5, t6 = H6, t7 = H7;\n\n        _hmac_opad();\n\n        _core(t0, t1, t2, t3, t4, t5, t6, t7, 0x80000000, 0, 0, 0, 0, 0, 0, 768);\n\n        t0 = H0, t1 = H1, t2 = H2, t3 = H3, t4 = H4, t5 = H5, t6 = H6, t7 = H7;\n        h0 = h0 ^ H0;\n        h1 = h1 ^ H1;\n        h2 = h2 ^ H2;\n        h3 = h3 ^ H3;\n        h4 = h4 ^ H4;\n        h5 = h5 ^ H5;\n        h6 = h6 ^ H6;\n        h7 = h7 ^ H7;\n        count = count - 1 | 0;\n      }\n\n      H0 = h0;\n      H1 = h1;\n      H2 = h2;\n      H3 = h3;\n      H4 = h4;\n      H5 = h5;\n      H6 = h6;\n      H7 = h7;\n      if (~output) _state_to_heap(output);\n      return 0;\n    }\n\n    return {\n      // SHA256\n      reset: reset,\n      init: init,\n      process: process,\n      finish: finish,\n      // HMAC-SHA256\n      hmac_reset: hmac_reset,\n      hmac_init: hmac_init,\n      hmac_finish: hmac_finish,\n      // PBKDF2-HMAC-SHA256\n      pbkdf2_generate_block: pbkdf2_generate_block\n    };\n  }\n\n  var _sha256_block_size = 64,\n      _sha256_hash_size = 32;\n\n  function sha256_constructor(options) {\n    options = options || {};\n    this.heap = _heap_init(Uint8Array, options);\n    this.asm = options.asm || sha256_asm(global, null, this.heap.buffer);\n    this.BLOCK_SIZE = _sha256_block_size;\n    this.HASH_SIZE = _sha256_hash_size;\n    this.reset();\n  }\n\n  sha256_constructor.BLOCK_SIZE = _sha256_block_size;\n  sha256_constructor.HASH_SIZE = _sha256_hash_size;\n  var sha256_prototype = sha256_constructor.prototype;\n  sha256_prototype.reset = hash_reset;\n  sha256_prototype.process = hash_process;\n  sha256_prototype.finish = hash_finish;\n  var sha256_instance = null;\n\n  function get_sha256_instance() {\n    if (sha256_instance === null) sha256_instance = new sha256_constructor({\n      heapSize: 0x100000\n    });\n    return sha256_instance;\n  }\n  /**\n   * SHA256 exports\n   */\n\n\n  function sha256_bytes(data) {\n    if (data === undefined) throw new SyntaxError(\"data required\");\n    return get_sha256_instance().reset().process(data).finish().result;\n  }\n\n  function sha256_hex(data) {\n    var result = sha256_bytes(data);\n    return bytes_to_hex(result);\n  }\n\n  function sha256_base64(data) {\n    var result = sha256_bytes(data);\n    return bytes_to_base64(result);\n  }\n\n  sha256_constructor.bytes = sha256_bytes;\n  sha256_constructor.hex = sha256_hex;\n  sha256_constructor.base64 = sha256_base64;\n  exports.SHA256 = sha256_constructor;\n  'function' == typeof define && define.amd ? define([], function () {\n    return exports;\n  }) : 'object' == typeof module && module.exports ? module.exports = exports : global.asmCrypto = exports;\n  return exports;\n})({}, function () {\n  return this;\n}());","map":null,"metadata":{},"sourceType":"script"}