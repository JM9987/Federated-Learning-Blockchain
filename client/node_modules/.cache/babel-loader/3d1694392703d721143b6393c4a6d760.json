{"ast":null,"code":"'use strict';\n\nmodule.exports = Receptacle;\n\nvar toMS = require('ms');\n\nvar cache = Receptacle.prototype;\nvar counter = new Date() % 1e9;\n\nfunction getUID() {\n  return (Math.random() * 1e9 >>> 0) + counter++;\n}\n/**\n * Creates a cache with a maximum key size.\n *\n * @constructor\n * @param {Object} options\n * @param {Number} [options.max=Infinity] the maximum number of keys allowed in the cache (lru).\n * @param {Array} [options.items=[]] the default items in the cache.\n */\n\n\nfunction Receptacle(options) {\n  options = options || {};\n  this.id = options.id || getUID();\n  this.max = options.max || Infinity;\n  this.items = options.items || [];\n  this._lookup = {};\n  this.size = this.items.length;\n  this.lastModified = new Date(options.lastModified || new Date()); // Setup initial timers and indexes for the cache.\n\n  for (var item, ttl, i = this.items.length; i--;) {\n    item = this.items[i];\n    ttl = new Date(item.expires) - new Date();\n    this._lookup[item.key] = item;\n    if (ttl > 0) this.expire(item.key, ttl);else if (ttl <= 0) this.delete(item.key);\n  }\n}\n/**\n * Tests if a key is currently in the cache.\n * Does not check if slot is empty.\n *\n * @param {String} key - the key to retrieve from the cache.\n * @return {Boolean}\n */\n\n\ncache.has = function (key) {\n  return key in this._lookup;\n};\n/**\n * Retrieves a key from the cache and marks it as recently used.\n *\n * @param {String} key - the key to retrieve from the cache.\n * @return {*}\n */\n\n\ncache.get = function (key) {\n  if (!this.has(key)) return null;\n  var record = this._lookup[key]; // Update expiry for \"refresh\" keys\n\n  if (record.refresh) this.expire(key, record.refresh); // Move to front of the line.\n\n  this.items.splice(this.items.indexOf(record), 1);\n  this.items.push(record);\n  return record.value;\n};\n/**\n * Retrieves user meta data for a cached item.\n *\n * @param {String} key - the key to retrieve meta data from the cache.\n * @return {*}\n */\n\n\ncache.meta = function (key) {\n  if (!this.has(key)) return null;\n  var record = this._lookup[key];\n  if (!('meta' in record)) return null;\n  return record.meta;\n};\n/**\n * Puts a key into the cache with an optional expiry time.\n *\n * @param {String} key - the key for the value in the cache.\n * @param {*} value - the value to place at the key.\n * @param {Number} [options.ttl] - a time after which the key will be removed.\n * @return {Receptacle}\n */\n\n\ncache.set = function (key, value, options) {\n  var oldRecord = this._lookup[key];\n  var record = this._lookup[key] = {\n    key: key,\n    value: value\n  }; // Mark cache as modified.\n\n  this.lastModified = new Date();\n\n  if (oldRecord) {\n    // Replace an old key.\n    clearTimeout(oldRecord.timeout);\n    this.items.splice(this.items.indexOf(oldRecord), 1, record);\n  } else {\n    // Remove least used item if needed.\n    if (this.size >= this.max) this.delete(this.items[0].key); // Add a new key.\n\n    this.items.push(record);\n    this.size++;\n  }\n\n  if (options) {\n    // Setup key expiry.\n    if ('ttl' in options) this.expire(key, options.ttl); // Store user options in the record.\n\n    if ('meta' in options) record.meta = options.meta; // Mark a auto refresh key.\n\n    if (options.refresh) record.refresh = options.ttl;\n  }\n\n  return this;\n};\n/**\n * Deletes an item from the cache.\n *\n * @param {String} key - the key to remove.\n * @return {Receptacle}\n */\n\n\ncache.delete = function (key) {\n  var record = this._lookup[key];\n  if (!record) return false;\n  this.lastModified = new Date();\n  this.items.splice(this.items.indexOf(record), 1);\n  clearTimeout(record.timeout);\n  delete this._lookup[key];\n  this.size--;\n  return this;\n};\n/**\n * Utility to register a key that will be removed after some time.\n *\n * @param {String} key - the key to remove.\n * @param {Number} [ms] - the timeout before removal.\n * @return {Receptacle}\n */\n\n\ncache.expire = function (key, ttl) {\n  var ms = ttl || 0;\n  var record = this._lookup[key];\n  if (!record) return this;\n  if (typeof ms === 'string') ms = toMS(ttl);\n  if (typeof ms !== 'number') throw new TypeError('Expiration time must be a string or number.');\n  clearTimeout(record.timeout);\n  record.timeout = setTimeout(this.delete.bind(this, record.key), ms);\n  record.expires = Number(new Date()) + ms;\n  return this;\n};\n/**\n * Deletes all items from the cache.\n * @return {Receptacle}\n */\n\n\ncache.clear = function () {\n  for (var i = this.items.length; i--;) this.delete(this.items[i].key);\n\n  return this;\n};\n/**\n * Fixes serialization issues in polyfilled environments.\n * Ensures non-cyclical serialized object.\n */\n\n\ncache.toJSON = function () {\n  var items = new Array(this.items.length);\n  var item;\n\n  for (var i = items.length; i--;) {\n    item = this.items[i];\n    items[i] = {\n      key: item.key,\n      meta: item.meta,\n      value: item.value,\n      expires: item.expires,\n      refresh: item.refresh\n    };\n  }\n\n  return {\n    id: this.id,\n    max: isFinite(this.max) ? this.max : undefined,\n    lastModified: this.lastModified,\n    items: items\n  };\n};","map":null,"metadata":{},"sourceType":"script"}