{"ast":null,"code":"'use strict';\n\nconst CID = require('cids');\n\nconst log = require('debug')('ipfs:repo:gc');\n\nconst _require = require('../../utils'),\n      MFS_ROOT_KEY = _require.MFS_ROOT_KEY;\n\nconst withTimeoutOption = require('ipfs-core-utils/src/with-timeout-option');\n\nconst _require2 = require('interface-datastore'),\n      Errors = _require2.Errors;\n\nconst ERR_NOT_FOUND = Errors.notFoundError().code;\n\nconst _require3 = require('streaming-iterables'),\n      parallelMerge = _require3.parallelMerge,\n      transform = _require3.transform,\n      map = _require3.map;\n\nconst multibase = require('multibase'); // Limit on the number of parallel block remove operations\n\n\nconst BLOCK_RM_CONCURRENCY = 256;\n/**\n * Perform mark and sweep garbage collection\n *\n * @param {Object} config\n * @param {import('.').GCLock} config.gcLock\n * @param {import('.').Pin} config.pin\n * @param {import('.').Refs} config.refs\n * @param {import('.').Repo} config.repo\n */\n\nmodule.exports = ({\n  gcLock,\n  pin,\n  refs,\n  repo\n}) => {\n  /**\n   * @param {AbortOptions} [_options]\n   * @returns {AsyncIterable<Notification>}\n   */\n  async function* gc(_options = {}) {\n    const start = Date.now();\n    log('Creating set of marked blocks');\n    const release = await gcLock.writeLock();\n\n    try {\n      // Mark all blocks that are being used\n      const markedSet = await createMarkedSet({\n        pin,\n        refs,\n        repo\n      }); // Get all blocks keys from the blockstore\n      // @ts-ignore - TS is not aware of keysOnly overload\n\n      const blockKeys = repo.blocks.query({\n        keysOnly: true\n      }); // Delete blocks that are not being used\n\n      yield* deleteUnmarkedBlocks({\n        repo\n      }, markedSet, blockKeys);\n      log(\"Complete (\".concat(Date.now() - start, \"ms)\"));\n    } finally {\n      release();\n    }\n  }\n\n  return withTimeoutOption(gc);\n}; // Get Set of CIDs of blocks to keep\n\n\nasync function createMarkedSet({\n  pin,\n  refs,\n  repo\n}) {\n  const pinsSource = map(({\n    cid\n  }) => cid, pin.ls());\n\n  const mfsSource = async function* () {\n    let mh;\n\n    try {\n      mh = await repo.root.get(MFS_ROOT_KEY);\n    } catch (err) {\n      if (err.code === ERR_NOT_FOUND) {\n        log('No blocks in MFS');\n        return;\n      }\n\n      throw err;\n    }\n\n    const rootCid = new CID(mh);\n    yield rootCid;\n\n    for await (const _ref of refs(rootCid, {\n      recursive: true\n    })) {\n      const ref = _ref.ref;\n      yield new CID(ref);\n    }\n  }();\n\n  const output = new Set();\n\n  for await (const cid of parallelMerge(pinsSource, mfsSource)) {\n    output.add(multibase.encode('base32', cid.multihash).toString());\n  }\n\n  return output;\n} // Delete all blocks that are not marked as in use\n\n\nasync function* deleteUnmarkedBlocks({\n  repo\n}, markedSet, blockKeys) {\n  // Iterate through all blocks and find those that are not in the marked set\n  // blockKeys yields { key: Key() }\n  let blocksCount = 0;\n  let removedBlocksCount = 0;\n\n  const removeBlock = async cid => {\n    blocksCount++;\n\n    try {\n      const b32 = multibase.encode('base32', cid.multihash).toString();\n      if (markedSet.has(b32)) return null;\n      const res = {\n        cid\n      };\n\n      try {\n        await repo.blocks.delete(cid);\n        removedBlocksCount++;\n      } catch (err) {\n        res.err = new Error(\"Could not delete block with CID \".concat(cid, \": \").concat(err.message));\n      }\n\n      return res;\n    } catch (err) {\n      const msg = \"Could delete block with CID \".concat(cid);\n      log(msg, err);\n      return {\n        err: new Error(msg + \": \".concat(err.message))\n      };\n    }\n  };\n\n  for await (const res of transform(BLOCK_RM_CONCURRENCY, removeBlock, blockKeys)) {\n    // filter nulls (blocks that were retained)\n    if (res) yield res;\n  }\n\n  log(\"Marked set has \".concat(markedSet.size, \" unique blocks. Blockstore has \").concat(blocksCount, \" blocks. \") + \"Deleted \".concat(removedBlocksCount, \" blocks.\"));\n}\n/**\n * @typedef {import('../../utils').AbortOptions} AbortOptions\n *\n * @typedef {Err|BlockID} Notification\n *\n * @typedef {Object} Err\n * @property {void} [cid]\n * @property {Error} err\n *\n * @typedef {Object} BlockID\n * @property {CID} cid\n * @property {void} [err]\n *\n * @typedef {import('interface-datastore').Key} Key\n */","map":null,"metadata":{},"sourceType":"script"}