{"ast":null,"code":"/* eslint-disable no-undef */\n'use strict';\n\nconst _require = require('./http/fetch'),\n      fetch = _require.fetch,\n      Request = _require.Request,\n      Headers = _require.Headers;\n\nconst _require2 = require('./http/error'),\n      TimeoutError = _require2.TimeoutError,\n      HTTPError = _require2.HTTPError;\n\nconst merge = require('merge-options').bind({\n  ignoreUndefined: true\n});\n\nconst _require3 = require('iso-url'),\n      URL = _require3.URL,\n      URLSearchParams = _require3.URLSearchParams;\n\nconst _require4 = require('native-abort-controller'),\n      AbortController = _require4.AbortController;\n\nconst anySignal = require('any-signal');\n/**\n * @typedef {import('native-fetch').Response} Response\n * @typedef {import('stream').Readable} NodeReadableStream\n * @typedef {import('stream').Duplex} NodeDuplexStream\n * @typedef {import('./types').HTTPOptions} HTTPOptions\n */\n\n/**\n * @template TResponse\n * @param {Promise<TResponse>} promise\n * @param {number | undefined} ms\n * @param {AbortController} abortController\n * @returns {Promise<TResponse>}\n */\n\n\nconst timeout = (promise, ms, abortController) => {\n  if (ms === undefined) {\n    return promise;\n  }\n\n  const start = Date.now();\n\n  const timedOut = () => {\n    const time = Date.now() - start;\n    return time >= ms;\n  };\n\n  return new Promise((resolve, reject) => {\n    const timeoutID = setTimeout(() => {\n      if (timedOut()) {\n        reject(new TimeoutError());\n        abortController.abort();\n      }\n    }, ms);\n    /**\n     * @param {(value: any) => void } next\n     */\n\n    const after = next => {\n      /**\n       * @param {any} res\n       */\n      const fn = res => {\n        clearTimeout(timeoutID);\n\n        if (timedOut()) {\n          reject(new TimeoutError());\n          return;\n        }\n\n        next(res);\n      };\n\n      return fn;\n    };\n\n    promise.then(after(resolve), after(reject));\n  });\n};\n\nconst defaults = {\n  throwHttpErrors: true,\n  credentials: 'same-origin'\n};\n\nclass HTTP {\n  /**\n   *\n   * @param {HTTPOptions} options\n   */\n  constructor(options = {}) {\n    /** @type {HTTPOptions} */\n    this.opts = merge(defaults, options);\n  }\n  /**\n   * Fetch\n   *\n   * @param {string | Request} resource\n   * @param {HTTPOptions} options\n   * @returns {Promise<Response>}\n   */\n\n\n  async fetch(resource, options = {}) {\n    /** @type {HTTPOptions} */\n    const opts = merge(this.opts, options);\n    const headers = new Headers(opts.headers); // validate resource type\n\n    if (typeof resource !== 'string' && !(resource instanceof URL || resource instanceof Request)) {\n      throw new TypeError('`resource` must be a string, URL, or Request');\n    }\n\n    const url = new URL(resource.toString(), opts.base);\n    const searchParams = opts.searchParams,\n          transformSearchParams = opts.transformSearchParams,\n          json = opts.json;\n\n    if (searchParams) {\n      if (typeof transformSearchParams === 'function') {\n        // @ts-ignore\n        url.search = transformSearchParams(new URLSearchParams(opts.searchParams));\n      } else {\n        // @ts-ignore\n        url.search = new URLSearchParams(opts.searchParams);\n      }\n    }\n\n    if (json) {\n      opts.body = JSON.stringify(opts.json);\n      headers.set('content-type', 'application/json');\n    }\n\n    const abortController = new AbortController(); // @ts-ignore\n\n    const signal = anySignal([abortController.signal, opts.signal]);\n    const response = await timeout(fetch(url.toString(), { ...opts,\n      signal,\n      timeout: undefined,\n      headers\n    }), opts.timeout, abortController);\n\n    if (!response.ok && opts.throwHttpErrors) {\n      if (opts.handleError) {\n        await opts.handleError(response);\n      }\n\n      throw new HTTPError(response);\n    }\n\n    response.iterator = function () {\n      return fromStream(response.body);\n    };\n\n    response.ndjson = async function* () {\n      for await (const chunk of ndjson(response.iterator())) {\n        if (options.transform) {\n          yield options.transform(chunk);\n        } else {\n          yield chunk;\n        }\n      }\n    };\n\n    return response;\n  }\n  /**\n   * @param {string | Request} resource\n   * @param {HTTPOptions} options\n   * @returns {Promise<Response>}\n   */\n\n\n  post(resource, options = {}) {\n    return this.fetch(resource, { ...options,\n      method: 'POST'\n    });\n  }\n  /**\n   * @param {string | Request} resource\n   * @param {HTTPOptions} options\n   * @returns {Promise<Response>}\n   */\n\n\n  get(resource, options = {}) {\n    return this.fetch(resource, { ...options,\n      method: 'GET'\n    });\n  }\n  /**\n   * @param {string | Request} resource\n   * @param {HTTPOptions} options\n   * @returns {Promise<Response>}\n   */\n\n\n  put(resource, options = {}) {\n    return this.fetch(resource, { ...options,\n      method: 'PUT'\n    });\n  }\n  /**\n   * @param {string | Request} resource\n   * @param {HTTPOptions} options\n   * @returns {Promise<Response>}\n   */\n\n\n  delete(resource, options = {}) {\n    return this.fetch(resource, { ...options,\n      method: 'DELETE'\n    });\n  }\n  /**\n   * @param {string | Request} resource\n   * @param {HTTPOptions} options\n   * @returns {Promise<Response>}\n   */\n\n\n  options(resource, options = {}) {\n    return this.fetch(resource, { ...options,\n      method: 'OPTIONS'\n    });\n  }\n\n}\n/**\n * Parses NDJSON chunks from an iterator\n *\n * @param {AsyncIterable<Uint8Array>} source\n * @returns {AsyncIterable<any>}\n */\n\n\nconst ndjson = async function* (source) {\n  const decoder = new TextDecoder();\n  let buf = '';\n\n  for await (const chunk of source) {\n    buf += decoder.decode(chunk, {\n      stream: true\n    });\n    const lines = buf.split(/\\r?\\n/);\n\n    for (let i = 0; i < lines.length - 1; i++) {\n      const l = lines[i].trim();\n\n      if (l.length > 0) {\n        yield JSON.parse(l);\n      }\n    }\n\n    buf = lines[lines.length - 1];\n  }\n\n  buf += decoder.decode();\n  buf = buf.trim();\n\n  if (buf.length !== 0) {\n    yield JSON.parse(buf);\n  }\n};\n/**\n * Stream to AsyncIterable\n *\n * @template TChunk\n * @param {ReadableStream<TChunk> | NodeReadableStream | null} source\n * @returns {AsyncIterable<TChunk>}\n */\n\n\nconst fromStream = source => {\n  // Workaround for https://github.com/node-fetch/node-fetch/issues/766\n  if (isNodeReadableStream(source)) {\n    const iter = source[Symbol.asyncIterator]();\n    return {\n      [Symbol.asyncIterator]() {\n        return {\n          next: iter.next.bind(iter),\n\n          return(value) {\n            source.destroy();\n\n            if (typeof iter.return === 'function') {\n              return iter.return();\n            }\n\n            return Promise.resolve({\n              done: true,\n              value\n            });\n          }\n\n        };\n      }\n\n    };\n  }\n\n  if (isWebReadableStream(source)) {\n    const reader = source.getReader();\n    return async function* () {\n      try {\n        while (true) {\n          // Read from the stream\n          const _ref = await reader.read(),\n                done = _ref.done,\n                value = _ref.value; // Exit if we're done\n\n\n          if (done) return; // Else yield the chunk\n\n          if (value) {\n            yield value;\n          }\n        }\n      } finally {\n        reader.releaseLock();\n      }\n    }();\n  }\n\n  if (isAsyncIterable(source)) {\n    return source;\n  }\n\n  throw new TypeError('Body can\\'t be converted to AsyncIterable');\n};\n/**\n * Check if it's an AsyncIterable\n *\n * @template {unknown} TChunk\n * @template {any} Other\n * @param {Other|AsyncIterable<TChunk>} value\n * @returns {value is AsyncIterable<TChunk>}\n */\n\n\nconst isAsyncIterable = value => {\n  return typeof value === 'object' && value !== null && typeof\n  /** @type {any} */\n  value[Symbol.asyncIterator] === 'function';\n};\n/**\n * Check for web readable stream\n *\n * @template {unknown} TChunk\n * @template {any} Other\n * @param {Other|ReadableStream<TChunk>} value\n * @returns {value is ReadableStream<TChunk>}\n */\n\n\nconst isWebReadableStream = value => {\n  return value && typeof\n  /** @type {any} */\n  value.getReader === 'function';\n};\n/**\n * @param {any} value\n * @returns {value is NodeReadableStream}\n */\n\n\nconst isNodeReadableStream = value => Object.prototype.hasOwnProperty.call(value, 'readable') && Object.prototype.hasOwnProperty.call(value, 'writable');\n\nHTTP.HTTPError = HTTPError;\nHTTP.TimeoutError = TimeoutError;\nHTTP.streamToAsyncIterator = fromStream;\n/**\n * @param {string | Request} resource\n * @param {HTTPOptions} [options]\n * @returns {Promise<Response>}\n */\n\nHTTP.post = (resource, options) => new HTTP(options).post(resource, options);\n/**\n * @param {string | Request} resource\n * @param {HTTPOptions} [options]\n * @returns {Promise<Response>}\n */\n\n\nHTTP.get = (resource, options) => new HTTP(options).get(resource, options);\n/**\n * @param {string | Request} resource\n * @param {HTTPOptions} [options]\n * @returns {Promise<Response>}\n */\n\n\nHTTP.put = (resource, options) => new HTTP(options).put(resource, options);\n/**\n * @param {string | Request} resource\n * @param {HTTPOptions} [options]\n * @returns {Promise<Response>}\n */\n\n\nHTTP.delete = (resource, options) => new HTTP(options).delete(resource, options);\n/**\n * @param {string | Request} resource\n * @param {HTTPOptions} [options]\n * @returns {Promise<Response>}\n */\n\n\nHTTP.options = (resource, options) => new HTTP(options).options(resource, options);\n\nmodule.exports = HTTP;","map":null,"metadata":{},"sourceType":"script"}