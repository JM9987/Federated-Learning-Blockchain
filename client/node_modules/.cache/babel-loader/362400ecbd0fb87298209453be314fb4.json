{"ast":null,"code":"'use strict';\n\nvar _slicedToArray = require(\"/home/ubuntu/Codigo_Javier/client/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nconst debug = require('debug');\n\nconst log = Object.assign(debug('libp2p:dialer'), {\n  error: debug('libp2p:dialer:err')\n});\n\nconst errCode = require('err-code');\n\nconst multiaddr = require('multiaddr');\n\nconst TimeoutController = require('timeout-abort-controller');\n\nconst _require = require('any-signal'),\n      anySignal = _require.anySignal;\n\nconst DialRequest = require('./dial-request');\n\nconst _require2 = require('libp2p-utils/src/address-sort'),\n      publicAddressesFirst = _require2.publicAddressesFirst;\n\nconst getPeer = require('../get-peer');\n\nconst _require3 = require('../errors'),\n      codes = _require3.codes;\n\nconst _require4 = require('../constants'),\n      DIAL_TIMEOUT = _require4.DIAL_TIMEOUT,\n      MAX_PARALLEL_DIALS = _require4.MAX_PARALLEL_DIALS,\n      MAX_PER_PEER_DIALS = _require4.MAX_PER_PEER_DIALS;\n/**\n * @typedef {import('libp2p-interfaces/src/connection').Connection} Connection\n * @typedef {import('multiaddr')} Multiaddr\n * @typedef {import('peer-id')} PeerId\n * @typedef {import('../peer-store')} PeerStore\n * @typedef {import('../peer-store/address-book').Address} Address\n * @typedef {import('../transport-manager')} TransportManager\n */\n\n/**\n * @typedef {Object} DialerProperties\n * @property {PeerStore} peerStore\n * @property {TransportManager} transportManager\n *\n * @typedef {(addr:Multiaddr) => Promise<string[]>} Resolver\n *\n * @typedef {Object} DialerOptions\n * @property {(addresses: Address[]) => Address[]} [options.addressSorter = publicAddressesFirst] - Sort the known addresses of a peer before trying to dial.\n * @property {number} [concurrency = MAX_PARALLEL_DIALS] - Number of max concurrent dials.\n * @property {number} [perPeerLimit = MAX_PER_PEER_DIALS] - Number of max concurrent dials per peer.\n * @property {number} [timeout = DIAL_TIMEOUT] - How long a dial attempt is allowed to take.\n * @property {Record<string, Resolver>} [resolvers = {}] - multiaddr resolvers to use when dialing\n *\n * @typedef DialTarget\n * @property {string} id\n * @property {Multiaddr[]} addrs\n *\n * @typedef PendingDial\n * @property {DialRequest} dialRequest\n * @property {TimeoutController} controller\n * @property {Promise} promise\n * @property {function():void} destroy\n */\n\n\nclass Dialer {\n  /**\n   * @class\n   * @param {DialerProperties & DialerOptions} options\n   */\n  constructor({\n    transportManager,\n    peerStore,\n    addressSorter = publicAddressesFirst,\n    concurrency = MAX_PARALLEL_DIALS,\n    timeout = DIAL_TIMEOUT,\n    perPeerLimit = MAX_PER_PEER_DIALS,\n    resolvers = {}\n  }) {\n    this.transportManager = transportManager;\n    this.peerStore = peerStore;\n    this.addressSorter = addressSorter;\n    this.concurrency = concurrency;\n    this.timeout = timeout;\n    this.perPeerLimit = perPeerLimit;\n    this.tokens = [...new Array(concurrency)].map((_, index) => index);\n    this._pendingDials = new Map();\n\n    for (const _ref of Object.entries(resolvers)) {\n      var _ref2 = _slicedToArray(_ref, 2);\n\n      const key = _ref2[0];\n      const value = _ref2[1];\n      multiaddr.resolvers.set(key, value);\n    }\n  }\n  /**\n   * Clears any pending dials\n   */\n\n\n  destroy() {\n    for (const dial of this._pendingDials.values()) {\n      try {\n        dial.controller.abort();\n      } catch (err) {\n        log.error(err);\n      }\n    }\n\n    this._pendingDials.clear();\n  }\n  /**\n   * Connects to a given `peer` by dialing all of its known addresses.\n   * The dial to the first address that is successfully able to upgrade a connection\n   * will be used.\n   *\n   * @param {PeerId|Multiaddr|string} peer - The peer to dial\n   * @param {object} [options]\n   * @param {AbortSignal} [options.signal] - An AbortController signal\n   * @returns {Promise<Connection>}\n   */\n\n\n  async connectToPeer(peer, options = {}) {\n    const dialTarget = await this._createDialTarget(peer);\n\n    if (!dialTarget.addrs.length) {\n      throw errCode(new Error('The dial request has no addresses'), codes.ERR_NO_VALID_ADDRESSES);\n    }\n\n    const pendingDial = this._pendingDials.get(dialTarget.id) || this._createPendingDial(dialTarget, options);\n\n    try {\n      const connection = await pendingDial.promise;\n      log('dial succeeded to %s', dialTarget.id);\n      return connection;\n    } catch (err) {\n      // Error is a timeout\n      if (pendingDial.controller.signal.aborted) {\n        err.code = codes.ERR_TIMEOUT;\n      }\n\n      log.error(err);\n      throw err;\n    } finally {\n      pendingDial.destroy();\n    }\n  }\n  /**\n   * Creates a DialTarget. The DialTarget is used to create and track\n   * the DialRequest to a given peer.\n   * If a multiaddr is received it should be the first address attempted.\n   *\n   * @private\n   * @param {PeerId|Multiaddr|string} peer - A PeerId or Multiaddr\n   * @returns {Promise<DialTarget>}\n   */\n\n\n  async _createDialTarget(peer) {\n    const _getPeer = getPeer(peer),\n          id = _getPeer.id,\n          multiaddrs = _getPeer.multiaddrs;\n\n    if (multiaddrs) {\n      this.peerStore.addressBook.add(id, multiaddrs);\n    }\n\n    let knownAddrs = this.peerStore.addressBook.getMultiaddrsForPeer(id, this.addressSorter) || []; // If received a multiaddr to dial, it should be the first to use\n    // But, if we know other multiaddrs for the peer, we should try them too.\n\n    if (multiaddr.isMultiaddr(peer)) {\n      knownAddrs = knownAddrs.filter(addr => !peer.equals(addr));\n      knownAddrs.unshift(peer);\n    }\n\n    const addrs = [];\n\n    for (const a of knownAddrs) {\n      const resolvedAddrs = await this._resolve(a);\n      resolvedAddrs.forEach(ra => addrs.push(ra));\n    }\n\n    return {\n      id: id.toB58String(),\n      addrs\n    };\n  }\n  /**\n   * Creates a PendingDial that wraps the underlying DialRequest\n   *\n   * @private\n   * @param {DialTarget} dialTarget\n   * @param {object} [options]\n   * @param {AbortSignal} [options.signal] - An AbortController signal\n   * @returns {PendingDial}\n   */\n\n\n  _createPendingDial(dialTarget, options = {}) {\n    const dialAction = (addr, options) => {\n      if (options.signal.aborted) throw errCode(new Error('already aborted'), codes.ERR_ALREADY_ABORTED);\n      return this.transportManager.dial(addr, options);\n    };\n\n    const dialRequest = new DialRequest({\n      addrs: dialTarget.addrs,\n      dialAction,\n      dialer: this\n    }); // Combine the timeout signal and options.signal, if provided\n\n    const timeoutController = new TimeoutController(this.timeout);\n    const signals = [timeoutController.signal];\n    options.signal && signals.push(options.signal);\n    const signal = anySignal(signals);\n    const pendingDial = {\n      dialRequest,\n      controller: timeoutController,\n      promise: dialRequest.run({ ...options,\n        signal\n      }),\n      destroy: () => {\n        timeoutController.clear();\n\n        this._pendingDials.delete(dialTarget.id);\n      }\n    };\n\n    this._pendingDials.set(dialTarget.id, pendingDial);\n\n    return pendingDial;\n  }\n\n  getTokens(num) {\n    const total = Math.min(num, this.perPeerLimit, this.tokens.length);\n    const tokens = this.tokens.splice(0, total);\n    log('%d tokens request, returning %d, %d remaining', num, total, this.tokens.length);\n    return tokens;\n  }\n\n  releaseToken(token) {\n    // Guard against duplicate releases\n    if (this.tokens.indexOf(token) > -1) return;\n    log('token %d released', token);\n    this.tokens.push(token);\n  }\n  /**\n   * Resolve multiaddr recursively.\n   *\n   * @param {Multiaddr} ma\n   * @returns {Promise<Multiaddr[]>}\n   */\n\n\n  async _resolve(ma) {\n    // TODO: recursive logic should live in multiaddr once dns4/dns6 support is in place\n    // Now only supporting resolve for dnsaddr\n    const resolvableProto = ma.protoNames().includes('dnsaddr'); // Multiaddr is not resolvable? End recursion!\n\n    if (!resolvableProto) {\n      return [ma];\n    }\n\n    const resolvedMultiaddrs = await this._resolveRecord(ma);\n    const recursiveMultiaddrs = await Promise.all(resolvedMultiaddrs.map(nm => {\n      return this._resolve(nm);\n    }));\n    const addrs = recursiveMultiaddrs.flat();\n    return addrs.reduce((array, newM) => {\n      if (!array.find(m => m.equals(newM))) {\n        array.push(newM);\n      }\n\n      return array;\n    },\n    /** @type  {Multiaddr[]} */\n    []);\n  }\n  /**\n   * Resolve a given multiaddr. If this fails, an empty array will be returned\n   *\n   * @param {Multiaddr} ma\n   * @returns {Promise<Multiaddr[]>}\n   */\n\n\n  async _resolveRecord(ma) {\n    try {\n      ma = multiaddr(ma.toString()); // Use current multiaddr module\n\n      const multiaddrs = await ma.resolve();\n      return multiaddrs;\n    } catch (_) {\n      log.error(\"multiaddr \".concat(ma, \" could not be resolved\"));\n      return [];\n    }\n  }\n\n}\n\nmodule.exports = Dialer;","map":null,"metadata":{},"sourceType":"script"}