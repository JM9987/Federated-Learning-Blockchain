{"ast":null,"code":"'use strict';\n\nconst debug = require('debug');\n\nconst _require = require('parse-duration'),\n      parseDuration = _require.default;\n\nconst crypto = require('libp2p-crypto');\n\nconst errcode = require('err-code');\n\nconst log = Object.assign(debug('ipfs:name:publish'), {\n  error: debug('ipfs:name:publish:error')\n});\n\nconst _require2 = require('../../utils'),\n      OFFLINE_ERROR = _require2.OFFLINE_ERROR,\n      normalizePath = _require2.normalizePath;\n\nconst withTimeoutOption = require('ipfs-core-utils/src/with-timeout-option');\n\nconst _require3 = require('./utils'),\n      resolvePath = _require3.resolvePath;\n/**\n * IPNS - Inter-Planetary Naming System\n *\n * @param {Object} config\n * @param {import('.').IPNS} config.ipns\n * @param {import('.').DagReader} config.dagReader\n * @param {import('.').PeerId} config.peerId\n * @param {import('.').IsOnline} config.isOnline\n * @param {import('.').Keychain} config.keychain\n */\n\n\nmodule.exports = ({\n  ipns,\n  dagReader,\n  peerId,\n  isOnline,\n  keychain\n}) => {\n  const lookupKey = async keyName => {\n    if (keyName === 'self') {\n      return peerId.privKey;\n    }\n\n    try {\n      // We're exporting and immediately importing the key, so we can just use a throw away password\n      const pem = await keychain.exportKey(keyName, 'temp');\n      const privateKey = await crypto.keys.import(pem, 'temp');\n      return privateKey;\n    } catch (err) {\n      log.error(err);\n      throw errcode(err, 'ERR_CANNOT_GET_KEY');\n    }\n  };\n  /**\n   * IPNS is a PKI namespace, where names are the hashes of public keys, and\n   * the private key enables publishing new (signed) values. In both publish\n   * and resolve, the default name used is the node's own PeerID,\n   * which is the hash of its public key.\n   *\n   * @param {string} value - ipfs path of the object to be published.\n   * @param {PublishOptions} [options]\n   * @returns {Promise<PublishResult>}\n   * @example\n   * ```js\n   * // The address of your files.\n   * const addr = '/ipfs/QmbezGequPwcsWo8UL4wDF6a8hYwM1hmbzYv2mnKkEWaUp'\n   * const res = await ipfs.name.publish(addr)\n   * // You now have a res which contains two fields:\n   * //   - name: the name under which the content was published.\n   * //   - value: the \"real\" address to which Name points.\n   * console.log(`https://gateway.ipfs.io/ipns/${res.name}`)\n   * ```\n   */\n\n\n  async function publish(value, options = {}) {\n    const resolve = !(options.resolve === false);\n    const lifetime = options.lifetime || '24h';\n    const key = options.key || 'self';\n\n    if (!isOnline()) {\n      throw errcode(new Error(OFFLINE_ERROR), 'OFFLINE_ERROR');\n    } // TODO: params related logic should be in the core implementation\n    // Normalize path value\n\n\n    try {\n      value = normalizePath(value);\n    } catch (err) {\n      log.error(err);\n      throw err;\n    }\n\n    let pubLifetime = 0;\n\n    try {\n      pubLifetime = parseDuration(lifetime) || 0; // Calculate lifetime with nanoseconds precision\n\n      pubLifetime = parseFloat(pubLifetime.toFixed(6));\n    } catch (err) {\n      log.error(err);\n      throw err;\n    } // TODO: ttl human for cache\n\n\n    const results = await Promise.all([// verify if the path exists, if not, an error will stop the execution\n    lookupKey(key), resolve ? resolvePath({\n      ipns,\n      dagReader\n    }, value) : Promise.resolve()]); // Start publishing process\n\n    return ipns.publish(results[0], value, pubLifetime);\n  }\n\n  return withTimeoutOption(publish);\n};\n/**\n * @typedef {PublishSettings & AbortOptions} PublishOptions\n * ipfs publish options.\n *\n * @typedef {Object} PublishSettings\n * @property {boolean} [resolve=true] - Resolve given path before publishing.\n * @property {string} [lifetime='24h'] - Time duration of the record.\n * @property {string} [ttl] - Time duration this record should be cached.\n * @property {string} [key=self] - Name of the key to be used.\n * @property {boolean} [allowOffline=true] - When offline, save the IPNS record\n * to the the local datastore without broadcasting to the network instead of\n * simply failing.\n *\n * This option is not yet implemented in js-ipfs. See tracking issue [ipfs/js-ipfs#1997]\n * (https://github.com/ipfs/js-ipfs/issues/1997).\n *\n * @typedef {Object} PublishResult\n * @property {string} name\n * @property {string} value\n *\n * @typedef {import('.').AbortOptions} AbortOptions\n */","map":null,"metadata":{},"sourceType":"script"}